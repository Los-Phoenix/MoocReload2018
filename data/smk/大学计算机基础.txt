那我们现在来看有了硬件设计
有了冯诺依曼体系结构之后
整个计算机运转
的基本工作原理
我们把它叫做存储程序控制
那么这里面核心的思想
就是程序一词
在日常生活当中我们会
碰到各种各样的程序
运动会的安排是程序
没有程序比赛过程就会乱套
所有的运动赛完了
程序执行也就结束了
演唱会一台晚会的节目也是程序
所有节目演完了
程序执行也就结束了
新生入学报到的手续
也是一种程序
报到的手续办完了整个程序的
执行也就结束了
在这些地方程序
表示的都是按时间
先后次序
出现的事物
有时候人们用程序来表示处理
或工作的步骤
那么一部计算机发展
的历史就可以看作是计算机
程序精彩纷呈
层出不穷的历史
也是用程序
如何去调教计算机
让它为人类而工作的一部历史
我们来看一个很简单的例子
大家每天早上要去上学
看我们上学准备的这个程序
应该是怎样的
我的问题是希望你能做好上学的准备
你要完成的工作包括这些
请你排好一个程序
来完成所有的这五项上学准备的工作
那么这个程序就应该是
醒来 起床 洗漱 着装 吃早餐
通过这个例子希望大家能够
体会程序当中这个序
是非常重要的概念
同样我们在计算机当中也有程序
那么顺序程序是一类非常重要的
程序控制结构
我们再来看计算机当中的程序
那么计算机的本能就是能够
识别并且执行属于它
自己的一组机器指令
以此我们可以说
程序就是完成既定
任务的一组指令序列
那么计算机按照程序规定的流程
依次执行一条一条的指令
最终完成程序所要实现的目标
计算机的硬件系统最终
只能执行由机器指令组成的程序
那么大家在高中的信息技术课
中应该已经学过
计算机的硬件系统
它的工作原理是基于01表示
最根本的运算是二进制
所以我们可以说计算机的
母语是什么计算机的母语
就是0101
最终的指令
都是由0101所编好的
一组一组的01代码
那么程序我们刚才提到过
程序在执行之前
那么执行意味着我要使用CUP
在执行之前必须首先要装入内存
那么程序执行的时候CUP
负责从内存当中
逐条的去取出指令分析
识别指令最后来执行指令从而
从而完成了一条指令的执行周期
那么CUP本身就是这样周而
复始的工作直到程序的完成
刚才我们提到的0101指令
实际上是对指令
是指对计算机进行程序控制的最小单位
所有指令的集合称为计算机的指令系统
那么对于一条典型的指令而言
它包含有两个组成部分
这是机器指令的格式
指令当中首先要指明的是
我要执行什么样的操作
这就是机器指令格式当中
非常重要的一部分我们把叫做操作码
你要先告诉我
你要执行一个怎么样的操作
你是做加法 做减法
还是做数据传输
你先通过操作码来说明这件事
第二个
在机器指令当中需要指明的
就是你的操作数
你要做一个加法运算那么
谁来做这个加法运算
操作数据有的时候可能是
一个 两个或者是多个
操作码规定了机器
要执行什么样的操作
而操作数则指明了
这些操作
这个操作是建立在那些数据上的
程序则是一组指令的集合
指的是为完成一项特定任务
而用某种语言编写的
一组指令序列
计算机的这种工作模式
我们就把它叫做存储程序控制
这也是计算机工作的一个基本原理
存储程序控制这个计算机
工作的基本原理
也就决定了人们
使用计算机的一个基本模式
就是编写程序
然后再运行程序
计算机具备的两个基本能力
一个是能够存储程序
就是在程序  在计算机 计算工具
在计算装置运行过程当中
要有办法存储程序
第二个就是有了这样的程序之后
能够自动的按照指令顺序
或者自动的执行程序
CPU是珍贵的计算资源
它的运算速度是非常快的
这是多任务的一个根本的基础
即使在你的内存当中有多个应用程序启动
都装入了内存
那么由于CPU的运算速度非常快
它可以应付所有这些
程序的运行
那么给你的感觉就是所有的程序
似乎都在运行 都在使用CPU
但事实上并不是这样的
某一时刻CPU
只执行某个程序的某一条指令
由于它的运算速度非常快
所以足以应付多个程序的运行
所以给你的感觉就是这多个程序
都在执行当中
那么下面我们复习一下程序的概念
程序指的是为完成特定功能
用某种计算机语言编写的一组
指令的集合
这是我们所讲的程序
而进程是指的程序执行的过程
是程序的一次执行过程
也是系统进行资源分配和
调度的一个独立单位
这CPU实际上它并不直接
跟程序打交道
它直接跟进程打交道
它直接跟内存当中的进程打交道
操作系统进行资源管理
这些资源包括计算资源 包括CPU
也包括你的其它的像打印机
那么它进行资源分配和调度的独立单位
是进程
而同一个程序
可能有多个执行过程
也就有多个进程
从这我们可以看出进程和程序之间是有区别的
进程它是动态的 是暂时的
是一次执行的过程
而程序本身
是静态的 它是一个永久的概念
永久的存放在你的外存当中
那么程序的每一次执行
都构成了不同的进程
一个程序可以对应
多个进程
这个举个简单的例子
你比方说我有两个QQ号
我可以启动两个QQ程序
分别
对应我的两个不同的QQ号
但QQ程序本身就只有一个
进程启动之后进入内存
我们就不把它叫程序了 叫进程
那么进程待在内存当中
这些进程
有的时候会在CPU上运行
有的时候可能需要等待跟用户进行交互
那么它有着不同的状态
那么进程的监控
可以通过任务管理器来进行
我们可以在这里启动任务管理器
在这个下面这个任务栏点击鼠标右键
我们得到上下文相关的快捷菜单
这里面有任务管理器
打开任务管理器之后
这是你看到的有多个
应用程序在执行
我们进入进程
那么大家可以看到这就是系统当中
当前时刻所运行的所有进程
那么在这也可以看到同一个应用程序
它有两个运行的过程
而这两个运行的过程是不同的进程
有不同的进程标识
Windows的任务管理器
是操作系统提供给用户
来完成一些简单地进程管理
那么同一个应用程序 在这里可以看到两个
相同的应用程序
有不同的进程标识
同一个应用程序
我有两个运行过程
有两个运行的实体
同时存在于内存当中
那么这个操作系统的任务管理器
所能提供给用户的
简单的管理包括
如果某一个过程
某一个进程发生死锁了
或者没有响应了
我可以结束进程
所以我们可以总结一下进程的一个基本特征
那么进程
一个应用程序启动之后进入内存
我们就把它称为是进程
那么进程在内存当中并不是一直忙碌的工作的
实际上它是一个走走停停 间断性的
使用CPU完成计算的一个过程
所以进程本身是动态的
它是有一个生命周期的
应用程序启动之后 我们说创建了进程
那么进程在完成计算之后
就会消亡
这个进程就没有了
进程
所占据的内存空间也会释放
由创建而产生
由调度而执行
因等待
而暂停去等待某种资源
等待输入输出过程的完成
那么因完成这个进程
也就完成了它的使命周期
进程是具备独立性的
是系统进行资源分配和调度的独立单位
同时进程具备我们刚才所讲的并发性
是为了增强计算机处理能力和
提高资源利用率所采用的一种
同时操作的技术
这就是你在完成这部分工作
如果有相同的
如果我使用的是不同的硬件资源
那我可以
同样的在计算机的帮助下
在操作系统的调度下
去使用其它的硬件资源
这是操作系统的功能
由于进程具备
并发性 独立性 动态性
所以我们也可以说进程
是具备异步性的
每个进程以自己独立的
不可预知的态度进展
也就是说它是不可
不可再现的
所以这个进程这个时候没有响应了出现问题了
下一次可能就不会有这个问题了
就是我很难把同样的状况
再让它发生一次
因为很多现场
整个进程运行的现场
应用程序运行的现场
是不可再现的
计算机的系统是挺复杂的系统
这是一台一体机的内部
可以看到它里面有
各种各样的硬件
这是跟计算相关的
这是一台打印机 打印机的里面也
同样有各种各样的电子机械装置
有各种各样它的组成
这是一块网络连接卡
我要上网我需要
把计算机的数字信号信息
转换成能够在网络上传输的信号
完成转换工作的是由网卡来进行
使得这些资源能够协同工作
着中间有个非常重要的软件
这就是我们讲的最重要的系统软件
操作系统
一台计算机买回来
我们把它叫做裸机
裸机只含有硬件
机器买回来之后第一个要安装的软件
就是操作系统 有了操作系统之后
整个计算机系统在操作系统的
控制和管理之下
才能进行有效的工作
对于用户而言它并不
直接跟计算机的硬件打交道
它首先面对的就是操作系统
就像机器一启动 不管你使用windows
还是麒麟操作系统还是linus
首先面对的是操作系统的桌面
使用这个计算系统
去完成任务 所有的工作
都在操作系统的监控和管理之下
操作系统这个
概念英文叫做operating system
有的时候简称为OS
操作系统是管理计算机
硬件与软件资源的计算机程序
归根到底它是软件是程序
所以操作系统的功能总的来说
一方面向下管理计算机的所有
软硬件资源
我们把它叫做计算机的管家功能
另一方面向上
为用户提供服务
提供用户与计算机的交互接口
用户通过这些接口
来完成计算任务
并不真正跟计算机的硬件打交道
很多时候可以把操作系统
看作一个抽象机
它是对计算机硬件的一种抽象
这种抽象隐藏了底层的硬件细节
只要知道怎样使用这些硬件就好
对于如何使硬件运转起来的
过程和步骤交给操作系统去做
它对底层的硬件进行了封装
为用户提供应用和
服务的公共接口
用户是看不到这些硬件的
它通过接口感知硬件的存在
操作系统就像用户与计算机之间抽象机器
从这里也可以看的出
计算机的硬件部分可能有CPU
有内存有视频卡
有各种各样的硬件
我还可能连接了打印机
操作系统处在硬件和用户的应用之间
它向下管理计算机的硬件资源
同时为用户使用硬件提供服务接口
我们通过一个简单的计算任务
来体会一下操作系统在整个计算机系统
运行过程中起的作用
假设现在需要用文字处理软件
打印一个文档 看一下这个过程
需要打印一个文档 这个文档是
是用文字处理软件制作的
在文字处理软件中
我需要打印它
可以在菜单中找到打印的命令
文字处理软件打印命令首先发给谁
它把文档的打印命令首先
是发给了操作系统
这台机子本身连接了打印机
任何硬件加入到计算机系统当中
都要有跟操作系统报道的过程
这就是经常性的在你有新硬件
插入到计算机当中的时候
要安装它的驱动程序
驱动程序就是对应软件
跟操作报道的过程
你要告诉操作系统
我该怎么样使用你这个硬件
我怎样跟你打交道
怎样使你完成计算任务
这就是驱动程序所起的作用
这个操作系统中由于已经安装了
打印机的驱动程序
操作系统就会完成与打印机的通讯过程
告诉它需要打印这些文档
同时把文档数据发送给打印机
打印机就像只一直在睡眠
直到有人来唤醒我完成工作
现在接收到了打印命令
我一直在监听
等我接收到了打印命令 就开始工作
完成最终的打印工作
你可以看到在完成打印的过程中
操作系统都起到非常重要的作用
我要认识所有的硬件资源
每个硬件资源
在使用之前都有跟操作系统
报道的过程
而这个报道我们说是通过
设备驱动程序来完成的
整个完成打印的过程当中
并不是用户直接跟打印机打交道
而是操作系统
接收用户的命令
再去与打印机交互
完成最终的打印任务
我们来回顾一下
操作系统是计算机的管家
它要管理计算机的所有硬件资源
我们先看硬件
对于计算机而言
硬件资源包括那些内容
最重要的硬件资源
是计算的核心CPU
操作系统对CPU的管理叫进程管理
也就是处理机管理
冯诺依曼体系结构当中
把硬件分成了五大部件
核心部件是CPU
对CPU牵扯到的主要方面就是
现代的操作系统当中
我可能同时运行着
很多个程序
可能启动了浏览器去浏览外部网页
我也可能同时听着MP3
这边还制作着文档
这些都是应用程序
这些应用程序都进入了内存
只要进入内存
就有资格抢占CPU
到底是谁
来使用CPU完成计算
这就牵扯到关于CPU管理的问题
CPU的管理在操作系统中
是一大块功能
叫做进程管理或者处理机管理
内存也是冯诺依曼体系结构中
非常重要的硬件
刚才提到
有很多程序我都同时启动了
内存是一大块的存储空间
哪一段程序占据哪一段存储空间
存储空间不够了怎么办
内存的空间是有限的
存储空间不够了怎么办
这就是操作系统的存储管理功能
对于冯诺依曼体系结构中的其它硬件
包括输入输出设备
我们把它叫做设备管理
而操作系统
对所有软件资源的管理
都是以文件的形式来进行的
这就是文件管理功能
另外一个
这是操作系统的四大管理功能
管理计算机的软硬件资源
其中进程管理 存储管理 设备管理
是管理硬件资源
而文件管理
牵扯的更多的是计算机软件资源管理
这是操作系统的管理功能
操作系统的服务功能指的是
它为用户提供用户接口
对于windows而言就是每次开机
一起来看到的桌面
这就是windows提供给你的用户接口
去年超级计算500强中
就是世界上最快的500台计算机当中
计算能力最强的
500台计算机中使用的
操作系统的比例
我们来看
在这500台计算机中从这也可以
看到linux现在
受到广大用户的追捧
500台计算机中有427台
都使用了linux操作系统
这是去年的一个数据
使用windows操作系统的是5台
在超级计算和个人计算当中
对于个人电脑而言使用Linux的可能
并不占大多数更多的是使用
windows和苹果操作系统
但在超级计算500强中
可以说是绝大多数linux占据统治地位
unix系统有25台
还有四台机器采用的是混合操作系统
使用苹果操作系统的占两台
操作系统的功能越来越完善
人们使用操作系统也越来越方便
操作系统这样一个系统软件规模
也越来越庞大
这个图表中选取了特定时期的
特定的操作系统用代码量
来看下软件的规模
这些数字的计量单位都是
百万行代码
这里就是一千万行代码
两千万行代码
可以看一下现在的
wiondows xp系统代码量达到了四千万行
linux在2000年发布
小红帽6.2版本的时候
它的代码量不到两千万行
从代码量可以看到
系统软件的规模
可以看到操作系统
这种软件的规模
操作系统本身
这些代码不是由一个人来完成
是团队合作的结果
而且是大规模的团队合作
下列各项中哪项与众不同
上面所列的五项中ABCD都是
我们所介绍的某种操作系统
在操作系统这一节我们讨论过
一个应用程序要运行首先要进入内存
然后才能去抢占CPU
那么一旦这个运行开始进入了内存
应用程序就不再叫应用程序
我们把它称之为进程
事实上在操作系统进行
调度的一个最小的单位
并不是进程 而是线程
那么线程的英文单词是thread
我们在操作系统这一节讨论了进程
那么进程的英文单词是process
这两个概念是有区别的
那么这两个概念之间的区别
包括线程的概念
我们一会再进行讨论
线程是应用程序运行
和被调度的一个最小的单位
下面我们以SCRATCH为例
来讨论一下这种并发并行的程序
到底是如何运行的
这个线程到底是怎么回事
这种并发会带来怎样的问题
这个程序是我已经写好的
我们首先来读一下这段程序
读程序也是一门功夫
那么这个程序它有三段代码来组成
我们一段一段来看
可以就把它看做是三个模块
那么在这里出现了一个变量
这个变量的名字叫做threads
不知道大家是不是还记得怎么样定义变量啊
在变量这一类的指令当中
首先make a veriable
我先创建一个变量
这个变量给它取个名字就是threads
那么这里打上勾表示这个变量
显示在运行屏幕的左上方
我给这个变量设一个初值 把它设为0
然后剩下的动作很简单
剩下的动作就是一个永无休止的循环
除非你强行结束这个程序
否则它这个代码会一直执行
它一直执行的是一个怎么样的动作呢
不停的原地转 转15度
我在这里不停的原地转15度
我们可以来看一下这个模块的执行
不断的在这个原地转15度
我们来看它的第二段代码
第二段代码说的是对键盘的一个定义
当空格键被按下的时候
在这里出现了一个新的命令
这个新的编码命令叫做broadcast
这个表示广播
广播给谁呢 广播给
我们这个程序当中出现的所有thread
也包括这个thread本身
我们现在这个thread
这个小精灵叫做1号小精灵
那么当一摁空格键 它就广播一个消息
这个消息广播给谁 大家都能听得到
我自己也能听得到
那么下面这段代码
就是这里最关键的一个核心代码了
它说当小精灵
收到够这个消息之后
它开始了一些动作 第一个动作
把变量值增加1
change by 1是增加1
如果你要减少1的话
那就change by负1就可以了
我在这里是做了一个增加1的动作
那么下面这条指令launch是
SCRATCH支持并发控制的一个核心的指令
我们来看一下
这个指令出现在控制类的
编码指令当中
这里有launch
在launch这个位置点击鼠标右键
可以看到有帮助
我们来看看它对launch这条指令的解释
launch这条指令 指的是
独立的运行这段代码
这个独立指的是独立于线程1本身
我们这个文件名叫做1.ypr
我们就把它叫做线程1好了
它独立于线程1的运行
每次执行到这里的时候 你可以看到
它在这里用到了parallel这个词
所以很多时候可能并发并行的概念
并不是多严格的多科学的有区分
但是我们希望你对 不管是并发还是并行
那么在学术上的争论
我们现在先不去考虑它
先让你对并行计算本身 对同时执行
有一个最初的认识
那么我们现在就来解释一下它的
这个程序真正运行起来
它跟运行空间结合在一起
跟内存 跟CPU结合在一起
它该是如何来转的
我这个应用程序的名字叫做
1.ypr 我已经写了一些代码
那么我双击它 意味着它启动了
那么在内存当中
它就建立了某个线程
那个线程也有自己的ID号
我们就假设是线程1
这个线程1就包含了
我们这里原始的1.ypr所写的
这三段代码 我就用1 2 3来表示
1 2 3分别指代我们这三段代码
那么程序一旦运行起来之后
我们可以看得到
在CPU当中它就开始了
使用CPU它要完成这个动作
那么所有的这个执行动作都要CPU
由控制器和运算器一块
来控制着你这个程序的运行
所以对于小精灵 我们刚才看得到的是
它开始转圈了 意味着我的线程1
开始使用CPU了
那么一旦我这个空格键摁下
我们说系统广播了一消息
系统广播这个消息是广播给了所有的精灵
也包括我自己
那么意味着我也能够收到这个消息go
那么一旦我收到这个消息go
首先我修改了这个变量的值
重要的动作来了
这就是它用了launch这个指令
意味着我生成了一个另外一个独立的线程
这个线程它的代码是什么呢 就这两句话
forever
永远循环执行 执行谁啊
我用括弧来表示
不再写严格的 它的指令了
前进5步
launch本身是SCRATCH所提供的指令
那么这条指令最终的执行
要有SCRATCH的翻译器
和操作系统共同
来进行调度才能完成
最终这条指令的执行
那么现在首先看到launch做的
第一件事就是
我在内存当中创建一个新的线程
这个线程它的程序代码 程序指令
就是你在launch这里面所写的这段代码
那么现在你可以看到
关于这段程序在内存当中
它就有了两个线程
那么两个线程都是操作系统
去做进程调度运行的一个最基本的单位
线程1可以使用CPU完成计算
线程2也可以使用CPU完成计算
那么SCRATCH的翻译器跟操作系统
在完成这两个线程的调度
它们是有一些约定的
我们两个线程是平等的
公平对待
你用一会CPU 我用一会CPU
那么过一会你又来用一会CPU
我又来用一会CPU
我们两个平均分配
公平对待
那么下面我们再来考虑
体现在这个小精灵身上
会变成什么样的动作呢
第一个线程导致它不停的以15度
以15度为一个单元的动作
不停的在转15度
而第二个线程是
每次前进5步
这是我们非常熟悉的动作了
我们在前面设计正多边形的时候
我们在前面试图去画圆的时候
我们是用正多边形去逼近的
那么这里就是我一边转15度
一边前进5步
这是典型的 我们说
这是画正多边形的动作
那么对于这个程序当中
这个正多边形我们看它是多少边形的
转一圈360度 每次前进15度
那么这里算出来是24 那么意味着
我就一直在画正24边形
我们来看整个程序的运行
我摁下绿旗键
它现在这个时候
因为新的线程是不是还没有声明呢
我还没有摁下空格键 没有广播消息
所以它没有创建新的线程
我摁下空格键了
广播消息了 是不是就要创建新线程了
创建新线程就意味着
每次前进5步这个动作开始了
那么我们来看
我这个时候来摁下空格键
这就画出了一个正24边形
很逼近这个圆了
你可以看到它的棱棱角角
但是已经很像一个圆了
那么再来考虑 如果我再一次
摁下空格键会发生什么啊
我们先把它停止在这里 我们来考虑
如果这个时候我又摁下了一个空格键
那么这件事会变成怎样呢
那么这段程序所说的就是
每次摁下一个空格键
是不是都要修改所有变量的值
然后要生成一个新的线程
当我第二次摁下空格键的时候
SCRATCH变量的值发生了变化
又增加了1
而这个时候我们说
是不是又生成了一个线程3啊
线程3干什么呀
线程3的代码
跟线程2的代码是不是一样的呀
也是forever
什么动作永远执行呢
也是move 5步的这个动作
你可以看到 这个时候我们还是公平合理
你执行一步我执行一步
CPU咱们合伙使用 对吧
你用一会我用一会
那么这个时候我们来看
CPU的调度和运行是怎样的
这件事是由SCRATCH的解释器
跟操作系统共同协同来完成这件事的
就是我们公平合理平均分配
线程1你执行一步
线程2也来执行一步
因为新的线程生成了
意味着它也有权利去使用CPU了
SCRATCH的规定就是咱们平等
你走一步我走一步 一个一个来
3这个线程也走一步
3走完之后又该1了
1走完2走 2走完3走
那么现在我们再来分析
这个小人的动作是什么
我转15度 然后前进5步
前进5不还不够 因为线程3还要运行
又要前进5步
那么事实上 每转15度
我是不是前进了10步啊
所以这个时候你可以看
这个小精灵画的圈会不会越来越大啊
因为这次我每转15度 我前进10步
我们回过头来看它的运行
我们重新运行
那么这个时候是一个线程的情况是
每次前进5步所画出来的正24边形
那么重新运行好了
运行一开始 就是它一个原始的线程
摁一次空格
多了一个前进5步的线程
我再摁一次空格
又多了一个前进5步的线程
那么再摁一步 以此类推 每摁一次
是不是这个就是多一个前进5步的线程
它画的这个圈就会越来越大
我把它停止了
所以我希望大家通过这个程序体验的就是
多线的并发的程序会带来
系统的怎样的动作的变化
对于并发控制 SCRATCH的做法它是
我们平等对待 平均分配
你走一步我走一步
大伙轮流使用CPU
这是一种分时的思想
我们大家都在这一个舞台上
一个精灵来做动作
所以我们以SCRATCH的这种
类似于并发控制的一种模拟 我们可以看得到
我们把这种情况叫做并发
就是多个线程之间是有互相作用和交流的
那么这种交流在这里体现的这两种方式
我们也都看到了 一种是共享的内存
而在这里 在BYOB 在SCRATCH当中
体现的就是我们大家都在这个共同的舞台上
三个线程 刚才我们一共按了两个space键
按了两个空格键
生成了两个新的线程 一共三个线程
这三个线程都在同一块舞台上
发生动作 那么这块舞台
就类似于我们的共享内存
大家都对同一块区域进行操作
那么另外一种交流方式就是消息传递了
那么消息传递体现在这里
这里我们简单的用了一个广播
小精灵之间我们可以通过broadcast
或者send message 就是简单的
通过消息传递来进行交流和作用
这体现了一种相互作用和控制
我们来总结一下到底什么是并发
并发性是指在一个系统当中
拥有多个计算
这些计算有同时执行的特性
所以无论是并发还是并行
都有同时执行的特性
在前面我们都没有严格的去区分
这两个概念 因为本身
这在学术上就有着一些争论
这个并发性的概念取自于维基百科
那么这些计算有同时执行的特性
而且它们之间有着潜在的交互
因此系统可进行的运行路径
可能会有相当多个
而且结果可能具有不确定性
关于这件事我们到后面
还有一个具体的例子来体现
并发计算可能会在具备
多核心的同一个芯片当中来运行
那么以优先分时线程在同一个处理
通常性的话我们会
如果CPU是多核的话
那么一般来讲一个线程会在同一个
核当中来运行
也有可能是在不同的核当中运行
所以这句话说的就是并发计算
可能会在具备多核心的同一个芯片当中运行
以优先分时线程在同一个处理器当中运行
或在不同的处理器当中运行
我们下面来简单的讨论一下
这种并发 我追求并发控制同时运行
那么这种会给软件设计人员
会给软件设计人员和硬件设计人员
分别带来怎样的问题
就是它对计算系统的影响有多大
现在计算机 我们说体系结构都是冯诺依曼
所以我们通常会讲都是冯诺依曼计算机
现在计算机都具有同样的体系结构
那么对于现在
冯诺依曼计算机的体系结构而言
我们这样来画好了
CPU当中包含有运算器ALU
还包含有控制器 也就是CU
然后我们有memory
有memory 有内存
那么五大部件还包括输入设备和
输出设备
现在的新的问题就在于
CPU是哪一部分 CPU是
CPU是我们说的由控制器
和运算器所组成的单元
那么现在我们的CPU大多是多核的
多核的CPU
那我怎么样充分的利用这些多核
来更快的以并发或者以同时运行的方式
来完成我们所需要的计算过程
这给硬件软件设计人员都提出了新的挑战
我们来查看一下这台机器的CPU有几核呢
我们从任务管理器来看好了
在任务管理器当中
我们可以对比性能 从这你就可以看得到了
在CPU的使用记录当中 你可以看到有
四个正方形的框 而内存就是一大块
四个正方形的框 你可以看到
每个框框出来的使用频率
运行频率是不太一样的
这都适时的显示它现在的运行
从这里就可以看出来 我这里有
我这核心是四个
我这个CPU有四核
那么更具体的我们还可以从资源监视器来看
从资源监视器你看 从右边
这一列上你就可以看到 第一项是总计
那么剩下的每一项分别为
CPU0 CPU1 CPU2 CPU3
这是一个四核的CPU
我们来看一看程序的运行对CPU的影响
我们看一下 在我这个程序没运行的时候
你可以看到这个
CPU的一些状况
我们先不看总计
就看这四个独立的CPU
那我们把它运行起来
你可以看到CPU的使用上的一些变化
我们再来看 我们摁下空格键
回过头再来看资源上的变化 看有没有
你可以看到我们这个程序
因为它是一个死循环
所以它需要CPU的运行
需要占用CPU的一个运行的时间
这是怎么样用你的任务管理器
当中的任务监视器
可以看到CPU四核运行的一些具体的情况
我们刚才回顾了冯诺依曼体系结构
也看到了我们刚才所用的这台机器
通过任务管理器 资源监视器
可以看到它是一个四核的CPU
那么下面我们来思考这样一个问题
考虑现在的计算
事实上都是多核的计算
因为即使是个人电脑上面
CPU也是多核的了
正是因为现在都是多核的计算
而我们计算机的体系结构并没有发生变化
还是冯诺依曼体系结构
现在的计算机工作
不管是软件设计人员还是硬件设计人员
所要面对的这些工作当中
在冯诺依曼体系结构当中 哪个部分
最让软件和硬件设计人员最伤脑筋
或者说现在我们又强调并发并行
哪部分内容 哪些内容
让软件和设计人员需要花费
更多的时间去思考 或者说以前
没有考虑过 以前不是多核
不考虑并发的时候 很少去思考这类问题
那么现在而言
哪个部分是你需要考虑最多的
那么这里给出了
冯诺依曼体系结构当中的五大部件
我们希望你从两个角度去考虑
就是计算机的工作主要是要靠
软件和硬件协同来完成
你要考虑的是对于硬件设计人员来说
硬件设计上他要花很多时间吗
会非常头疼吗
当然硬件上多核的
会带来一些设计上的变化
但真正要实现并行计算
硬件上设计会很伤脑筋吗
硬件我们说这里包括了这五大部件
还有一个角度要考虑的就是软件要编程
那我怎么样能够用好多核
软件结构又会发生怎样的变化
所以你从硬件和软件两个角度去考虑
哪一部分是最伤脑筋的
所以我们再来看一下这个线程
线程是操作系统进行运算调度的最小单位
它被包含在进程当中
我们在这里并没有讨论线程跟进程的关系
所以对于这些内容你还有疑惑或者感兴趣
可以去看操作系统的书籍
或者学习并行计算的内容
线程是进程当中的实际运作单位
所以我们说操作系统进行调动
它的最小单位是线程
那么一条线程指的是
进程当中一个单一顺序的控制流
一个进程当中可以并发多个线程
每条线程并行执行不同的任务
即使你是单核的CPU
我依然可以用某种方式 利用分时
我们平均分配时间 利用CPU的高速
来在一定程度上实现并发和运行
那么下面这两张图都截自维基百科
在操作系统当中
我们讨论存储管理
这个时候我们提到的存储
指的是计算机系统的内存
有时候也把它叫做主存
我们一直都在强调的是
现代的操作系统
大多是多用户多任务的操作系统
多任务的含义就是
在系统的
某一个运行时刻
在系统的运行
在你的计算机系统的
运行空间当中
有多个任务同时在运行
我可能打开了浏览器
去浏览网页
一边我又听着音乐
同时我手上还
可能还在操作着某种文档
意味着在计算机系统的
这样一段时间里
我们同时有多个任务在
一起执行
在讨论操作系统的
进程管理的时候
每一个应用程序
运行之后的实体
我们把它叫做进程
每个进程
不管你是QQ的运行
还是文档的处理
还是音乐播放软件
它们一旦启动之后
进入内存
有资格去抢占cpu
这时候我们都把它叫做进程
在系统运行当中的某一时刻
在内存当中有多个进程
每个进程都必须要有
足够的内存空间
共起来运行
每个进程在运行的时候
也不能闯入
其它进程
或者是操作系统进程的
内存空间
这就牵扯到了
计算机系统的
内存管理
每一个应用程序要运行都
需要从硬盘
或者是从其它的外村
装载到内存或者是
主存当中
我同时有多个
程序要装入主存
我们放到主存的什么位置合适
就是主存
不管你是2G的内存
4G的内存
空间是比较大的
你放到
每一个应用要多个程序要运行
要装入到内存当中
它应该放在
内存的哪一个位置
程序装入到内存之后
我们说这个时候它就
成为了一个进程
cpu调度
如何去寻找这些进程
有没有可能找错
如果你的应用程序
要求的内存空间比较大
而现在的内存所剩不多
内存你可能放不下了
这个时候操作系统
有没有一些技术支持
来帮助这样一些
应用程序完成运行
这些都是操作系统的
内存管理
所需要讨论的内容
虽然内存它是硬件一块芯片
而芯片 硬件的发展
我们说我们有摩尔定律
每隔十八个月
我们这个存储能力翻一番
但是软件功能也是越来越强大的
它对内存的容量需求
也在不断的增长
所以带来的问题就是
你的内存似乎是永远不够用的
而我们平常在
程序运行的时候
不断的启应用程序
我启动了我的QQ
打开了我的邮件管理
上网去浏览信息
同时还播放着音乐
似乎
我的内存是用之不尽的
这中间重要的支持技术
就是实现了
存储扩充的
虚拟存储技术
也就是我们通常所说的虚存
我们通过三国志的游戏软件
你可以看到
虽然你的芯片发展
你的存储越来越强
内存变得越来越大
但是软件
对内存的需求也越来越多
三国志的游戏
从第一代现在已经
发展到了第十二代
你可以看得到
在你安装这个游戏
在启动这个游戏的时候
对内存的需求的增长
之所以能够实现虚存
是由于程序的运行
存在着局部性的原理
这种存储管理方式的
优点在于
它减少了程序运行对内存的需求
增加了并行进程的数量
很多进程可以同时
存在于内存当中
内存似乎看起来是应该
放不下这么多进程的
原因在于
有一些不太活跃的进程
我把它放到
外存上去
放到外存我们
刚才划分的那一块
虚存里面去了
之所以能够这样做
是因为程序的运行
存在着局部性原理
程序在运行的时候
并不是所有的指令
都要在同时来执行
在一段时间之内
程序执行
只是访问部分的指令
所以你同一时间
在一段时间之内
活跃着的指令
可能只有那么一部分
程序在一次运行当中
可能只局限于部分的指令
所以程序在执行前
没有必要全部装入内存
只要保证访问到的部分
在内存就可以了
而随着程序的执行
将暂时不需要的内容
调出内存
存储在外存上
腾出空间
调入需要执行的部分
在操作系统的内存管理当中
一些存储单元
被使用之后
它相邻的存储单元
也可能很快就被使用
最近访问过的程序代码和数据
可能很快又会被访问
这就是我们强调的
程序的局部性原理
所以结论
就是我们在程序
运行的时候没有必要全部
一次性的装入内存
我可以只先装入一部分
只把一部分指令
先装入到内存
而相比内存而言
外存的访存速度
要慢至少一个数量级
要慢很多
所以主存容量越大
cpu的执行速度
也就越块
而你要访问的
那段指令如果刚好已经
刚好被放到虚存里了
意味着虚存里的这些指令
最终要能够被cpu执行
还要重新
回到内存
所以这个时候你会感觉的到
它的执行速度有一些延迟
有一些慢
下面我们看看windows
操作系统当中
对虚存管理的一些支持
在windows操作系统的
控制面板当中
有系统选项选择系统
选择系统可以看到有更改设置
我们来看一下
在高级当中
有设置你可以看到
这一项可以
是对性能的一些设置
包括视觉效果
处理器计划内存使用
以及虚拟内存
这里虽然
把它叫做虚拟内存
但事实上它是外存
我们不看视觉效果看高级
高级当中你可以看到这里有
虚拟内存
虚拟内存指的是硬盘上的一块区域
windows把它和
RAM也就是我们常讲的
随机访问内存一块使用
在这里我可以
改变一些虚存的
设置
你可以看到我的虚存
指的是我从
硬盘上找一块
外存空间把它化成虚拟存储空间
实际上它是
硬盘上的空间我的
虚存设在了
C盘这个驱动器当中
初始大小为2049
这个单位是MB
最大的这个大小把它
设成了10240MB
从这我们也可以看到
所有驱动器分页文件大小的总数
在这里你可以更改也
可以把你的虚存划在D盘上
或者是其它的
一些空间上
这就是我们讲的虚拟存储的概念
我们先看抽象与模型
数学所关注的是现实问题的
一些抽象概念和逻辑推理
计算机科学最本质的内容
是抽象与自动化
通常把它叫做计算机科学
当中的两个a
一个a指的是抽象abstraction
一个a指的是自动化automation
前面讨论过抽象
抽象指的是
摒弃细节去抓主要矛盾
抽象还指从具体对象和性质中
提炼出一般性使具体问题一般化
而我们做这些事情的目的
归根到底是为了给问题建立
一个合适的模型
在这里讲的合适是希望模型
适于计算机进行问题求解
有了模型之后
下面要做的就是使用这个模型
在计算机上自动求解问题
找到一种方法
计算机最终如何求解问题
首先要弄清计算机能干什么
计算机包括了什么
计算机系统包含有软件硬件
软件指程序加文档
机器上装有各种各样软件
有的是买来的别人写好的
有的是自己写的
用于解决自己需要解决的问题
硬件指电子机械装置的总称
计算机最终是完整的系统
有软件硬件有机整合在一起
来进行问题求解为人类工作
先看一个例子题目是让计算机
在屏幕上写hello
能否指令为你写一个hello
这样计算机是读不懂的
再看这样一种指令希望最终
在屏幕上打印出hello这个词
可能写出这样一条指令
print
对于这条指令仍读不懂
但是这条语句
是一条c语言的语句
对于计算机程序设计语言C
它能读懂
再来看这里变成一组指令
这样一组指令对于计算机的
硬件而言依然看不懂
这是一种汇编语言能懂
某一种汇编语言
可以看得懂这些指令
大多数人看不懂
现在给出的指令都是01的组合
这个时候计算机硬件能看懂
因为归根到底它是一些开关电路
是0和1的编码形式
计算机能够懂得01表示
这是它的母语
这是指对于计算机有某种机器
语言可以读懂
这些指令序列可能可以
完成这个指令需要完成的操作
这些指令摆在这里对于人而言
可能就看不懂
计算机当中都是01内存中
cpu中寄存器中寄存的都是01
这些0和1最终意味着
就是模型的表示
可以代表很多的信息
0和1有可能是一幅图片
通过把图片按行按列划分成
像素点对每一个像素点存放
颜色信息这些信息都由01表示
这样可以通过一些解读
可以解读成一幅图片
我的图片同样可以用01表示
这些0101也可能是一些歌曲
对于音频我们也可以对它进行
编码把它用01表示出来
平常用播放软件
用mp3播放的歌曲最终
存放在你的计算机中也是01形式
你所制作的文档
包括文本信息汉字或其他语种
最终
它们存放在计算机中
也是01串所以01串也可能是
一些文档
写的word文档ppt文档
用百度地图搜索起点终点
去寻找路径最终地图
它的存放也是01的形式
建立在01表示的基础上
可以使用用01表示的地图信息
如果你希望使用地图查找目的地
或者路径
最终地图信息存放在计算机
内部也是01的表示
从起点到终点找到路径
这里需要一系列的操作
这组01串出了表示各样的信息
还有很重要的形式就是它
可以是程序可以是指令的集合
建立在刚才讲的数据上的操作
事实上都是01的指令这些指令
同样是以01的形式存放在计算机
中所以对于在计算机存储器中
在计算机存储的0101
有各种各样的解释方式
对于计算机而言看到的都是
对它而言
都是0101
这些01代表着什么样的含义
该对它如何进行操作这是模型
要做的工作
我们平常的工作是跟模型打交道
不是跟01串打交道
抽象的目的最终
建立模型这是用计算机进行
问题求解的重要步骤
下面看自动化与算法
我们的目的是自动计算
希望计算机自动进行问题求解
希望它替代我们进行脑力劳动
在这中间我们需要计算过程
计算步骤
一个计算步骤实际上是
一组
动作的序列
这组动作序列告诉你
该如何去做一件事
我们通过如何泡茶体会一下
我想泡茶
动作序列是第一步先
烧一壶开水
第二步把茶叶放入茶杯
第三步把开水
倒入茶杯
第四步等待十分钟
这个时候十分钟之后茶泡好了
这样一组动作就完成了泡茶
对于烧开水还可以细化
怎样烧一壶开水
先接水用电如何烧用煤气
如何烧 这些动作
如果要用计算机实现需要非常
确定的计算机能执行的动作序列
再来看另一个泡茶的计算过程
第一步烧一壶开水
接着把茶叶放入茶壶
第三把茶水倒入茶壶中
第四等待两分钟
第五把茶壶中的水倒掉
第六再向茶壶倒水倒满
第七等待十分钟
十分钟之后茶泡好
可以看得出来
同样的完成泡茶任务给出了
两种计算步骤
这两种计算步骤都可以使我
达到目的
都可以使我完成任务
这就是后面要讨论的完成
对于现实世界的问题解决问题
可能有多种途径
这多种途径中该如何去评价
该怎样选择比较好的方法
这是讲的对
计算过程进行评价的思路
计算机科学是两个a一个是
抽象一个是自动化
自动化指的是设计出计算过程
能够让机器自动的执行
而计算机是一种通用的机器
只要给出好的抽象和自动化的
计算过程
就可以自动完成很多事
在计算机上要完成这些任务
是以程序设计的形式来进行
程序设计就是设计计算机
可以理解的模型和求解过程
程序设计本身是一种创造性的
劳动我们强调了计算机的基本
原理是存储程序工作原理
存储程序工作原理的计算机决定
它的使用方式是编写和运行程序
现实世界中
各种各样的问题
最终要能在计算机上进行求解
首先要通过人的脑力劳动
人要具备某种计算思维
一方面清楚的描述出人进行
问题求解的过程
另一方面要了解计算机的能力
要了解计算机是如何进行问题
求解的所以面临是第一件事情
是为现实世界中的问题
建模就是今天强调的
要抽象出模型的概念
抽象出来的模型面对的
是信息世界
我们在信息世界中
为这样问题建好模之后
下面要做的
计算步骤以编程方式告诉计算机
计算机才有可能
把程序存储起来在程序控制下
完成整个求解的过程
下面我们用scratch来编写一个
寻宝挖金子的游戏
这个简单游戏讲的是一条鱼
在大海当中不断的寻宝
它对它寻到的宝物
都还做了计算它记数
我一共找到了多少宝物
我们就把BYOB这个版本的
这个白色的舞台比作大海
这条鱼就是
这个舞台上的一个精灵
这个宝物我们也用
BYOB当作的一个小精灵来了表示
只是这时候这个精灵
它没有生命
它只是呆在这里不动
等待着这条鱼找到或没找到它
这条鱼的运动
是通过键盘控制来进行的
我通过键盘上的上下左右键
来控制来找到这个宝物
一旦这个舞台上
出现了一个新的宝物
看到它在哪个位置之后
我通过控制上下左右键
我就可以找到这个宝物
而我一旦找到这个宝物
我的计数器就发生了变化
计数器原来是0
现在则变成了1
意味着找到了一个宝物
被找到之后又会
出现一个新的宝物在这个舞台上
我继续寻找新的宝物
同样这个寻找的过程
通过用户按上下左右键来进行控制
这样又出现了宝物
我又来找找到之后你可以看到
我找到了宝物不断的在增加
这就是这个
简单游戏的一个运行的过程
下面我们试图对它进行编程
来实现这个简单的游戏
在这个简单游戏当中
包含了很多程序设计
当中一些重要的概念
用来计算这条鱼
一共找到了多少宝物的
这个计数器
这是程序设计当中
非常重要的概念叫做变量
这个变量起到的就是记数的作用
它的最初的值为0
一开始我一个都没有找到
我的初值为0
之后我每找到一个
我每找到一个宝物
这个计数器就增加1
我们来看如何编写
这样的简单游戏
我们先看变量是如何实现的
在BYOB当中有八大类程序指令
这是我们编程的基础
其中一类就叫做变量
变量当中的第一块积木
就是创建一个新的变量
我们在这里创建一个新的变量
这个变量是s
你创建变量的含义
就是每当这个程序运行的时候
在内存空间都会为s分配一个存储单元
这个单元当中记录的
就是它找到的这些宝物的数值
实际上就是一个自然数
我们给这个变量
这个存储单元起个名字叫做s
你可以看到舞台上的变化
舞台的左上角就出现了s这个变量
在这个游戏当中
还出现了两个对象
一个对象是宝物
在大海当中刚才我们
看到的实线中
就是用这个黄色的小精灵
来代表这个宝物
只是这个精灵太大了
我们把它缩小一点
这是改变精灵的
外观选择这个精灵之后
在外表的这一类程序指令当中
有改变大小
我们把它拖到编程区
我们希望把它的大小
改成原来的百分之二十
双击这条指令
也就是双击这块积木意味着
这条指令的执行
你可以看到宝物缩小了
在这个舞台上
另外一个重要的角色
就是这条鱼
对于这条鱼你可以重新创建一个精灵
你可以按自己的方式去画一条鱼
当然我画的不好
也就不用我画的
我们直接在
它的库当中选择一条类似的鱼
这个就是我们
刚才看到的这条鱼
我们选择这条鱼
这条鱼也太大个了
我们也把它的外观缩小一下
缩小为原来的百分之三十
而这条鱼所做的动作
其实很简单它就是通过键盘的
上下左右键要控制
它上下左右的移动
意味着它要能够感知
外部的环境
它要能够感知到键盘的变化
这就要用到感知
这一类指令当中的
这就要用到感知这一类指令
在感知这一类指令当中你
可以看得到可以感觉的到
一些键被拍下了
这里我们所要表达的
不过是当上键
如果我在键盘上
按了上键
我希望它往上走
我要按了右键我希望它往右走
这是一个判断
如果我在键盘上按了向上走的键
我希望你往上走这句话
我们该怎么讲呢
我们在这里有if语句
我们希望判断
怎么看的怎么表达
这个向上的键被按下了呢
我们把这里做一个修改
你可以看到
把这个space这是表示
是不是空格键被按下了
我们现在要考察的是
向上走的键是不是被按下了
选择的是up arow这表示向上的键
这是一个判断条件
我现在判断这句话很清楚了
如果向上的键被按下了
我要做的动作是
我要往上走
现在是精灵的运动
所以我们找的精灵运动的指令
那我们首先要找方向
那么这个方向我们可以通过转90度
但是这里有直接的
改变方向的指令叫做point in
我们在这里先改变它的方向
这个时的方向你可以看到
它标明了0是表示向上
180是表示向下
90表示向右
负90的向左
我们现在是向上
方向改变之后
我已经转对了正确的方向之后
我们前进十步
这是向上走的判断
同样的我们可以完成
向左向右向下走这个
程序指令的编写
我们这里重复这一串指令
如果是向下的话
我的方向也要变成向下
向下走十步
如果我是向右
如果我按下了向右走的键
那么这个方向要变成
向右走走十步
每按一下表示我走十个坐标
前面我们讲了这个坐标系的概念
最后一个是
向左的键按下我要向左走走十步
这是这条鱼
它这些动作实际上
它是始终跟着你的键盘在做的
一旦我按下了
你就要一直走一直走
所以这是一个
这是一个无休止的循环
你就要一直听从我的指令
我们先来看一下
这条鱼是不是这样跟从走的
双击这段
双击这个程序块
表示这个程序块执行
你可以看到现在可以来看
我向右走
每按一下它走十步
向左走每按一下走十步
每按一下走十步
向下也是每按一下走十步
这个时候你可以看到路过
这个宝物的时候它根本没反应
因为你程序里面没有写
程序里没有写你只规定了
我按照键盘的上下左右的
这个移动的过程
你没有讲如何去跟这个宝物打交道
下面我们要考虑跟宝物的
这个程序怎么写
我们回到这个小的精灵
它的动作有两类
一个是它一旦碰到这个大鱼
它就被大鱼找到了
被大鱼找到了意味
这个大鱼就会把
它收入囊中了计数器增加1
首先它要能够判断
我是不是被大鱼找到了
那么这又是一个感知
这里看到
我是不是碰到了这是touching
这是我的第二个精灵
我这两个精灵都有名字的
这个宝贝黄色宝贝
黄色的宝物叫做精灵1
这条鱼叫做精灵2
你可以看到
我可以完成一个if判断
这时候要看if判断
我有没有被这条鱼
这个判断条件就是
我跟精灵2有没有接触
一旦我们俩有了接触
那么我要做一些动作
第一个动作就是
变量的值要发生变化
变量的值发生变化在
变量的这类程序代码当中
这里有change
你可以看到我一旦被鱼找到意味着
它要找到的宝物就增加1了
我们可以看这个指令对s的影响
你可以看到我们每次用1来改变它
实际上是每次都对它增加了一个1
我们再把这个指令
从这里删掉
计数器加1
这是它的第一个动作
第二个动作就是
我这个宝物要消失了
这是外观上的变化在这里
这个时候我们让宝物消失
我把它藏起来
hide起来了
下面的动作就是
我要找到一个新的位置
我要随机的出现在这个舞台上的
另外一个位置
我要去到一个新的位置
我们用go to
到某一个坐标这条指令
我go to到哪里呢
并不是说我
一直都在原点或者某一个位置上出现
而是我要出现在
一个随机的位置
在scratch当中
提供了随机的概念
就是这个函数pick randorm
这个函数放在这里的含义就是
在1和10之间产生一个随机数
它不一定是1或者10 或者4 或是5
随机产生的
可能是1到10之间的任何一个数
而我们这个舞台我们说了
横坐标是负的240到正的240
纵坐标是负的200到正的200
所以我们对于横坐标而言
这个随机数的产生就是
负的240到正的240之间
这就表示我在
负240到正240之间
产生一个随机数
来作为它的横坐标
纵坐标也是同样的概念
也用随机数
只不过这时的范围发生了变化
走到新的位置之后我们希望
我们刚才把这个精灵隐藏了
走到这里你走到新的位置
还是看不见
所以这个时候我们要让
走到了新的位置之后
我们需要它出现
需要它出现
同样的
这个精灵这些动作
实际上它一直都在这做着
什么时候能够
触发我执行这段指令呢
就是这个if
语句的条件被激活
也就是它碰到了这条鱼
它被这条鱼找到了
我这个循环也是一直存在的
我一直在执行
如果你没有碰到
我在来下一次循环
继续看你是不是
有可能碰到我
同样我们说对于小精灵的激活
我们也用这个小绿旗
被点击的时候大精灵
我们看做了这件事没
大精灵也把这段代码写进来
现在我们来看
运行的过程是不是对的
点击小绿旗意味着两个精灵都被
都被开始执行了
一开始执行
相信大家就已经看到了问题所在了
问题在哪里
s的值是9还没开始
怎么就变成9了呢
原因就在于我们刚才在
过程当中做了一些实验
使得这个内存单元
最后的时候它的值是9
那么这个时候程序你要做一个
初始化的动作
我们要给s一个初值
这个值不能是9
所以我们先把程序的执行终止
给试图在执行的一开始
给它一个初值
我们来看一下
在变量当中可看到
第一项有set x to 0
这就是表示
首先给它一个初值
重新完成运行
那么这个时候你可以看
上下左右键
我的小鱼在海里
不断的游曵
我看到这条鱼了
现在要来吃掉这条鱼
可以看到s的计数器发生了变化
同样它又出现在了下方
我们吃掉这个鱼
马上s又会出现在另外一个位置
出现的有点太快了
我们再去修改一下程序
修改一下小精灵的程序
让它不要那么快就出现
让它等待一段时间
在控制当中
有一条等待的指令
这个等待我们说
等待两秒钟你再出现
你不要出现那么快我
这条鱼太辛苦了
我们再来看程序的变化
重新开始运行
你看精灵挡在计数器的后边了
我们吃掉了这个精灵
精灵怎么还不出现两秒钟很长
精灵出现在这里
我们吃掉精灵计数器增加1
这就是我们对这个
简单游戏程序的一个实现
我们刚才编写了一个
非常简单的游戏程序
通过这个游戏程序
希望你能理解进而能够掌握编程当中
最重要的一些基本概念和基本结构
这里面牵涉到了变量的概念
还牵涉到了循环 分支 顺序
这三种程序设计基本结构
大家实际上已经体会的到
用scratch 用BYOB完成程序设计
编程的这个过程
有点自底向上
就是我有一个一个基本的积木块
这些积木块是什么
那几类程序指令当中的
每一条具体的指令
而通过这些指令的组合搭建
最终我可以完成一些程序
这实际上是一种自底向上的方法
我们现在考虑车辆驾驶问题
从你的角度而言
你知道汽车是怎么工作的吗
知道汽车是如何工作的
发动机是如何发动 带动离合器
使得汽车前进
它的工作过程可能知道的人并不多
但是会开车的人却很多
如论你的车是怎样具体的一个个体
但是操作车的过程
我是可以抽象出来的
无论你
驾驶的是什么样的车
开车的过程你要关注的可能是
你的刹车 你的加油
你的油门在哪里 你如何刹车
如何踩油门
这个过程是可以抽象出来的
所有有时候会讲
你可能是1920年就学会了开车
如果现在你还健在
我再给你辆车你依然会开
原因就在于我知道抽象过程
这就是我把开车的过程
建立一个一般化的
抽象过程
无论你驾驶的是什么样的具体的汽车
像开车的过程 我是可以抽象出来的
我们再来看一个例子
这是摩天轮
摩天轮在一定的时间内会
完成一个圆周的运动
我希望你
来计算在这个摩天轮上
高度随时间是怎么变化的
假设摩天轮是6分钟转一圈
6分钟刚好是
刚好360秒转过了360度
假设摩天轮的半径是10米
起点在A处
我们来计算30秒后我所在的位置
跟起点之间的高度差
高度差就应该是这段高度H
因为它360秒转过了360度
所以30秒就应该转过了30度
我们把这个问题扩展开来
假设考虑在任意时刻
在这6分钟之内
我都期望知道
我跟A点之间的高度差是多少
往下写 假设在t时刻
我想知道高度差
计算t依然是
以秒为单位来计算
这样我就可以求出任意时刻
在t时刻 我和起点A之间的高度差
从这里可以看出
30秒的时候我的位置所在地
t取30秒的时候我的高度
跟A之间的差距
60秒 也可能是67秒
或者是90秒 我和A之间的
高度差
这里可以看到
这就定义了一个函数
这个函数描述了我们所称的自变量
和最终它的取值 计算出的值
之间的一种对应关系
我们再看一个例子
假设我这有一组数
1 2 3 4 5等等
下一组数我是这样的
你可能很快的就看出
这两组数值之间有一定的联系
如果我们把上面一排自然数叫x
很明显下一排的数值就是x的平方
也描述了一个函数 这个函数就是
f(x)等于x平方
实际上x的平方
我所定义的f(x)这个函数
描述了这样两组数据
描述了自变量跟值之间的一种抽象关系
函数是一个非常伟大的概念
他描述了自变量
和值之间的的一种抽象关系
而这种抽象
对于我们解决现实生活当中很多应用问题
是非常有用的
在数学当中 函数的定义
就是描述了每个输入值
对应唯一输出值的这种对应关系
同样这种描述也适用计算机科学
我们站在计算机的角度来考虑
就是我对于每个自变量
通过一定的函数计算之后
都可以输出一个值
函数就非常好的描述了输入
与输出之间的关系
这就是对于输入 输出之间
有关联的关系之间的一种抽象
这种抽象实际上提取了
这种关系当中的共性
再回过头来
我们来看抽象
刚才我们提到第一点 抽象是要
移除一些细节来看主干
第二点
就是我们前面所讨论的两个例子
抽象是从众多的事物当中
抽取出共同的
本质性的特征 而把它一些
非本质的特征扔掉
这样可以得到一个抽象的过程
抽象本身也是一种从个体
去把握一般
从现象去把握本质的
一个认知过程和思维方法
抽象是计算与计算思维的重要思想
我们前面所讨论的图灵机
是对自动计算
对计算过程的一种抽象
我们在前面讲了一些历史
我们曾经提到过
计算机能够准确高效的
完成很多工作
背后有着强大的理论基础
这个理论基础的
构成当中
图灵机是最重要的一部分
图灵机就可以看做是
计算的抽象
而我们前面所讲的
冯诺依曼体系结构
则可以看成是计算机系统
在硬件层次上的抽象
无论你是在哪个层次上来考虑抽象问题
都意味着
这些抽象的系统
抽象的理论 抽象的概念
首先要在设计者的头脑当中转起来
前面我们讲过
图灵机
是对计算的抽象
今天我们讨论
什么是抽象 为什么抽象是重要的
我们的现实世界有着各种各样的问题
而求解这些问题都有着一定的难度
在求解问题的过程当中
如何去清晰的描述问题
如何去找到问题的解
在这样一个过程当中
抽象就变得非常重要
考虑到最终我们这些问题
不仅仅是你求解完了就结束了
还有站在计算机的角度来考虑
如何让计算机能够帮助我们
或者直接代替人类
去求解这样的问题
抽象在计算机科学当中
是非常重要的概念
我们先来看艺术当中的抽象
毕加索是二十世纪的艺术大师
有一次他要画一头牛
他画出的第一头牛十分写实
结构也很严谨 很逼真
但是他并没有满足于这幅图
他陆续的又画了后续的十幅图
所以最终关于牛
他画了十一副画
从这里可以看的出
这十一副画当中牛的演化过程
这些画从写实开始
然后一幅一幅的可以看出对牛的
图像的一个抽象的过程
线条变得越来越简洁
到最后一幅画的时候
寥寥数笔
就已经勾勒出了一个牛的形与神
当我们看到牛的最后一稿的时候
其实很难想象的出
毕加索在这幅画成图的当中
花费了多少心血
这些看上去非常简单的线条当中
非常形象的 精炼的
勾勒出了
牛的形与神
西班牙诗人拉斐尔曾经说过
毕加索是用另外一只眼睛观察事物
他使世界大吃一惊
把世界翻了个身
并赋予了它新的眼睛
毕加索的作品 《牛》
是在1945年完成的第一稿
到1946年1月17日完成了第十一稿
从第一稿到第十一稿一共花费了45天
从毕加索创造《牛》 这幅抽象画
我们可以看出抽象的表现形式
是非常简单 省力的
抽象的表象形式是非常简洁的
但是完成抽象的过程
却是最复杂 最费力的
同时我们也看到了创造
抽象艺术品的简单法则就是做减法
最终毕加索创造出的《牛》
这幅抽象画
保留下来的线条当中
包含了我们在讲到牛时
所能想到的一切
毕加索认为
画家的职责
不仅仅是要借助具体形象去反映现实
而是要以抽象的形象
来表达科学的真实
从毕加索创作《牛》的过程
我们可以清晰的了解到抽象的过程
实际上就是抛弃一些细节
抓住问题的本质
也就是抓住主干的过程
我们再来看另外一些例子
生活当中也存在很多抽象
比方说我们的地铁地图
我们以伦敦地铁为例来看
1928年的伦敦地铁图
是在真实的地图的基础上
勾勒出了地铁的线路
亨利贝克是伦敦地铁的绘图员
1933年 亨利贝克
对伦敦的地铁图做了一个改造
这是他改造后的结果
我们可以把这个地图
看做是1928年那个版本地图的
一种抽象
他没有在追求在地图中
描绘出真实的道路的走向
你可以看到
在这幅地图当中他去掉了一些曲线
站点之间的到达全是是以直线的方式
他用颜色区分了
各个地铁线路
这种
描述地铁地图的方式
也流传至今
我们用这个例子
是希望大家理解抽象的目的是什么
在这个例子当中
抽象的目的是为了
帮助人们
更好的利用好地铁这个交通工具
亨利贝克在绘制地铁图的时候分析发现
人们使用地铁图
更多关注的是
线路之间的交叉互通关系
站点之间的先后关系
以及换乘的关系
他并不关注线路是否是曲直的
地铁前进路线是怎样的
是否穿过了
水流和桥梁
站点之间的实际距离
这些都不是
使用地铁图的用户所关注的
所以我们强调抽象
强调抽象过程
它有个准心
就是你的问题本身是什么 目标是什么
我们说抽象就是忽略一个主题当中
与当前目标 当前问题
无关的那些方面 那些细节
以便能够更充分的
注意到与当前目标
当前问题有关的那些方面
这是伦敦地铁地图的一个演变的过程
从这个演变的过程当中
我们可以看到
他丢弃了一些关于地图本身
道路本身的一些细节
而集中体现了
我们使用地铁地图的
目的所在
这是我们在艺术和生活当中的两个例子
由此我们可以总结出抽象的一个重要方面
抽象就是忽略一个主题当中与当前问题
或者是当前目标无关的那些方面
包括那些细节
以便能够更充分的注意到
与当前问题或目标
相关的那些方面
一句话来讲
抽象的一个重要的方面是
移除细节看主干
在抽象过程当中
移除细节是一个很重要的方面
那么前面我们讲了抽象与模型
讲了自动化与算法
那么下面我们通过一个例子
来把这条线
来把这个计算机问题求解的过程
来把它串一下
这个例子讲的是在罗马尼亚旅游的问题
我现在在罗马尼亚的这个城市
这个城市的名字叫做Arad
这是我的起点
那我过两天我要从这个Bucharest离开
我要从这离开坐飞机回北京 回中国
现在要解决的问题就是
我怎么样从Arad出发能够抵达Bucharest呢
你可以走不同的路
可以采用各种各样的交通工具 你可以飞
你可以驾车 你还可以租车
甚至你可以步行 只要你时间赶得及
当然解决这个问题
你选择怎么样的路径怎么样的方法
这取决于你的目标是什么
同时你还要考虑你当前的约束条件
你是希望赶时间 还是希望看风景
所以这取决于你的目标和你的约束
这最终将决定你的行为
那么这里我们首先看到的问题是
我出去旅游 我在罗马尼亚旅游
我一定有它一个地图
这是一个基本的常识 我需要有地图
那我现在的问题是这样
我已经决定了我准备开车去
我要找到一条路
我不飞我也不步行
我准备开车去
那么这样我就希望来找出一条路
使得我能够开车从Arad
到达这个Bucharest
而罗马尼亚的公共交通可能是非常发达
它有很多条路 那我怎么选择我的路径呢
我是往哪边走呢
这么多条路我选择哪条路去走呢
那么首先我们说
面对这个问题我要考虑的
就是对这个交通图 对我手上的这个地图
我该如何进行抽象
关于这些所有的地图信息
我该怎么样建立一个模型
而这个模型在计算机科学当中
很常见的就是我们使用图
那么图论也是计算机科学
一个非常重要的内容
我们用图来表示罗马尼亚问题
每一个城市 以及城市之间的这个道路
只要有道路连通
我们可以用一条线来表示
表示这中间有公路可以直通
而这些城市
都把它抽象成了
图中的一个节点
而把道路抽象成了两个节点之间的一条线
那么这就是我为罗马尼亚问题
所建立的一个模型 这就是一种抽象
而用图 用图论
在计算机当中来求解问题
这是非常常见的
我已经把它抽象成了一个模型
有了这样一个模型之后
我怎么样在这个模型之上进行问题求解呢
那么你从Arad出发
首先就面对着我有三条路可以走
我到底往哪条路走呢
你要明确的告诉计算机
一个选择的标准
就是计算机它的每一步动作都要确定
你要告诉它
或者说你按照东南西北四个方向
你按照一个怎样的顺序去尝试你的道路
或者说你可以采用一些很明确的算法
三个城市之间我该选择哪条路
哪个目标去前进呢
这就是我们讲的自动化与算法的问题
而这个算法的选择
我们说你有很多种方法
也可以选择其他的一些算法
你比方我们经常提到的
在后面我们还要进行深入讨论的
这个贪心算法
那么贪心算法的思路就在于
我在选择的时候
我选择离目标最近的那个城市
而从Arad出发
我们说这里有三个城市
你可以选择
那你选择哪一条 我们说离目标最近
我的目标在Bucharest 在这呢
明显的离目标最近的这个城市是
Sibiu 在地图上我们说
我的一个城市与目标城市Bucharest之间
我至少是可以根据地图的信息
来算出它的一个直线距离的
那么根据这个直线的距离
我就可以做出我的决定
那么从Sibiu出发
我还是有其他的几个城市可以到达
我可以到达Oradea
我可以到达Fagaras
还可以到达Rimnicu
那么从这三个城市而言
当然我不走回头路 我不会再回到Arad
从这三个城市而言
那我现在的策略 我说了我是贪心策略
我贪心哪个离目标最近我就找谁去接近
那么明显的这三个城市之间
离目标最近的是Fagaras
那么我的路径选择就走到了Fagaras
我们说这是从Arad出发
按照贪心策略 第一个选择是Sibiu
第二个选择就到了Fagaras
我就走到了Fagaras这条路
那么从Fagaras出发我们就一条线了
我就到达目标了
所以按照贪心策略 我所找到的这条路是从
Arad到Sibiu
到Fagaras 最后到Bucharest
但事实上
就是按照贪心算法 我从Arad出发
我肯定可以到达Bucharest
但是我们说从地图上来看
这个解释事实上不是一个最优解
它不是一个最短的路径解
我可能希望找一条最短的路
花最少的时间或花最少的钱
我走的路短所花的油钱也就少
但是我们按照贪心算法所选择的这个策略
并不是最优解 而最优解是在这个位置上
我们来看
这才是我们的最优解
你可以看到 在这个图上
我用红线标出来的这个解
才是一个最优解答
所以贪心策略帮我找到了一个解
但是这个解并不是一个最好的
或者至少它不是最短路径解
我们通过这个例子是希望你能够理解
在用计算机求解一个现实的
应用问题的时候
怎么样抽象出一个模型
有了这个模型之后
我怎么样把问题求解的过程自动化
这样我也就得到了我的算法
有了算法之后
按照算法一步一步执行
写出来程序
那么计算机就可以理解并且按照这个程序
去完成整个计算机的
问题求解过程
我们前面讲过图灵机是
理想计算机的数学模型
图灵机代表了计算机的能力
而我要使计算机工作起来
算法是一个非常核心的概念
下面我们就来看一下
图灵机跟算法之间有什么样的关系
对于计算本身而言计算的过程
或者说计算的本质就是符号串的变换
从一串符号串
变成符合某种运算要求的
另一串符号串
整个计算过程是指从初始符号
或者已知符号开始出发
一步一步的变换符号
而你的算法
归根到底就是把步骤描述清楚
步骤一定是经过有限步的确定的
步骤之后最后得到一个满足
预先规定的符号串的变换过程
变换过程就是我们说的计算过程
在这个计算过程中你可以看到
计算机的执行一步一步的变换
经过有限的步骤实际上就是
都跟算法密切相关
下面我们从图灵机的运行的
实例来体会一下
算法跟图灵机之间的关系
图灵机就是一条可以无限延伸的纸带
这条纸带上我给出一些符号
在这条纸带上可以写01
也可以写其它的符号
在这里我们只写了0和1
这一串是111101
而我上面给出了一个算法
大家看这句话是怎么说的
如果你读到1
那么写0
同时读写头向右走重复这个动作
而第二句话说的是
如果你读到的是0在这个位置写1
halt指的是停机图灵机的
工作停止了
第三句话说的是如果你读到的是空格
那么写1停机
这显然是一个算法
这个算法我可以用流程图画出来
这是开始
对于这台图灵机
这段过程进来首先是完成
一个判断
判断你读入的字符是否为1
如果读到的字符为1
也就是回答如果是yes
如果读入的字符为1
图灵机要做的工作是
第一步是在当前位置
写0
第二步动作则是
读写头向右走
做完这步后给出的时reapt
意味着要重新回到
最开始
读到的如果不是1
意味着要执行下一条语句了
这个时候来看读入的字符
是否为0
读到的字符是不是0
如果读入的字符为0
对于这个判断框回答为
yes的话
写1
写入字符
写1而下一个动作
就是
停机了画边上带圆的这个框
表示在这个时候开始
在这就结束了
这是停机了
如果读入的仍然不是0
就走到了条件判断的第三个语句
判断它读入的是不是空格
如果读入的为空格
动作是类似的也是写1
在这个当前位置上写1
然后停机
这就是我们
这个简单的图灵机的例子中
给出的算法的流程图
对于图灵机的纸带上的输入
是111101
按照这个算法的流程
我们来看它完成了什么样的操作
现在纸带上
输入的序列为
我的读写头指向了最左的字符
按照我们算法的流程来看下
由于第一个读入的字符为1
意味着第一个条件判断的框成立
读入的是1我要
做的操作一个是在
这个位置上1写上0
第二个动作是读写头右移一位
然后又回到最开始
重新读入字符
这个时候读入的字符依然是1
所以要做的操作
依然是执行的这边的动作序列
我们来看一下这个1
位置写0
删掉这个1
写0
然后读写头右移一位
这个时候读入的字符依然为1
也就是始终第一个框是成立的
第一个条件判断框的回答是yes
所以执行的动作依然是写0
右走一位
删除1
再这个位置写0
同时读写头右移
读写头右移一位
由于读入的字符依然是1
所执行的动作依然是在这个
位置上写0
同时读写头右移一位
把原来这个读写头去掉
回到最开始重头再开始
这个时候第一个条件判断框一上来
读入的字符是1吗这个菱形框
问的是你读入的字符是1吗
我的回答是no读入字符不是1
第二个判断读入的字符是0吗
是的 我读入的字符是0
这个时候你来看
动作就走到了
这个框框上了
这个时候我要做的操作
是在0这个位置写上1
写完1之后图灵机停机了
这个工作就算结束了可以看到
纸带上输入串的变化
是从111101变成了0000
11这个时候我们可以来看
原有的输入字串是111101
最后经过一串变换就变成
我们再来看一个
假设我在这里就是三个1
我们来看一下这个
这串算法所
工作的过程这假设就是我要
处理的数据就是撒个1
可以看到开始它读入的是
1按照我们刚才的运行过程
这个1要被修改为
0因为第一个条件判断成立
同时读写头右移一位
读入的还是1还是写0
继续右移
到这一位读入的还是1
1的位置把它改成0
读写头继续右移这个时候
读入的符号不是1
也不是0最终走到空格
读入的是空格执行这段动作
这个时候在这个位置上写1
同时停机
可以看到这个输入字串的变化是
从我的输入
输入串是111
最终变成0001
我不知道大家看出来没
对于这两个输入字串
仔细观察你会发现这个数
从右往左读
从右往左读对于
第一个数就变成了101111
最终它变成了110000
我这是不是完成了一个加1的操作
刚才我们做的111最终变成1
3个0从右往左读这个数
实际上是完成了加1的动作
从这可以看出不仅仅是在纸带上
同样在计算机内存中存放的
01的表示怎么样解释
取决于你所建立的模型
从右往左读代表了一个数可以
从左往右读代表了一个字符
也可以这取决于你的程序
你所建立的模型最终
通过程序去处理你如何解释
这些0和1
对于这个我们刚才看的是算法
这个算法这个工作的过程
似乎很类似于图灵机
我们来试一下能不能把这个算法
改造成图灵机呢
能不能用一个状态的转换表
来把算法描述出来
对于图灵机而言
我们通常会说
这个图灵机当中有哪些状态
我们说它有开始状态
像刚才我们也提到了它有停机
状态对于图灵机我们还关心
的字母表也就是在图灵机的
纸带上我可以出现哪些字符
我们这里包括有0有1
还有一些空格
从这可以看出开始状态就是start
而我的停机状态<br>
停止状态图灵机什么时候工作
结束我需要停机状态
停机状态用halt来表示
对于图灵机而言它的
停机状态可能有很多个是一个
结合而我这里
只有一个停机状态
对于图灵机而言最关键的是
它的状态转换表
状态转换表的组成有两个部分
一部分叫做输入
输入中包含两个信息
一个是你的当前状态是什么
再就是你读入的字符是什么
你在这个时候读入的字符是什么
状态转换表转换的第二部分
状态转换表
这是图灵机工作的核心
整个图灵机工作的过程
是以查表得方式来进行
我们再来看图灵机的输出
图灵机的输出包括三个部分
一个是我需不需要在
纸带上当前位置写上新字符
另外一个是读写头需不需要移动
向左移动向右移动
输出还有一个方面指的是
要进入一个新的状态
对于刚才的
图灵机起始状态是start
一开始读入的字符可能是1
如果读入的字符为1意味着
当前位置上输出为0
而读写头是要右移
同时状态不变
这个动作要重复
状态不变还是start
在start这个状态遇到字符0
它的输出是在当前位置上写1
同时
读写头不动
没有它的动作了
而我进入一种停机的状态
同样的
对于如果在这个情况下我读入
是一个空格
这个时候在这个位置上同样写1
读写头也没有动作
我们把它叫stay
读写头不动
然后依然进入的是
停机状态
这样我就得到了
刚才这个算法我们简单
写出了它的图灵机表示方法
我们来看它们是否完成同样的操作
假设纸带上的输入字符为
读写头在
最左端
而我的开始状态为start
这个时候读入字符为1
这个时候意味着我要在当前纸带
位置上写0
按照查表它对应的是这一行
对应的图灵机状态转换表的第一行
对于这一行我们可以来
看它要输出字符为0
当前位置上写0 同时读写头
右移一位
状态依然在start
这个时候第二步而言状态还是start
只是读写头指向的字符为0了
我们再来查这个表
它对应的是这个表的第二行
第二行中我们可以看到
在状态为start读入状态为0的情况下
我在当前位置上写1
原有的0就抹掉啦写1之后
读写头不动同时图灵机停机
在这就停机了不再工作了
从这可以看到我们的
最初的输入字符串为101
最终变成110这个数是
从右往左读
跟我们刚才解释的是一样的
从右往左读看图灵机完成加1的动作
可以看到刚才是一个算法
这个算法被改造成图灵机
在大学计算机基础这门课当中
我们要求大家要理解流程图
能够用流程图简单
的表达出一些算法来
流程图在这个概念最早出现
在上个世纪的二十年代
主要应用在工业领域
应用在制造业当中
在工业领域完成制造的过程当中
用图示的一种方法
来表示过程
从1950年以后
流程图被广泛的用于
软件的设计当中
这是一幅矿石物料加工
用于冶金工业的一幅流程图
在这个流程图当中你可以
看到一些长方形的框
这些框里面记录了
金属在冶炼当中的一些步骤
这些长方形框之间的链接
用一些有箭头的线来表示
这表示过程进行的一种先后关系
下面我们通过一个简单的例子
把流程图的工作模式理解一下
前面我们举了泡茶的例子
泡茶的计算步骤包括
我要先烧开水
然后把茶叶放到茶壶里
泡上一会儿经过一段时间之后
那么这个茶泡好啦
我们用流程图
更直观的形式
用图示的方法
我们把它表示出来就是这样
前面我们讲过在描述
一个流程图的时候
主要的图例包括
起止框
平行四边形的输入输出框
以及菱形的判断框
带箭头的线表示流程线
长方形框指的是处理框
有的时候一幅流程图比较大
一块画不下来或者一张纸画不下
中间用连接表明
我这个图还没完
还在下一张纸上
还得继续
在我们进行数据处理
在计算机完成自动计算的时候
这个序一样是重要的
很多时候我们可以用流程图
来表示如何
处理一个问题的计算步骤
下面我们再来看一个
计算当中的例子
在中学大家都学过
如何去算一个梯形的面积
我有梯形面积的计算公式
那么现在我希望你能写出一个算法
只要我告诉你梯形的上底
下底和高
就希望你能把梯形的面积求出来
那么流程图的开始
都要画上开始框
那么计算梯形的面积
在你完成这个计算之前
一定要知道它的上底下底
和高是什么
所以一开始可能是一个输入框
那么这个输入要求你输入
用a来表示梯形的上底
用b来表示梯形的下底
用c来表示梯形的高
那么对于输入输出框
我们的流程图是
平行四边形的图示
用平行四边形来表示
输入输出
那么现在知道上底下底
以及梯形的高
那么下面我就可以完成计算
梯形的面积
真正完成梯形的面积计算结果
我用area来表示
计算它的面积
梯形的面积等于
上底加下底乘以高除以2
这是一个明确的计算处理框
之后你area计算我们说这个计算
过程是在cpu当中完成
它的计算完成之后
这个结果存放在
area内存的地址当中
对于用户而言我要知道
它最终计算的这个结果
那么还需要做一步输出
输出这个面积
那么这个同样是
输入输出框用平行四边形
再往下走
我这个梯形的面积是结束
这是流程图的结束框
我们希望大家从这个流程图
能够体会出我们
关于算法的几个重要特征
前面我们提到过
对于一个算法而言
它会有零或多个输入
这是它的第一个特征
第二个特征是
它会有输出
第三个特征是
一定是有限步骤
第四个特征则说的是
每一步都要是非常确定
那么计算机的执行它
不允许出现模糊的
二义性的东西一定是非常确定的
第五个
这个计算要能够有
效的完成我的要求
一定能够有效的完成这个动作
你比方说做除法
如果做除法除数不能为零
这就是指的
它的有效性
所以对于计算机我们有自己的数学基础
那么现代的数学可能可以考虑两大类
一类我们说是研究连续对象的
像分析 方程
像你在大学一年学习高等数学
那么它研究的是连续对象连续函数
那么还有一大类就是研究离散对象的数学
我们把它叫做离散数学
离散数学就是计算机出现以后
迅速发展起来的一个数学分支
那么它成为了
计算机的数学基础
那么计算机我们说之所以
被成为电脑好像是具有思维的
实际上是因为计算机执行的有人编写的程序
而程序我们前面介绍过
程序是什么 程序就是算法加上数据结构
那么谁能保证你的程序
对问题求解得到的解答是正确的呢
那么这里就是算法背后的一些数学基础
我们刚才讲了
求取最大公约数的欧几里德算法
实际上它有两种表现形式
一种是辗转相减 一种是辗转相除
我们对辗转相除给出了数学证明
同样的对辗转相减
你也可以给出自己的数学证明
关于对一个算法如何进行评价
我们在后面的课程当中还要进一步讨论
在我做这两个例子之前
我请大家思考了算法都有什么样的特征
那么下面我们就来看
唐纳德克努特也是图灵奖的获得者
他有个中文名字叫高德纳
那么他在他的著作《计算机程序设计艺术》
这样一本书当中
明确了算法具有五大特征
那么他这套书计划出版七卷
那么现在至少已经写好了四卷
下面我们就来看算法的特征
那么对于一个算法 我们说
一个算法必须有零个或零个以上的输入
那么同时对算法也要有输出
一个算法应该有一个或一个以上的输出量
输出量实际上就是指算法计算的结果
那么对于我们刚才讨论的
求最大公约数的欧几里德算法
我们说它的输入是两个
我需要求最大公约数
我需要对两个整数来求最大公约数
那么最后的输出就是一个整数
我要把这个最大的公约数求出来
其他的重要的算法特征还包括
算法一定是具有明确性的
这个明确性指的是算法的每一个步骤
都必须精确的定义
你执行的动作的每一步都必须严格的
无歧义的描述清楚
那么这样才能保证
算法的实际执行结果能够精确的符合
问题的要求或者期望
算法是有限的
有限性这个概念
在计算机科学当中是非常重要的
那么算法必须是在有限个步骤内终止
那么算法又一定是具有有效性的
这个有效性有时候又称作可行性或能行性
算法的所有运算都必须是充分基本的
因而原则上人们使用笔和纸在有限时间内
能够精确的完成它们
算法当中描述的操作
都可以通过已经实现的基本运算
执行有限次来实现
这是指的算法的有效性
那么计算机从这个名字上来说
它的发明是为了计算
科学计算现在依然是
计算机的一个非常重要的应用
计算机可以自动的完成很多的计算
只要你编程完成了算法
那么计算机就会自动的
按照程序的规定一步一步去完成
去求得最终计算的解答
我们下面看一个简单的计算 这个计算是
为了求取两个数的最大公约数的
那么求取两个数的最大公约数
这是由欧几里德提出来的算法
这个算法可以看出是最古老的算法之一
这个算法大家在中学是有所接触的
中学可能都学过
辗转相除 辗转相减
所以这是欧几里德算法的两种表现形式
一种是辗转相除 一种是辗转相减
那么我们下面通过两个例子
希望你能够体会出算法的基本特征有哪些
也能够去体会这两种算法
哪种好 哪种坏 我该怎么样
去评价一个算法
我想求1122和867的最大公约数
我们先来看辗转相减该怎么做
辗转相减我们说讲的是
两个数的最大公约数与它们做减法之后
再和其中的小数
求最大公约数的结果是相同的
所以对于这个数而言
我们说这里就可以做1122减掉867
这个结果就应该是255
那么它的最大公约数就应该等于
255和867求最大公约数
那么再往下 我们说可以继续往下算
因为255和867的最大公约数
又要等于它们之间 首先做个差
差再与小数求最大公约数
867减掉255 剩下612
那么这个计算步骤继续下去
你可以看到这个计算过程
做减法和小数 求最大公约数
GCD 这里依然小数是255
而612减去255则变成了357
我还没求出来 这个算法继续
小的数留下 大的数变成了它们之间的差
这个数变成了102
再往下
小数留下 大数变成了它们之间的差
我之所以能够一直这么做是因为
我前面有数学背后的定理支持
两个数的最大公约数
等于它们的差
和那个比较小的数之间求最大公约数
所以我可以一步一步进行下去
再往下做就变成了
GCD 51剩下 它们的差也变成了51
那么现在就可以说一目了然了 我知道
这两个数之间的最大公约数就应该是51
那么这里你特别要注意一下的就是
对于一个计算过程 计算步骤
它什么时候开始 它是怎么开始的
它又是如何结束的
我为什么停在这了 因为我知道
到这我就求取出了最大公约数
这是用辗转相减
我用差和它的小数去比较
我们下面看辗转相除的
辗转相除我们说 留下的是什么
一样的是
比较小的这个数867
那么这个大的数1122就变成了什么
变成了它除以867之后的一个余数
那么这个余数也是255
我把它留在这里好了
两个算法的第一步的结论是一样的
我们再来看第二步
再往下我们继续做
我要求取867和255之间的
最大公约数怎么办呢
我用867去除以255
然后求取它的余数
867除以255
所以这个余数就应该是102
所以这里就变成了这个剩下的小数
与余数 867除以255
之间的余数102 求最大公约数
我们再往下来算
对于它而言我还看不出最大公约数是多少
那么继续往下算
小数留下 大数则变成整除之后的余数
那么这个整除之后的余数就变成了51
再往下 我们说算法还要继续往下走
走到什么时候算是算法结束呢
走到这里
小数留下
这个时候的余数就是为0了
那么在这里我们说 出现了一个0的时候
这个算法实际上就可以结束了
0前面的这个数51
就成为了这两个数之间的最大公约数
那么对于我们给出的这个例子
大家可以比较这两个算法的执行
这两个算法最终
按照我们的计算步骤都可以求出最大公约数
但是比较谁算的比较快
我们可以看到辗转相除
收敛的更快 可以很快的找出最大公约数
那么辗转相除说的就是
我要求取两个数的最大公约数
a和b这样两个最大公约数
它与把a这个数与b取模得到的余数
再与b来求最大公约数
那么这两个最大公约数是相等的
这是辗转相除背后的基本原理
我们下面来对它完成一个证明
我们下面希望证明
a和b的最大公约数与
a与b为模求得余数
这个余数与b再求最大公约数
这两个最大公约数是相等的
那么不失一般性
我们就假设a大于b大于0
假设a和b都是正整数
那么既然a大于b 我就可以把a表示成
kb加上r的形式
这个k是自然数
那么下面我们假设
d为a b的公约数
假设d为a b的公约数
那么也就意味着
d可以被a整除
我就用这样式子来表示
a可以整除d
那么同样的d也可以被b整除
下面我们假设d为a b的公约数
那么既然它是公约数 意味着
它既能被a整除又能被b整除
那我们再来看我们刚才假设的
r等于什么 r等于a减去kb
那么你看等号的左右两侧
那么等号的右边我们说
因为d既能被a整除又能被b整除
那么意味着d是可以被r整除的
所以有d可以被r整除
而事实上这个r等于a减kb
它的结果就是a与b取模
得到的余数
那么从这我们就证明了
证明了d如果是a b的公约数
就一定会有
d也是
a与b为模取余数
和b的公约数
那么我刚才证的这一步就是
假设d是a b的公约数
我证明了d一定也是
a与b为模求余数
得到的这个余数与b的公约数
那么下面我们反过来
这是第一步
第二步我们来看
假设d撇为a与b为模求余数
和b的公约数
那么这意味着d
可以被a mod b整除
那么这意味着d可以被
a除以b的余数所整除
也可以被b所整除
那么这句话实际上指的是d可以被r整除
而我们前面讲过
a的假设是a等于kb加上r
这一部分可以被d整除
我现在又得出了r也可以被d整除
所以下面的结论就是
这个d也是a b的公约数
所以对于等号左右两端的这两个数
我们求公约数 可以证明
它们所有的公约数都是相同的
从而也就说明
它们的最大公约数也是相同的
事实上这个证明过程很多的是数学的基础
我之所以要在这里完成这样一个证明
是希望你能够认识到
我们的算法设计 我要找出一个计算过程
我要描述好一个算法去进行问题求解
背后并不是靠的一些小聪明和小技巧
那么背后都有它深厚的理论基础
包括数学基础
所以对于计算机我们有自己的数学基础
那么现代的数学可能可以考虑两大类
一类我们说是研究连续对象的
像分析 方程
像你在大学一年学习高等数学
那么它研究的是连续对象连续函数
那么还有一大类就是研究离散对象的数学
我们把它叫做离散数学
离散数学就是计算机出现以后
迅速发展起来的一个数学分支
那么它成为了
计算机的数学基础
那么计算机我们说之所以
被成为电脑好像是具有思维的
实际上是因为计算机执行的有人编写的程序
而程序我们前面介绍过
程序是什么 程序就是算法加上数据结构
那么谁能保证你的程序
对问题求解得到的解答是正确的呢
那么这里就是算法背后的一些数学基础
我们刚才讲了
求取最大公约数的欧几里德算法
实际上它有两种表现形式
一种是辗转相减 一种是辗转相除
我们对辗转相除给出了数学证明
同样的对辗转相减
你也可以给出自己的数学证明
关于对一个算法如何进行评价
我们在后面的课程当中还要进一步讨论
在我做这两个例子之前
我请大家思考了算法都有什么样的特征
那么下面我们就来看
唐纳德克努特也是图灵奖的获得者
他有个中文名字叫高德纳
那么他在他的著作《计算机程序设计艺术》
这样一本书当中
明确了算法具有五大特征
那么他这套书计划出版七卷
那么现在至少已经写好了四卷
下面我们就来看算法的特征
那么对于一个算法 我们说
一个算法必须有零个或零个以上的输入
那么同时对算法也要有输出
一个算法应该有一个或一个以上的输出量
输出量实际上就是指算法计算的结果
那么对于我们刚才讨论的
求最大公约数的欧几里德算法
我们说它的输入是两个
我需要求最大公约数
我需要对两个整数来求最大公约数
那么最后的输出就是一个整数
我要把这个最大的公约数求出来
其他的重要的算法特征还包括
算法一定是具有明确性的
这个明确性指的是算法的每一个步骤
都必须精确的定义
你执行的动作的每一步都必须严格的
无歧义的描述清楚
那么这样才能保证
算法的实际执行结果能够精确的符合
问题的要求或者期望
算法是有限的
有限性这个概念
在计算机科学当中是非常重要的
那么算法必须是在有限个步骤内终止
那么算法又一定是具有有效性的
这个有效性有时候又称作可行性或能行性
算法的所有运算都必须是充分基本的
因而原则上人们使用笔和纸在有限时间内
能够精确的完成它们
算法当中描述的操作
都可以通过已经实现的基本运算
执行有限次来实现
这是指的算法的有效性
那么前面我们讲了抽象与模型
讲了自动化与算法
那么下面我们通过一个例子
来把这条线
来把这个计算机问题求解的过程
来把它串一下
这个例子讲的是在罗马尼亚旅游的问题
我现在在罗马尼亚的这个城市
这个城市的名字叫做Arad
这是我的起点
那我过两天我要从这个Bucharest离开
我要从这离开坐飞机回北京 回中国
现在要解决的问题就是
我怎么样从Arad出发能够抵达Bucharest呢
你可以走不同的路
可以采用各种各样的交通工具 你可以飞
你可以驾车 你还可以租车
甚至你可以步行 只要你时间赶得及
当然解决这个问题
你选择怎么样的路径怎么样的方法
这取决于你的目标是什么
同时你还要考虑你当前的约束条件
你是希望赶时间 还是希望看风景
所以这取决于你的目标和你的约束
这最终将决定你的行为
那么这里我们首先看到的问题是
我出去旅游 我在罗马尼亚旅游
我一定有它一个地图
这是一个基本的常识 我需要有地图
那我现在的问题是这样
我已经决定了我准备开车去
我要找到一条路
我不飞我也不步行
我准备开车去
那么这样我就希望来找出一条路
使得我能够开车从Arad
到达这个Bucharest
而罗马尼亚的公共交通可能是非常发达
它有很多条路 那我怎么选择我的路径呢
我是往哪边走呢
这么多条路我选择哪条路去走呢
那么首先我们说
面对这个问题我要考虑的
就是对这个交通图 对我手上的这个地图
我该如何进行抽象
关于这些所有的地图信息
我该怎么样建立一个模型
而这个模型在计算机科学当中
很常见的就是我们使用图
那么图论也是计算机科学
一个非常重要的内容
我们用图来表示罗马尼亚问题
每一个城市 以及城市之间的这个道路
只要有道路连通
我们可以用一条线来表示
表示这中间有公路可以直通
而这些城市
都把它抽象成了
图中的一个节点
而把道路抽象成了两个节点之间的一条线
那么这就是我为罗马尼亚问题
所建立的一个模型 这就是一种抽象
而用图 用图论
在计算机当中来求解问题
这是非常常见的
我已经把它抽象成了一个模型
有了这样一个模型之后
我怎么样在这个模型之上进行问题求解呢
那么你从Arad出发
首先就面对着我有三条路可以走
我到底往哪条路走呢
你要明确的告诉计算机
一个选择的标准
就是计算机它的每一步动作都要确定
你要告诉它
或者说你按照东南西北四个方向
你按照一个怎样的顺序去尝试你的道路
或者说你可以采用一些很明确的算法
三个城市之间我该选择哪条路
哪个目标去前进呢
这就是我们讲的自动化与算法的问题
而这个算法的选择
我们说你有很多种方法
也可以选择其他的一些算法
你比方我们经常提到的
在后面我们还要进行深入讨论的
这个贪心算法
那么贪心算法的思路就在于
我在选择的时候
我选择离目标最近的那个城市
而从Arad出发
我们说这里有三个城市
你可以选择
那你选择哪一条 我们说离目标最近
我的目标在Bucharest 在这呢
明显的离目标最近的这个城市是
Sibiu 在地图上我们说
我的一个城市与目标城市Bucharest之间
我至少是可以根据地图的信息
来算出它的一个直线距离的
那么根据这个直线的距离
我就可以做出我的决定
那么从Sibiu出发
我还是有其他的几个城市可以到达
我可以到达Oradea
我可以到达Fagaras
还可以到达Rimnicu
那么从这三个城市而言
当然我不走回头路 我不会再回到Arad
从这三个城市而言
那我现在的策略 我说了我是贪心策略
我贪心哪个离目标最近我就找谁去接近
那么明显的这三个城市之间
离目标最近的是Fagaras
那么我的路径选择就走到了Fagaras
我们说这是从Arad出发
按照贪心策略 第一个选择是Sibiu
第二个选择就到了Fagaras
我就走到了Fagaras这条路
那么从Fagaras出发我们就一条线了
我就到达目标了
所以按照贪心策略 我所找到的这条路是从
Arad到Sibiu
到Fagaras 最后到Bucharest
但事实上
就是按照贪心算法 我从Arad出发
我肯定可以到达Bucharest
但是我们说从地图上来看
这个解释事实上不是一个最优解
它不是一个最短的路径解
我可能希望找一条最短的路
花最少的时间或花最少的钱
我走的路短所花的油钱也就少
但是我们按照贪心算法所选择的这个策略
并不是最优解 而最优解是在这个位置上
我们来看
这才是我们的最优解
你可以看到 在这个图上
我用红线标出来的这个解
才是一个最优解答
所以贪心策略帮我找到了一个解
但是这个解并不是一个最好的
或者至少它不是最短路径解
我们通过这个例子是希望你能够理解
在用计算机求解一个现实的
应用问题的时候
怎么样抽象出一个模型
有了这个模型之后
我怎么样把问题求解的过程自动化
这样我也就得到了我的算法
有了算法之后
按照算法一步一步执行
写出来程序
那么计算机就可以理解并且按照这个程序
去完成整个计算机的
问题求解过程
所以对于计算机我们有自己的数学基础
那么现代的数学可能可以考虑两大类
一类我们说是研究连续对象的
像分析 方程
像你在大学一年学习高等数学
那么它研究的是连续对象连续函数
那么还有一大类就是研究离散对象的数学
我们把它叫做离散数学
离散数学就是计算机出现以后
迅速发展起来的一个数学分支
那么它成为了
计算机的数学基础
那么计算机我们说之所以
被成为电脑好像是具有思维的
实际上是因为计算机执行的有人编写的程序
而程序我们前面介绍过
程序是什么 程序就是算法加上数据结构
那么谁能保证你的程序
对问题求解得到的解答是正确的呢
那么这里就是算法背后的一些数学基础
我们刚才讲了
求取最大公约数的欧几里德算法
实际上它有两种表现形式
一种是辗转相减 一种是辗转相除
我们对辗转相除给出了数学证明
同样的对辗转相减
你也可以给出自己的数学证明
关于对一个算法如何进行评价
我们在后面的课程当中还要进一步讨论
在我做这两个例子之前
我请大家思考了算法都有什么样的特征
那么下面我们就来看
唐纳德克努特也是图灵奖的获得者
他有个中文名字叫高德纳
那么他在他的著作《计算机程序设计艺术》
这样一本书当中
明确了算法具有五大特征
那么他这套书计划出版七卷
那么现在至少已经写好了四卷
下面我们就来看算法的特征
那么对于一个算法 我们说
一个算法必须有零个或零个以上的输入
那么同时对算法也要有输出
一个算法应该有一个或一个以上的输出量
输出量实际上就是指算法计算的结果
那么对于我们刚才讨论的
求最大公约数的欧几里德算法
我们说它的输入是两个
我需要求最大公约数
我需要对两个整数来求最大公约数
那么最后的输出就是一个整数
我要把这个最大的公约数求出来
其他的重要的算法特征还包括
算法一定是具有明确性的
这个明确性指的是算法的每一个步骤
都必须精确的定义
你执行的动作的每一步都必须严格的
无歧义的描述清楚
那么这样才能保证
算法的实际执行结果能够精确的符合
问题的要求或者期望
算法是有限的
有限性这个概念
在计算机科学当中是非常重要的
那么算法必须是在有限个步骤内终止
那么算法又一定是具有有效性的
这个有效性有时候又称作可行性或能行性
算法的所有运算都必须是充分基本的
因而原则上人们使用笔和纸在有限时间内
能够精确的完成它们
算法当中描述的操作
都可以通过已经实现的基本运算
执行有限次来实现
这是指的算法的有效性
Hello 大家好
我就是那个挂了头像
却一直隐身的周老师
话说我是负责辅助刘越老师守论坛的
但在刘越老师的一再威逼下
今天我只好被迫出镜
初次见面 请大家多多关照
在进入正题之前
我想先谈谈我们这门
Mooc课程开课以来
我个人的一点感受
首先是开课时的新鲜感
以这样一种全新的教学模式
面向社会中不同行业
不同层次的自发学习者
开展计算机通识教育
将会是怎样的情形
随着课程的推进
注册人数节节攀升
论坛研讨日渐活跃
作业提交量不断增大
最初的新鲜感转变为异常的兴奋感
从未经历过如此庞大的虚拟课堂
也从未在我的 大学计算机基础
教学生涯中就一个话题
引发过如此热烈而深刻的讨论
面对同学们扑面而来的各种问题和建议
作为老师除了想方设法地
第一时间给予大家反馈和帮助以外
巨大的压力感也随之而来
如何能深入浅出地引导大家
学到真正有用的东西
如何通过各种教学手段
持续激发同学们的学习热情
如何通过这门课程的开设
让大家既充实了计算机知识
又体验了计算思维给你的生活
或者工作带来的变化和便利
这些问题推动着课程组的老师们
不断优化施教方案
不断提升课程品质
在同学们享受着Mooc平台带来的自主学习
互助学习的成就感的同时
老师们也收获了知识传递
和自我提升的快乐
借这个机会谢谢各位同学捧场
也请继续跟随我们来完成
这一季体验计算之美的旅程
我们下次再见
好了 言归正传
今天我的主要任务是对开课第一周
推出的关于 摩尔定律 的研讨话题
进行一下总结和讲评
首先 我们来回顾一下什么是摩尔定律
在刘越老师第一周的课程讲授中告诉我们
摩尔定律是英特尔公司的
创始人之一戈登摩尔
1965年发现的一个计算机芯片的发展趋势
这个趋势是说
集成电路芯片上所有集成的晶体管数目
每隔十八个月就翻一番
而价格相对下降一半
用大家熟悉的事情来解释
就是你现在买了一台计算机
一年半以后
你可以用差不多同样的价格
更换一台性能翻番的新机器
我们研讨的背景是一则题为
摩尔定律面临失效 芯片恐难继续降价的
科技新闻
那么你认为摩尔定律是否会失效
如果失效
将对计算机产业带来哪些影响
我花了大概2个小时
认真翻看了同学们在论坛中的发言
做了一些统计工作
在这里我简单总结一下
发言的同学中有初学者
也有有一定计算机基础的
有学材料的 也有文科专业的
发言的观点中有的从基础理论角度推断
有的从市场产业发展角度解释
甚至有的从哲学辩证的角度分析
当然还有纯粹跟着感觉走的
但我想说的是
无论你的来源如何
你的观点是否正确
能积极参与到学习讨论
就值得给自己点赞
下面我们来看看具体的数据
379人的观点大致可以分为三类
失效 不失效 是否失效很难说
需要说明的是
我将认为 未来一定时期内有效
但长期来看会失效 的观点
一并归入了 失效 这一类的统计中
从统计图中可以看出
大部分同学都认为
摩尔定律终将推出历史舞台
只是维持的时间长短问题
这部分同学给出的理由
可以归结为以下三个论点
单位面积上可以集成的晶体管数量
终将达到物理极限
正如新闻中的萨姆利所言
你不可能仅使用一个原子来制造晶体管
因此当元器件的发展
遭遇到了物理上瓶颈
摩尔定律将不再有效
芯片上晶体管的集成度越高
制造工艺越复杂
越精密的制造技术
意味着芯片的制造成本就越昂贵
因此摩尔定律关于性能提升一倍
价格相对下降一半的经济学预测
也将无法维持
摩尔定律不是一个严谨的公式化的定律
仅仅是电子技术发展时
特定条件下的一个经验定律
当技术发展的必要条件丧失了
摩尔定律失效就是必然的了
而反方
大约有21%的同学
表示了对摩尔定律的信心
认为它不会失效的理由
也可以归结为三个论点
一 纵观科技发展的历史
总会有令人惊叹的突破
目前只不过暂时还没有找到
更好的材料提高集成度
没有提出新的技术简化工艺
相信人类的智慧会尽快解决
摩尔定律不会失效
二 计算机的性能并不完全
取决于芯片制造水平
系统架构 软件 应用
甚至新的计算形态或者方法
都能进一步提升计算机的性能
从整体性能的角度来看
IT行业会竭尽全力
让摩尔定律继续发挥作用
三 广义的摩尔定律可以理解为
对计算机发展趋势的大致判断
计算能力呈现一个指数形式的上升
如果从这个角度来解读
它是不会过时的
另外 还有少部分同学表达了
对摩尔定律未来的不确定
似乎已经感受到技术变革的气息
但何去何从还难下定论
这其中
有一个有趣的观点引起了我的关注
大体是说
作为行业领袖的英特尔
为了占据其霸主地位
一直在尽力延续摩尔定律的寿命
产业发展与摩尔定律之间
达成了微妙的默契
有节奏地推动着整个半导体行业的发展
我想
这就是技术与社会相互作用融合的结果
上述观点可谓仁者见仁智者见智
都有一定的道理
事实上
面对这样一个开放的话题
我们的目的不是得出确定的答案
而是通过阅读
思考和讨论来透过现象看本质
锻炼分析问题能力
最终达成一些共识
至于摩尔定律的失效
将会对IT产业带来什么影响
多数同学都持乐观的估计
认为业界会加快寻求新技术
研发新产品的步伐
计算机的发展将迎来新的契机
事实上早在2005年
我参加欧洲超算国际会议的时候
大会的主题演讲中
就已经有业界专家发表了
为摩尔定律失效做前瞻性研究的看法
近年来业界对生物 量子 光计算
人工智能等新型计算机的探索也如火如荼
正如一位同学在发言中所说
这个定律的背后
是人类不断创新的能力
是永不满足现状
对新技术对新事物的探索
因此 我们有理由相信
计算机的发展有无限空间
计算思维将成为
未来每个人不可或缺的基本素养
今天的讲评就到这里
你还满意么
好了 言归正传
今天我的主要任务是对开课第一周
推出的关于 摩尔定律 的研讨话题
进行一下总结和讲评
首先 我们来回顾一下什么是摩尔定律
在刘越老师第一周的课程讲授中告诉我们
摩尔定律是英特尔公司的
创始人之一戈登摩尔
1965年发现的一个计算机芯片的发展趋势
这个趋势是说
集成电路芯片上所集成的晶体管数目
每隔十八个月就翻一番
而价格相对的下降了一半
用大家熟悉的事情来解释
就是你现在买了一台计算机
一年半以后
你可以用差不多同样的价格
更换一台性能翻番的新机器
我们研讨的背景是一则题为
摩尔定律面临失效 芯片恐难继续降价
科技新闻
那么你认为摩尔定律是否会失效
如果失效
将对计算机产业带来哪些影响
我花了大概2个小时
认真翻看了同学们在论坛中的发言
做了一些统计工作
在这里我简单总结一下
发言的同学中有初学者
也有有一定计算机基础的
有学材料的 也有文科专业的
发言的观点中有的从基础理论角度推断
有的从市场产业发展角度解释
甚至有的从哲学辩证的角度分析
当然还有纯粹跟着感觉走的
但我想说的是
无论你的来源如何
你的观点是否正确
能积极参与到学习讨论
就值得给自己点赞
下面我们来看看具体的数据
观点大致可以分为三类
失效 不失效 是否失效很难说
需要说明的是
我将认为 未来一定时期内有效
但长期来看会失效 的观点
一并归入了 失效 这一类的统计中
从统计图中可以看出
大部分同学都认为
摩尔定律终将推出历史舞台
只是维持的时间长短问题
这部分同学给出的理由
可以归结为以下三个论点
单位面积上可以集成的晶体管数量
终将达到物理极限
正如新闻中的萨姆利所言
你不可能仅使用一个原子来制造晶体管
因此当元器件的发展
遭遇到了物理上瓶颈
摩尔定律将不再有效
芯片上晶体管的集成度越高
制造工艺越复杂
越精密的制造技术
意味着芯片的制造成本就越昂贵
因此摩尔定律关于性能提升一倍
价格相对下降一半的经济学预测
也将无法维持
摩尔定律不是一个严谨的公式化的定律
仅仅是电子技术发展时
特定条件下的一个经验定律
当技术发展的必要条件丧失了
摩尔定律失效就是必然的了
而反方
大约有21%的同学
表示了对摩尔定律的信心
认为它不会失效的理由
也可以归结为三个论点
一 纵观科技发展的历史
总会有令人惊叹的突破
目前只不过暂时还没有找到
更好的材料提高集成度
没有提出新的技术简化工艺
相信人类的智慧会尽快解决
摩尔定律不会失效
二 计算机的性能并不完全
取决于芯片制造水平
系统架构 软件 应用
甚至新的计算形态或者方法
都能进一步提升计算机的性能
从整体性能的角度来看
IT行业会竭尽全力
让摩尔定律继续发挥作用
三 广义的摩尔定律可以理解为
对计算机发展趋势的大致判断
计算能力呈现一个指数形式的上升
如果从这个角度来解读
它是不会过时的
另外 还有少部分同学表达了
对摩尔定律未来的不确定
似乎已经感受到技术变革的气息
但何去何从还难下定论
这其中
有一个有趣的观点引起了我的关注
大体是说
作为行业领袖的英特尔
为了占据其霸主地位
一直在尽力延续摩尔定律的寿命
产业发展与摩尔定律之间
达成了微妙的默契
有节奏地推动着整个半导体行业的发展
我想
这就是技术与社会相互作用融合的结果
上述观点可谓仁者见仁智者见智
都有一定的道理
事实上
面对这样一个开放的话题
我们的目的不是得出确定的答案
而是通过阅读
思考和讨论来透过现象看本质
锻炼分析问题能力
最终达成一些共识
至于摩尔定律的失效
将会对IT产业带来什么影响
多数同学都持乐观的估计
认为业界会加快寻求新技术
研发新产品的步伐
计算机的发展将迎来新的契机
事实上早在2005年
我参加欧洲超算国际会议的时候
大会的主题演讲中
就已经有业界专家发表了
为摩尔定律失效做前瞻性研究的看法
近年来业界对生物 量子 光计算
人工智能等新型计算机的探索也如火如荼
正如一位同学在发言中所说
这个定律的背后
是人类不断创新的能力
是永不满足现状
对新技术对新事物的探索
因此 我们有理由相信
计算机的发展有无限空间
计算思维将成为
未来每个人不可或缺的基本素养
今天的讲评就到这里
你还满意么
我们下次再见
好了 言归正传
今天我的主要任务是对开课第一周
推出的关于 摩尔定律 的研讨话题
进行一下总结和讲评
首先 我们来回顾一下什么是摩尔定律
在刘越老师第一周的课程讲授中告诉我们
摩尔定律是英特尔公司的
创始人之一戈登摩尔
1965年发现的一个计算机芯片的发展趋势
这个趋势是说
集成电路芯片上所有集成的晶体管数目
每隔十八个月就翻一番
而价格相对下降一半
用大家熟悉的事情来解释
就是你现在买了一台计算机
一年半以后
你可以用差不多同样的价格
更换一台性能翻番的新机器
我们研讨的背景是一则题为
摩尔定律面临失效 芯片恐难继续降价的
科技新闻
那么你认为摩尔定律是否会失效
如果失效
将对计算机产业带来哪些影响
我花了大概2个小时
认真翻看了同学们在论坛中的发言
做了一些统计工作
在这里我简单总结一下
发言的同学中有初学者
也有有一定计算机基础的
有学材料的 也有文科专业的
发言的观点中有的从基础理论角度推断
有的从市场产业发展角度解释
甚至有的从哲学辩证的角度分析
当然还有纯粹跟着感觉走的
但我想说的是
无论你的来源如何
你的观点是否正确
能积极参与到学习讨论
就值得给自己点赞
下面我们来看看具体的数据
379人的观点大致可以分为三类
失效 不失效 是否失效很难说
需要说明的是
我将认为 未来一定时期内有效
但长期来看会失效 的观点
一并归入了 失效 这一类的统计中
从统计图中可以看出
大部分同学都认为
摩尔定律终将推出历史舞台
只是维持的时间长短问题
这部分同学给出的理由
可以归结为以下三个论点
单位面积上可以集成的晶体管数量
终将达到物理极限
正如新闻中的萨姆利所言
你不可能仅使用一个原子来制造晶体管
因此当元器件的发展
遭遇到了物理上瓶颈
摩尔定律将不再有效
芯片上晶体管的集成度越高
制造工艺越复杂
越精密的制造技术
意味着芯片的制造成本就越昂贵
因此摩尔定律关于性能提升一倍
价格相对下降一半的经济学预测
也将无法维持
摩尔定律不是一个严谨的公式化的定律
仅仅是电子技术发展时
特定条件下的一个经验定律
当技术发展的必要条件丧失了
摩尔定律失效就是必然的了
而反方
大约有21%的同学
表示了对摩尔定律的信心
认为它不会失效的理由
也可以归结为三个论点
一 纵观科技发展的历史
总会有令人惊叹的突破
目前只不过暂时还没有找到
更好的材料提高集成度
没有提出新的技术简化工艺
相信人类的智慧会尽快解决
摩尔定律不会失效
二 计算机的性能并不完全
取决于芯片制造水平
系统架构 软件 应用
甚至新的计算形态或者方法
都能进一步提升计算机的性能
从整体性能的角度来看
IT行业会竭尽全力
让摩尔定律继续发挥作用
三 广义的摩尔定律可以理解为
对计算机发展趋势的大致判断
计算能力呈现一个指数形式的上升
如果从这个角度来解读
它是不会过时的
另外 还有少部分同学表达了
对摩尔定律未来的不确定
似乎已经感受到技术变革的气息
但何去何从还难下定论
这其中
有一个有趣的观点引起了我的关注
大体是说
作为行业领袖的英特尔
为了占据其霸主地位
一直在尽力延续摩尔定律的寿命
产业发展与摩尔定律之间
达成了微妙的默契
有节奏地推动着整个半导体行业的发展
我想
这就是技术与社会相互作用融合的结果
上述观点可谓仁者见仁智者见智
都有一定的道理
事实上
面对这样一个开放的话题
我们的目的不是得出确定的答案
而是通过阅读
思考和讨论来透过现象看本质
锻炼分析问题能力
最终达成一些共识
至于摩尔定律的失效
将会对IT产业带来什么影响
多数同学都持乐观的估计
认为业界会加快寻求新技术
研发新产品的步伐
计算机的发展将迎来新的契机
事实上早在2005年
我参加欧洲超算国际会议的时候
大会的主题演讲中
就已经有业界专家发表了
为摩尔定律失效做前瞻性研究的看法
近年来业界对生物 量子 光计算
人工智能等新型计算机的探索也如火如荼
正如一位同学在发言中所说
这个定律的背后
是人类不断创新的能力
是永不满足现状
对新技术对新事物的探索
因此 我们有理由相信
计算机的发展有无限空间
计算思维将成为
未来每个人不可或缺的基本素养
今天的讲评就到这里
你还满意么
我们下次再见
好了 言归正传
今天我的主要任务是对开课第一周
推出的关于 摩尔定律 的研讨话题
进行一下总结和讲评
首先 我们来回顾一下什么是摩尔定律
在刘越老师第一周的课程讲授中告诉我们
摩尔定律是英特尔公司的
创始人之一戈登摩尔
1965年发现的一个计算机芯片的发展趋势
这个趋势是说
集成电路芯片上所集成的晶体管数目
每隔十八个月就翻一番
而价格相对的下降了一半
用大家熟悉的事情来解释
就是你现在买了一台计算机
一年半以后
你可以用差不多同样的价格
更换一台性能翻番的新机器
我们研讨的背景是一则题为
摩尔定律面临失效 芯片恐难继续降价
科技新闻
那么你认为摩尔定律是否会失效
如果失效
将对计算机产业带来哪些影响
我花了大概2个小时
认真翻看了同学们在论坛中的发言
做了一些统计工作
在这里我简单总结一下
发言的同学中有初学者
也有有一定计算机基础的
有学材料的 也有文科专业的
发言的观点中有的从基础理论角度推断
有的从市场产业发展角度解释
甚至有的从哲学辩证的角度分析
当然还有纯粹跟着感觉走的
但我想说的是
无论你的来源如何
你的观点是否正确
能积极参与到学习讨论
就值得给自己点赞
下面我们来看看具体的数据
观点大致可以分为三类
失效 不失效 是否失效很难说
需要说明的是
我将认为 未来一定时期内有效
但长期来看会失效 的观点
一并归入了 失效 这一类的统计中
从统计图中可以看出
大部分同学都认为
摩尔定律终将推出历史舞台
只是维持的时间长短问题
这部分同学给出的理由
可以归结为以下三个论点
单位面积上可以集成的晶体管数量
终将达到物理极限
正如新闻中的萨姆利所言
你不可能仅使用一个原子来制造晶体管
因此当元器件的发展
遭遇到了物理上瓶颈
摩尔定律将不再有效
芯片上晶体管的集成度越高
制造工艺越复杂
越精密的制造技术
意味着芯片的制造成本就越昂贵
因此摩尔定律关于性能提升一倍
价格相对下降一半的经济学预测
也将无法维持
摩尔定律不是一个严谨的公式化的定律
仅仅是电子技术发展时
特定条件下的一个经验定律
当技术发展的必要条件丧失了
摩尔定律失效就是必然的了
而反方
大约有21%的同学
表示了对摩尔定律的信心
认为它不会失效的理由
也可以归结为三个论点
一 纵观科技发展的历史
总会有令人惊叹的突破
目前只不过暂时还没有找到
更好的材料提高集成度
没有提出新的技术简化工艺
相信人类的智慧会尽快解决
摩尔定律不会失效
二 计算机的性能并不完全
取决于芯片制造水平
系统架构 软件 应用
甚至新的计算形态或者方法
都能进一步提升计算机的性能
从整体性能的角度来看
IT行业会竭尽全力
让摩尔定律继续发挥作用
三 广义的摩尔定律可以理解为
对计算机发展趋势的大致判断
计算能力呈现一个指数形式的上升
如果从这个角度来解读
它是不会过时的
另外 还有少部分同学表达了
对摩尔定律未来的不确定
似乎已经感受到技术变革的气息
但何去何从还难下定论
这其中
有一个有趣的观点引起了我的关注
大体是说
作为行业领袖的英特尔
为了占据其霸主地位
一直在尽力延续摩尔定律的寿命
产业发展与摩尔定律之间
达成了微妙的默契
有节奏地推动着整个半导体行业的发展
我想
这就是技术与社会相互作用融合的结果
上述观点可谓仁者见仁智者见智
都有一定的道理
事实上
面对这样一个开放的话题
我们的目的不是得出确定的答案
而是通过阅读
思考和讨论来透过现象看本质
锻炼分析问题能力
最终达成一些共识
至于摩尔定律的失效
将会对IT产业带来什么影响
多数同学都持乐观的估计
认为业界会加快寻求新技术
研发新产品的步伐
计算机的发展将迎来新的契机
事实上早在2005年
我参加欧洲超算国际会议的时候
大会的主题演讲中
就已经有业界专家发表了
为摩尔定律失效做前瞻性研究的看法
近年来业界对生物 量子 光计算
人工智能等新型计算机的探索也如火如荼
正如一位同学在发言中所说
这个定律的背后
是人类不断创新的能力
是永不满足现状
对新技术对新事物的探索
因此 我们有理由相信
计算机的发展有无限空间
计算思维将成为
未来每个人不可或缺的基本素养
今天的讲评就到这里
你还满意么
我们下次再见
好了 言归正传
今天我的主要任务是对开课第一周
推出的关于 摩尔定律 的研讨话题
进行一下总结和讲评
首先 我们来回顾一下什么是摩尔定律
在刘越老师第一周的课程讲授中告诉我们
摩尔定律是英特尔公司的
创始人之一戈登摩尔
1965年发现的一个计算机芯片的发展趋势
这个趋势是说
集成电路芯片上所有集成的晶体管数目
每隔十八个月就翻一番
而价格相对下降一半
用大家熟悉的事情来解释
就是你现在买了一台计算机
一年半以后
你可以用差不多同样的价格
更换一台性能翻番的新机器
我们研讨的背景是一则题为
摩尔定律面临失效 芯片恐难继续降价的
科技新闻
那么你认为摩尔定律是否会失效
如果失效
将对计算机产业带来哪些影响
我花了大概2个小时
认真翻看了同学们在论坛中的发言
做了一些统计工作
在这里我简单总结一下
发言的同学中有初学者
也有有一定计算机基础的
有学材料的 也有文科专业的
发言的观点中有的从基础理论角度推断
有的从市场产业发展角度解释
甚至有的从哲学辩证的角度分析
当然还有纯粹跟着感觉走的
但我想说的是
无论你的来源如何
你的观点是否正确
能积极参与到学习讨论
就值得给自己点赞
下面我们来看看具体的数据
379人的观点大致可以分为三类
失效 不失效 是否失效很难说
需要说明的是
我将认为 未来一定时期内有效
但长期来看会失效 的观点
一并归入了 失效 这一类的统计中
从统计图中可以看出
大部分同学都认为
摩尔定律终将推出历史舞台
只是维持的时间长短问题
这部分同学给出的理由
可以归结为以下三个论点
单位面积上可以集成的晶体管数量
终将达到物理极限
正如新闻中的萨姆利所言
你不可能仅使用一个原子来制造晶体管
因此当元器件的发展
遭遇到了物理上瓶颈
摩尔定律将不再有效
芯片上晶体管的集成度越高
制造工艺越复杂
越精密的制造技术
意味着芯片的制造成本就越昂贵
因此摩尔定律关于性能提升一倍
价格相对下降一半的经济学预测
也将无法维持
摩尔定律不是一个严谨的公式化的定律
仅仅是电子技术发展时
特定条件下的一个经验定律
当技术发展的必要条件丧失了
摩尔定律失效就是必然的了
而反方
大约有21%的同学
表示了对摩尔定律的信心
认为它不会失效的理由
也可以归结为三个论点
一 纵观科技发展的历史
总会有令人惊叹的突破
目前只不过暂时还没有找到
更好的材料提高集成度
没有提出新的技术简化工艺
相信人类的智慧会尽快解决
摩尔定律不会失效
二 计算机的性能并不完全
取决于芯片制造水平
系统架构 软件 应用
甚至新的计算形态或者方法
都能进一步提升计算机的性能
从整体性能的角度来看
IT行业会竭尽全力
让摩尔定律继续发挥作用
三 广义的摩尔定律可以理解为
对计算机发展趋势的大致判断
计算能力呈现一个指数形式的上升
如果从这个角度来解读
它是不会过时的
另外 还有少部分同学表达了
对摩尔定律未来的不确定
似乎已经感受到技术变革的气息
但何去何从还难下定论
这其中
有一个有趣的观点引起了我的关注
大体是说
作为行业领袖的英特尔
为了占据其霸主地位
一直在尽力延续摩尔定律的寿命
产业发展与摩尔定律之间
达成了微妙的默契
有节奏地推动着整个半导体行业的发展
我想
这就是技术与社会相互作用融合的结果
上述观点可谓仁者见仁智者见智
都有一定的道理
事实上
面对这样一个开放的话题
我们的目的不是得出确定的答案
而是通过阅读
思考和讨论来透过现象看本质
锻炼分析问题能力
最终达成一些共识
至于摩尔定律的失效
将会对IT产业带来什么影响
多数同学都持乐观的估计
认为业界会加快寻求新技术
研发新产品的步伐
计算机的发展将迎来新的契机
事实上早在2005年
我参加欧洲超算国际会议的时候
大会的主题演讲中
就已经有业界专家发表了
为摩尔定律失效做前瞻性研究的看法
近年来业界对生物 量子 光计算
人工智能等新型计算机的探索也如火如荼
正如一位同学在发言中所说
这个定律的背后
是人类不断创新的能力
是永不满足现状
对新技术对新事物的探索
因此 我们有理由相信
计算机的发展有无限空间
计算思维将成为
未来每个人不可或缺的基本素养
今天的讲评就到这里
你还满意么
我们下次再见
Hello 大家好
我就是那个挂了头像
却一直隐身的周老师
话说我是负责辅助刘越老师守论坛的
但在刘越老师的一再威逼下
今天我只好被迫出镜
初次见面 请大家多多关照
在进入正题之前
我想先谈谈我们这门
Mooc课程开课以来
我个人的一点感受
首先是开课时的新鲜感
以这样一种全新的教学模式
面向社会中不同行业
不同层次的自发学习者
开展计算机通识教育
将会是怎样的情形
随着课程的推进
注册人数节节攀升
论坛研讨日渐活跃
作业提交量不断增大
最初的新鲜感转变为异常的兴奋感
从未经历过如此庞大的虚拟课堂
也从未在我的 大学计算机基础
教学生涯中就一个话题
引发过如此热烈而深刻的讨论
面对同学们扑面而来的各种问题和建议
作为老师除了想方设法地
第一时间给予大家反馈和帮助以外
巨大的压力感也随之而来
如何能深入浅出地引导大家
学到真正有用的东西
如何通过各种教学手段
持续激发同学们的学习热情
如何通过这门课程的开设
让大家既充实了计算机知识
又体验了计算思维给你的生活
或者工作带来的变化和便利
这些问题推动着课程组的老师们
不断优化施教方案
不断提升课程品质
在同学们享受着Mooc平台带来的自主学习
互助学习的成就感的同时
老师们也收获了知识传递
和自我提升的快乐
借这个机会谢谢各位同学捧场
也请继续跟随我们来完成
这一季体验计算之美的旅程
下面我们再来回顾一下
关于 抽象 这个话题
刘越老师列举了毕加索画牛
和伦敦地铁地图变迁
这两个十分生动形象的例子
来诠释抽象的概念和作用
抽象就是忽略一个主题中
与当前问题或者目标无关的那些方面
以便更充分地注意与当前问题或者
目标有关的那些方面
一言以蔽之 就是移除细节看主干
另一方面 刘越老师又用摩天轮
和函数的例子来说明
抽象是从众多相互关联的事务中
抽取出共同的 本质性的特征
舍弃那些非本质性的特征
同学们在研讨中列举了不少
工作学习中运用到抽象思维的例子
比如 经常参加考试的同学
考前拿到的考场示意图是
对考场布局的一种抽象
爱好旅游的同学
旅游地图是对旅游景点的一种抽象
建筑设计师绘制的图纸是
对建筑的一种抽象
医生出具的心电图是
对心脏活动的一种抽象
导演专业的学生呢
通过这部分内容的学习深刻领会了
编剧的过程可以抽象为
制造冲突 解释冲突和完结冲突
英语专业的学生得出了
语法就是英文句子的抽象
这样的结论 万变不离其宗
看似毫不相干的英文单词
按照固定的语法组成了
具有各种意义的英文句子
还有保险行业的同学
这时候他们再看那些熟悉的保险条款
在对保险产品进行概念描述时
其实都是对一类行为或者对象的抽象
而正在从事IT行业的同学体会更为深刻
比如在网络管理工作中
为了方便管理 从所有设备的互联中
抽象出网络拓扑结构
又比如作为驾驶模拟软件的开发人员
将车辆变道时其在水平
方向的移动距离抽象为y=sinx的函数
有一个同学举了个十分有趣的例子
是说某跨国日化公司
要解决肥皂生产线上
存在包装时可能漏包肥皂的问题
以博士牵头的专家研发团队
使用了红外 激光探测等尖端技术
花费了大量财力和精力
才完成了肥皂盒检测系统
将肥皂盒空填率有效的降低至5%以内
而某乡镇肥皂企业也遇到了类似的问题
初中毕业的流水线工头经过半天的思考
就拿了一台电扇到生产线的末端
对着传送带猛吹
那些没有装填肥皂的肥皂盒
由于重量轻就被风吹出去了
我们不去考究这两个例子的真实性
但其背后却隐含了另一个有益的结论
无论是专家团队
还是流水线的工头
都自觉或者不自觉地运用了抽象思维
前者是把肥皂盒漏装的问题
抽象为不同的物理材质的
光反射特征不同的探测问题
而后者呢则抽象为
不同的物理材质重量区分的问题
都是抽象 但应用的效果
却有很大的差异
因此 面对不同的应用问题
如何恰当地运用
抽象思维 也是值得我们关注的。
至于汽车发动机给蓄电池充电
为什么不采用独立控制的问题
其实也反映了抽象的两个方面
一 从用户的角度考虑
驾驶者需要关注的是与
汽车驾驶直接相关的部分
比如油门 刹车 操纵杆和仪表盘
而无需了解蓄电池的
充电原理和控制时机
那么屏蔽这部分无关的细节
就是自然而然的选择
二是从设计者的角度考虑
发动机既可以驱动汽车产生动能
也可以驱动发电机产生电能
抽象出二者共同的特征
统一和简化控制接口
自然就是最合理经济的选择
对用户而言呢
二者的控制就统一为踩下油门
通过对 抽象 思维的学习和研讨
回头我们再看图灵机
你是不是对它有了更为深刻的认识
图灵机是对计算的抽象
它反映了计算的5个最本质的特点
有输入 可输出 明确性 有限性 有效性
对于图灵机是如何反映
上述这些抽象特征的
我们的同事王挺教授
也就是八音盒道具的提供者
给大家撰写了一个详细的解答文档
请各位课后下载阅读
从同学们的研讨发言可以看出
大家来自各行各业
而 抽象 的运用无处不在
有意识地培养和训练这方面的能力
并在工作学习中灵活运用
会给我们的生活带来更多的便利和惊喜
随着课程的不断深入
你是不是慢慢的体会到
计算思维其实并不是那么抽象的概念
你的思维方式正在悄悄地发生变化
下面我们用scratch来编写一个
寻宝挖金子的游戏
这个简单游戏讲的是一条鱼
在大海当中不断的寻宝
它对它寻到的宝物
都还做了计算它记数
我一共找到了多少宝物
我们就把BYOB这个版本的
这个白色的舞台比作大海
这条鱼就是
这个舞台上的一个精灵
这个宝物我们也用
BYOB当作的一个小精灵来了表示
只是这时候这个精灵
它没有生命
它只是呆在这里不动
等待着这条鱼找到或没找到它
这条鱼的运动
是通过键盘控制来进行的
我通过键盘上的上下左右键
来控制来找到这个宝物
一旦这个舞台上
出现了一个新的宝物
看到它在哪个位置之后
我通过控制上下左右键
我就可以找到这个宝物
而我一旦找到这个宝物
我的计数器就发生了变化
计数器原来是0
现在则变成了1
意味着找到了一个宝物
被找到之后又会
出现一个新的宝物在这个舞台上
我继续寻找新的宝物
同样这个寻找的过程
通过用户按上下左右键来进行控制
这样又出现了宝物
我又来找找到之后你可以看到
我找到了宝物不断的在增加
这就是这个
简单游戏的一个运行的过程
下面我们试图对它进行编程
来实现这个简单的游戏
在这个简单游戏当中
包含了很多程序设计
当中一些重要的概念
用来计算这条鱼
一共找到了多少宝物的
这个计数器
这是程序设计当中
非常重要的概念叫做变量
这个变量起到的就是记数的作用
它的最初的值为0
一开始我一个都没有找到
我的初值为0
之后我每找到一个
我每找到一个宝物
这个计数器就增加1
我们来看如何编写
这样的简单游戏
我们先看变量是如何实现的
在BYOB当中有八大类程序指令
这是我们编程的基础
其中一类就叫做变量
变量当中的第一块积木
就是创建一个新的变量
我们在这里创建一个新的变量
这个变量是s
你创建变量的含义
就是每当这个程序运行的时候
在内存空间都会为s分配一个存储单元
这个单元当中记录的
就是它找到的这些宝物的数值
实际上就是一个自然数
我们给这个变量
这个存储单元起个名字叫做s
你可以看到舞台上的变化
舞台的左上角就出现了s这个变量
在这个游戏当中
还出现了两个对象
一个对象是宝物
在大海当中刚才我们
看到的实线中
就是用这个黄色的小精灵
来代表这个宝物
只是这个精灵太大了
我们把它缩小一点
这是改变精灵的
外观选择这个精灵之后
在外表的这一类程序指令当中
有改变大小
我们把它拖到编程区
我们希望把它的大小
改成原来的百分之二十
双击这条指令
也就是双击这块积木意味着
这条指令的执行
你可以看到宝物缩小了
在这个舞台上
另外一个重要的角色
就是这条鱼
对于这条鱼你可以重新创建一个精灵
你可以按自己的方式去画一条鱼
当然我画的不好
也就不用我画的
我们直接在
它的库当中选择一条类似的鱼
这个就是我们
刚才看到的这条鱼
我们选择这条鱼
这条鱼也太大个了
我们也把它的外观缩小一下
缩小为原来的百分之三十
而这条鱼所做的动作
其实很简单它就是通过键盘的
上下左右键要控制
它上下左右的移动
意味着它要能够感知
外部的环境
它要能够感知到键盘的变化
这就要用到感知
这一类指令当中的
这就要用到感知这一类指令
在感知这一类指令当中你
可以看得到可以感觉的到
一些键被拍下了
这里我们所要表达的
不过是当上键
如果我在键盘上
按了上键
我希望它往上走
我要按了右键我希望它往右走
这是一个判断
如果我在键盘上按了向上走的键
我希望你往上走这句话
我们该怎么讲呢
我们在这里有if语句
我们希望判断
怎么看的怎么表达
这个向上的键被按下了呢
我们把这里做一个修改
你可以看到
把这个space这是表示
是不是空格键被按下了
我们现在要考察的是
向上走的键是不是被按下了
选择的是up arow这表示向上的键
这是一个判断条件
我现在判断这句话很清楚了
如果向上的键被按下了
我要做的动作是
我要往上走
现在是精灵的运动
所以我们找的精灵运动的指令
那我们首先要找方向
那么这个方向我们可以通过转90度
但是这里有直接的
改变方向的指令叫做point in
我们在这里先改变它的方向
这个时的方向你可以看到
它标明了0是表示向上
180是表示向下
90表示向右
负90的向左
我们现在是向上
方向改变之后
我已经转对了正确的方向之后
我们前进十步
这是向上走的判断
同样的我们可以完成
向左向右向下走这个
程序指令的编写
我们这里重复这一串指令
如果是向下的话
我的方向也要变成向下
向下走十步
如果我是向右
如果我按下了向右走的键
那么这个方向要变成
向右走走十步
每按一下表示我走十个坐标
前面我们讲了这个坐标系的概念
最后一个是
向左的键按下我要向左走走十步
这是这条鱼
它这些动作实际上
它是始终跟着你的键盘在做的
一旦我按下了
你就要一直走一直走
所以这是一个
这是一个无休止的循环
你就要一直听从我的指令
我们先来看一下
这条鱼是不是这样跟从走的
双击这段
双击这个程序块
表示这个程序块执行
你可以看到现在可以来看
我向右走
每按一下它走十步
向左走每按一下走十步
每按一下走十步
向下也是每按一下走十步
这个时候你可以看到路过
这个宝物的时候它根本没反应
因为你程序里面没有写
程序里没有写你只规定了
我按照键盘的上下左右的
这个移动的过程
你没有讲如何去跟这个宝物打交道
下面我们要考虑跟宝物的
这个程序怎么写
我们回到这个小的精灵
它的动作有两类
一个是它一旦碰到这个大鱼
它就被大鱼找到了
被大鱼找到了意味
这个大鱼就会把
它收入囊中了计数器增加1
首先它要能够判断
我是不是被大鱼找到了
那么这又是一个感知
这里看到
我是不是碰到了这是touching
这是我的第二个精灵
我这两个精灵都有名字的
这个宝贝黄色宝贝
黄色的宝物叫做精灵1
这条鱼叫做精灵2
你可以看到
我可以完成一个if判断
这时候要看if判断
我有没有被这条鱼
这个判断条件就是
我跟精灵2有没有接触
一旦我们俩有了接触
那么我要做一些动作
第一个动作就是
变量的值要发生变化
变量的值发生变化在
变量的这类程序代码当中
这里有change
你可以看到我一旦被鱼找到意味着
它要找到的宝物就增加1了
我们可以看这个指令对s的影响
你可以看到我们每次用1来改变它
实际上是每次都对它增加了一个1
我们再把这个指令
从这里删掉
计数器加1
这是它的第一个动作
第二个动作就是
我这个宝物要消失了
这是外观上的变化在这里
这个时候我们让宝物消失
我把它藏起来
hide起来了
下面的动作就是
我要找到一个新的位置
我要随机的出现在这个舞台上的
另外一个位置
我要去到一个新的位置
我们用go to
到某一个坐标这条指令
我go to到哪里呢
并不是说我
一直都在原点或者某一个位置上出现
而是我要出现在
一个随机的位置
在scratch当中
提供了随机的概念
就是这个函数pick randorm
这个函数放在这里的含义就是
在1和10之间产生一个随机数
它不一定是1或者10 或者4 或是5
随机产生的
可能是1到10之间的任何一个数
而我们这个舞台我们说了
横坐标是负的240到正的240
纵坐标是负的200到正的200
所以我们对于横坐标而言
这个随机数的产生就是
负的240到正的240之间
这就表示我在
负240到正240之间
产生一个随机数
来作为它的横坐标
纵坐标也是同样的概念
也用随机数
只不过这时的范围发生了变化
走到新的位置之后我们希望
我们刚才把这个精灵隐藏了
走到这里你走到新的位置
还是看不见
所以这个时候我们要让
走到了新的位置之后
我们需要它出现
需要它出现
同样的
这个精灵这些动作
实际上它一直都在这做着
什么时候能够
触发我执行这段指令呢
就是这个if
语句的条件被激活
也就是它碰到了这条鱼
它被这条鱼找到了
我这个循环也是一直存在的
我一直在执行
如果你没有碰到
我在来下一次循环
继续看你是不是
有可能碰到我
同样我们说对于小精灵的激活
我们也用这个小绿旗
被点击的时候大精灵
我们看做了这件事没
大精灵也把这段代码写进来
现在我们来看
运行的过程是不是对的
点击小绿旗意味着两个精灵都被
都被开始执行了
一开始执行
相信大家就已经看到了问题所在了
问题在哪里
s的值是9还没开始
怎么就变成9了呢
原因就在于我们刚才在
过程当中做了一些实验
使得这个内存单元
最后的时候它的值是9
那么这个时候程序你要做一个
初始化的动作
我们要给s一个初值
这个值不能是9
所以我们先把程序的执行终止
给试图在执行的一开始
给它一个初值
我们来看一下
在变量当中可看到
第一项有set x to 0
这就是表示
首先给它一个初值
重新完成运行
那么这个时候你可以看
上下左右键
我的小鱼在海里
不断的游曵
我看到这条鱼了
现在要来吃掉这条鱼
可以看到s的计数器发生了变化
同样它又出现在了下方
我们吃掉这个鱼
马上s又会出现在另外一个位置
出现的有点太快了
我们再去修改一下程序
修改一下小精灵的程序
让它不要那么快就出现
让它等待一段时间
在控制当中
有一条等待的指令
这个等待我们说
等待两秒钟你再出现
你不要出现那么快我
这条鱼太辛苦了
我们再来看程序的变化
重新开始运行
你看精灵挡在计数器的后边了
我们吃掉了这个精灵
精灵怎么还不出现两秒钟很长
精灵出现在这里
我们吃掉精灵计数器增加1
这就是我们对这个
简单游戏程序的一个实现
我们刚才编写了一个
非常简单的游戏程序
通过这个游戏程序
希望你能理解进而能够掌握编程当中
最重要的一些基本概念和基本结构
这里面牵涉到了变量的概念
还牵涉到了循环 分支 顺序
这三种程序设计基本结构
大家实际上已经体会的到
用scratch 用BYOB完成程序设计
编程的这个过程
有点自底向上
就是我有一个一个基本的积木块
这些积木块是什么
那几类程序指令当中的
每一条具体的指令
而通过这些指令的组合搭建
最终我可以完成一些程序
这实际上是一种自底向上的方法
Scratch是由美国麻省理工学院
开发出来的免费的程序设计语言环境
我们所知道的程序设计语言也有很多
各式各样的计算环境也有很多
Scratch的特点是
它可以用来创造互动的故事
动画游戏音乐和艺术
直接用鼠标以点选拖曳的方式来进行编程
减少因为不熟悉语法顺序或者指令错误
所产生这种挫折感
实际上它非常适合于程序设计的入门教学
它能够使学生将心思用在
解决问题的本身上
很适合于学习程序设计语言的初学者
我们在这里选择用Scratch
来完成这部分内容的教学
是因为它简单直观
而它的编程主要
是通过积木的组合来完成
通过一些简单游戏的设计
我们希望你在游戏当中学习
下面我们就通过第一个简单的
例子来看一下
用Scratch这样一种计算环境
如何编程 如何制作
一个会唱歌的小精灵
打开我机器上的BYOB版本
在右侧可以看到一个白色的舞台
在Scratch当中我们把它叫做舞台
舞台上有一个黄色的小精灵
你所有的编程实际上
都是为这个精灵来设计工作
就可以把它看成是一个机器人
它能干什么
它想干什么
都需要你程序设计编程来实现
中间的这个灰色的区域就是
你编程的区域
你写程序就在这片灰色的区域上完成
而在最左侧则是
Scratch所提供的一些基本指令
所有的程序指令分成了八类
包括如何
第一大类为Motion运动
如何指挥这个小精灵做一些动作
前进后退
怎样改变它的外表
这是第二大类指令
第三大类指令
是为这个小精灵定义声音
我们一会要打交道的
就是这一部分指令
因为我们希望它能够唱歌
第四大类指令是pen
是一支画笔它可以画出一些图形
而基本的程序控制都在
都在控制指令区域
这个小精灵可以感知外部的环境
它有一些感知的指令设置
另外还有一些基本的操作
基本的运算
如何定义变量
这是它的一共八类指令
每一类指令下面
都有一些基本的指令区域
这些指令区域实现
都是以积木的形式
你在编写指令的时候
我需要哪一块积木
我就把哪一块积木
拖到这个灰色的区域
我们现在希望
这个小精灵能够发声 能够唱歌
选择声音这一类指令
也就是玫瑰红的这些指令
弹奏钢琴上的音符
用的这个程序指令用的Scratch指令
是play note
我们把play note
用鼠标左键
选中playnote之后把它拖到
我们的编程区域
双击这条指令你可以
看到这个指令会使
小精灵发生的怎样的变化
它会发出一个音节
而这对应的就是
我们钢琴琴盘上的C音
也就是Do Re Mi Fa Sol La Si
Do这个音
采用的这个音高是60
而它的节奏是半拍
要重复这条指令
我希望它发出一组声音
一连串的声音最后能唱出歌来
那么是一些音符
我在这里选择复制
这个时候不再是Do了
我希望它发Re的音
这个时候不是发的C的音
我希望它发D的音
62好了
点击鼠标右键
有复制
选择复制我们说我这样可以得到两拍
这个发E的音
最后又回到C的音
那么双击这一组指令
它就应该发出两拍
一共是四个音符
这是鼠标双击
这就是一个程序块
鼠标双击这个程序块
代表这个程序块要开始运行
你可以看到小精灵
按照这组指令所发出的声音
这也是我们一直强调的在
程序设计基本结构当中
最重要的一种结构是顺序结构
而这个序是非常关键的
这是一组非常简单的音节
我们希望它重复做这个动作
选择重复进行
我这有四组音节每节两拍
每个音符发的是半拍
这样我们就得到了一串的音调
讲算法时我们就强调了循环
就是我们编程一般不会把一组
重复弄做这样去写程序
我们的写法是利用循环的
控制结构把它进行一个完成
因为这只是一种动作重复了四遍
我把这组指令删掉
而我选择控制块当中的repeat
这表示着一组循环
我要对谁进行循环呢
我是要对这四个音节
这一个音节
两拍四个音符进行重复的
重复的次数不要是十次
重复了四次
这就是我们在算法的
基本思想里面提到的一种循环结构
循环重复动作
这是程序设计基本思想当中
非常重要的一种结构
现在我们来看它的执行
双击这个程序块实际上
就是运行这个程序块
我们跟刚才一长串的顺序指令一样
得到了一样的演奏效果
这就是一个Scratch的程序
Scratch当中对声音的处理
你可以看到它的指令当中
有打鼓 有各种各样的
在编程的时候
你都可以使用这些指令
下面请大家做一个练习
我们下面再做一个小的程序
这个程序叫做涂鸦的猫
通过这个涂鸦的猫进一步来熟悉
scratch的这个计算环境
在进行编程之前我们先把
这个舞台的大小做一个介绍
精灵活动的区域是它的舞台
精灵在这个舞台上
有它自己的坐标正中间的坐标为
舞台的中心坐标为
为原点（0 0）
这是它的原点
那么四个顶点的坐标
横坐标的范围是从
负的240到正的240
而纵坐标的范围是从
负的180到正的180
由此你可以计算出四个顶点的坐标
这个题是我们希望做一个会涂鸦的猫
希望通过鼠标控制
一只小猫精灵在这个
舞台上随意的涂鸦
由你的鼠标来进行控制
首先我们切换的实际上是这个精灵
我不再需要这个精灵
我希望这个精灵是个猫
当然对于这个精灵你可以
自己新画一个
我可以设计自己的精灵
我可以自己画一个精灵
我们在这里不在去画一个新的精灵
我们从它的库里选择一个精灵
我在这里既然是猫
那我就从这里选择一个猫好了
我们就选择这个cat3
作为这里的精灵
原来的这个精灵我们把它删掉
这个会涂鸦的猫相对于
我这个舞台来讲这个猫有点大
我们把它的外观修改一下
把它的这个样子缩小一下
在外观当中有set指令
我们把这个set指令拖出来
我们希望把这个猫缩小到
原来的百分之二十
双击这个指令
你可以看到这个猫缩小到百分之二十
就这么大了
下面我希望它能够感知
事实上我希望
它能够跟着我的鼠标去随意的画一些
去随意的进行图画
这是我们讲的涂鸦
需要它能够
感知到我的鼠标的变化
程序运行起来鼠标的变化
在这里大家可以看得到的
这个舞台区域的右上角有绿色的小旗子
有一个暂停的符号
还有一个红色的符号
一般来讲绿色的小旗子表示运行
黄色的两竖杠表示暂停
而红色表示停止
我程序的运行我给它设计
一个开始的端口当
这个绿旗子按下的时候
表示程序运行的开始
程序运行我要画图了
我需要带上我这支画笔
需要把这支画笔放下来
对于这支画笔你可以设计颜色
如果你不设置
那就是它原来的缺省颜色
我们简单的写一个
设置它的颜色为蓝色
同样的我们可以
把这支笔的粗细也做一个设置
我们把这支笔大小变成10
这个时候这段代码
这段代码的执行
我可以双击这个程序块
也可以点击这个绿旗子
所以我们说下面你要跟着我的鼠标做动作
这件事该怎么做
这个精灵它要跟着我的鼠标
来完成涂鸦的动作
意味着我的鼠标走到哪儿
你这个精灵跟到哪儿
这时候牵扯到的是精灵的运动
我需要用goto
我的鼠标走到哪儿
你就跟我到哪儿
我要goto到哪儿呢
我不是要走到（10 10）这个坐标的位置
而是要跟着鼠标运动
所以这个时候我们需要感知
我需要感知
鼠标的位置在哪里我就走到哪
纵坐标也是的
横坐标走到的鼠标的横坐标
横坐标走到鼠标所在的
横坐标纵坐标也要走到
鼠标所在的纵坐标
下面再看这个程序运行的变化
双击这个程序块
你可以看到我的鼠标
走到这因为我的鼠标在这
所以它试图往近的方向走
我希望你一直跟着我涂鸦
而不是一下动作就完了
这个时候我们又需要到一个循环了
我希望你的动作
一直跟着我做
永远进行下去用forever
你一直跟着我走好了
现在你可以看到小猫一直跟着我走
什么时候停止呢
点击右上角的红心
现在表示程序停止了
现在问题又来了
就是我的舞台又发生变化了
舞台上小猫的位置不在原点了
而且舞台上画了些乱七八糟的东西
所以很多时候
我们程序运行的时候
不仅仅是在这个例子当中
很多运行程序的实例当中
都有一个动作要进行初始化
所以在这里每次程序
运行的开始
我们加上一些初始化的动作
每一次我首先走到原点让小猫
我这里让它走到原点
我们刚才看了原点的坐标是（0 0）
同时我们希望把这个舞台清干净
把舞台上的画笔
原有的画笔都清掉
用clear把它清干净
然后再完成我们的涂鸦的动作
现在我们再来运行
你可以看到它一直跟着
我再完成这个涂鸦的动作
那么程序停止之后
它就会变成这个形式
这就是我们所编写的
一个小猫跟着你的鼠标不断的
在这个舞台上
进行涂鸦的这样一段程序
前面我们讨论了递归
今天我们以一个特殊的领域
分形为背景来讨论递归的
的应用递归的力量所在
什么是分形我们来看两个例子
仔细观察图形发现他们
是有一些共同点的
左边这个树这部分有一个树根
这棵树的组成上面又有一些
分叉出去的小的树这里看做
一个树这里可以看做是一个树
从这里来看也是一棵树
这棵树的整体可以看到它
一个树根上长出了三个枝杈
而每个枝杈上的子树
与整个树
具有同样的结构右边的子树
一样有一段树根
然后树根上分出了三个枝杈
枝杈上又分别都是
这个子树的一个部分这个子树
的一个部分跟它整个子树本身
是相似的
再看右边的树叶
树叶上有很多小的叶片
中间的每一个叶片单独拿出来
这一部分跟整个的叶片
本身可以看到轮廓形状
整个整体上是相似的这类图形
就是我们说的分形
到底分形的定义是什么
分形通常被定义为一个粗糙
或零碎的几何形状它可以分成
数个部分每个部分
都是整体缩小后
的形状至少跟整体缩小后的
形状相似
这是具有自相似的性质
下面我们看一棵树的例子
自然界有很多类似分形的事物
这些事物包括云彩山脉闪电
海岸线雪片植物跟
多种蔬菜像花菜或者西兰花
动物的毛皮的图案
这样一些分形我们
今天尝试的就是能用
递归方法来进行解决
先看简化过后的这棵树
分析这棵树希望能够理出
用计算机怎样画出这棵树来
或者说用BYOB这个计算环境
怎样画出这样一棵树来
这棵树可以把它分解进行分析
这棵树下面这一部分是个
树根在这个地方有树根
这个树根上面长出来的树是
很有规律的
它分成了两个枝杈
这两个枝杈完全类似
是我们说的自相似的
两棵子树这两棵子树单独拿出来
这一部分的子树
整个大树相比
也是相似的
我们来分析这棵大树的组成
这就是树根
每一棵树上面都分成了两个枝杈
这两个枝杈在最上面一层就是
两个树枝
从这个层次看
对于整个大树而言对于这个树根而言
这两个枝杈是两棵子树
中间每一个枝杈的组成
都是这种思路底下有棵树根
上面分出去两棵子树
相对于前面所讲的递归方法
递归方法的基本思想在于
第一我要找到递归的基础
也就是递归的出口在哪里
递下去归上来递归到什么程度
递归的基础在哪
第二个从归纳法的思想就是有了
如果把这棵树分成按
树枝的层次分成级别就是有了
n级的
树之后
我们如何构造
下一级也就是多一级n加1级的树
如果能找到这两点意味着可以
用递归的方法进行求解
出口相对来说是简单的只要
能画出这段线段
到最终都是画出
线段
所以出口是到最下一层
最后的枝杈这是我的
出口我的级别
按照级别一层一层递下去递到
一定级别我就直接画树枝了
枝杈的长度
每上升一级枝杈的长度
都变的比原来的短
这是编程时要注意的
第二个考虑有了
两级高的树之后如何构建
三级高的树
有了三级高的树怎么构建四级高
的树基本思路的组成要理出来
事实上我们已经理出来了
只要有了一棵子树
这两个子树就可以成为
他的高一级子树的两个枝杈
有了这两个枝杈在加上树根
n加1级的树就构建出来了
下面用BYOB这个计算环境
来编程对这棵树进行一个实现
这个任务是让小精灵画出一棵树
下面要做的就是
设法构建一棵树这棵树
用函数来定义
名字叫一个tree
这棵树呢
一个是给树枝的长度一个初始值
另外刚才提到了1级树2级树
n加1级树
它是构建一个多高的树
我要给它一个参数
用百分号level
来表示树的层次
用百分号size表示这棵树有
两个形式参数
用这种方法我们也可以
定义tree这棵树的两个形式参数
一个是level一个是size
先写好递归的出口如果到达出口
意味着这棵树不需要再画下去
这个出口在级别
等于1的时候认为这棵树
到达了最底部可以直接画
这个小人背着一支笔
继续往下走我们把笔放下来
同时先做一个
初始化包括
清屏
包括让它走到最初画的一个
起始点
我们让它往下一点
y等于负100
给它一个方向
方向是向上生长的树
让它向上画
再回到treeblock的定义
level等于1是试图定义它的递归出口
这个时候我们说已经到出口
意味着画完树枝就可以了
画的长度就是size的大小
这里要注意我们再来看
我们画这棵树的过程
完成过程的时候是这样画的
小精灵从这里出发向上画一段距离
画出了树根
之后画出两棵子树
画两棵子树就不再是正直向上
可能要偏转一定的角度
偏转一定的角度后画左子树
画完左子树后画的
思路是画完后要回到
这个点回到这个点之后
再向
右边画出右子树右子树画完后
一样回到分叉点
所以我们说你出去
出去划过去之后还要回来然后
翻转一定的角度画右子树
这里走过去了还要让它走回来
走回来就是小精灵方向不变
再原路
倒着走回来只是一个方向距离不变
反方向走回来用
求反的运算这里没有求负的动作
用0减去size
表示反方向走回来
这是在level等于1的时候
已经到最后一层我要把枝杈
画出来
剩下的就是如果level没有
到1意味着我要画
一个子树
同样的树是有树根的
把这段先做一个复制
这个树是有树根的先把树根做好
之后是要画这两个子树
这个树根画好之后
画好了向上的过程是从这点出发
从一点出发往上画一个树根
画完树根之后由于不是
最后一级意味着有子树
这个时候往这边转一定的角度
画出上面字数的分叉
然后回来转弯画它的右子树
画完右子树再回来
最终回到原点
所以这画的过程就是
小精灵往上画一段线段
第二段往左上画出左子树的分叉
然后退回来
右子树分叉退回来最终退回起点
我们来编程实现
move size steps意味着画出
向上的树根
下面做一个
左转的动作左转15度
它的左子树
又是一棵tree这棵tree
级别和size都会发生变化
左子树是自相似图形跟整个
树是类似的
只是这个时候level
级别就降级了
本来画了n级树
上面左子树就是n减1级的
哲理level就是要减1
同样的size越往上走越缩小
给它乘一个
一定的比例让它缩小假设画的是
比例是0点75乘以原size
这是左子树还有右子树
右子树意味着
本来方向是正向上
现在往左偏了15度
现在要偏成
以中轴为中心往右偏15度
意味着要向右转30度
同样的
这个时候要画它的
右子树
右子树level减1
size也是原来的四分之三
现在要回到正
对向上的方向的话
还需要
转15度使精灵正直向上
然后退回到原有出发点
就完成了tree block的定义
这是调用自己
在tree中有两个对自身定义的
调用
在主程序中可以生成
一棵树了一步一步来
假设生成一个一级树
长度是50
我们看看这个树这就是生成的
一级树我再看二级树
这里要注意的是每次画完
我都回到了起始位置
来看三级树
来看五级的
同样还可以画出
十级的更复杂的树来
下面改一下函数让它慢点画
让大家能够
进一步体会递归函数在递归时
递下去归上来的过程
每一部移动后加一个wait命令
让大家清楚看到
它是
如何完成画树的动作的
我们不让它画十级复杂的树
我们看它
画三级树的过程
你可以看到
第一步是递下去一层一层
递到根之后
一层层再归上来
我们下面看一个非常著名的分形
这个分形叫做科赫雪花
这个分形就是我们说的科赫雪花
你可以看到本身这很
相似就跟一个六角形的雪花
非常相似中间部分的组成每一个
地方你可以看到都很类似于
我们平常见到的六角形的雪花
也正因为此我们把它叫做
科赫雪花
这个动画给出了科赫雪花
它的变形的过程
它的变化过程是很有规律的
这是一个向下的等腰三角形
这个等腰三角形的三条边
这三条边变化规律就是
对于这样的三角形对于它的边长
按照等分把它三等分
这一部分跟这一部分是不动的
中间的部分把线抠掉
往这个方向以它为边长做一个
等腰三角形
仔细来看
就是这一侧的线段
原来就是一个完整的一条线段
现在我们把它分成四节
下一次的变换是同样的动作
对于任意一节这样的线段
我继续做这样的变化
把它分成三等分
中间这部分以它为边做
等边三角形同时把这部分抠掉
再看一遍动画加深一下理解
可以看到每一次的变化都是把
一条边的中间
抠出等腰三角形的两个边来
下一步也是一样的
就形成了这个科赫雪花
它的变化过程就是
如果我不考虑这是递归出口的话
下面每一层的变换就在于
只要有这样的线段存在
按照你的层次级别的定义
只要级别没有到递归出口
一个线段就变成了1
四节
1234这四节每一节又变成
1撇2撇3撇4撇
继续变同样的2这条线段也是
一样的也要分成1234
三条线段1234
四这条线段分成1234
再往下就是对1撇这一步
这一部分的内容继续把它一分
为4的往下做最终形成一个
看上去逼真的科赫雪花
要做出科赫雪花它是将
正三角形每一边中央的三分之一
的线段
以一对等长的线段取代
形成一个等腰的凸角
再向上一步骤
所形成的每一边做同
样的动作
只要有这样的线段存在
每一次迭代总长度增加3分之一
科赫雪花就是通过
无限次迭代的结果
下面看程序
先看科赫雪花的定义
在科赫雪花的定义中可以看到
递归出口是level等于1
level等于1的时候直接画这条
线就可以了这个画的过程
不需要回头直接往下画就可以
level等于1是递归的出口
其他的还没有画到
一定的层次要求还要继续画
这个变化的过程就是1
变4的过程
每一节都是同样的
雪花回到ppt上可以看出
线段最终变成这个雪花的样子
每一节都还是一个科赫雪花
每一个小的部分都是一个科赫雪
花所以一个变成了4个
科赫雪花的调用这里是
层次减1
同时大小就是你那个
线段的长度变成原有的3分之1
这是我先画平行的
子树
我们来看
这是最初的出口这是
原始的线段
如果还没有到达递归出口
意味着还需要
画下一层次的雪花这一段
到达这里1变成了4段
雪花
第一段的雪花直接画就可以了
第二段雪花就倾斜了我要
逆时针转60度画第二段的科赫
雪花然后顺时针转120度画
第三段的雪花然后我们说
在逆时针转60度也就是
使它这个方向正直对着
右方再来画最后的科赫雪花
我们画出来的是这样一个形状
整个的科赫雪花
还需要完成
一个循环
我们回到这里
科赫雪花实际上画出来的
两朵花实际上是
最终科赫雪花是6个大的
凸角所以这里还需要
循环
三次最终完成雪花的
这才是最终的
雪花
画三级看
这就是三级的科赫雪花
从下面分形的例子可以看到
递归在处理问题的时候
要反复的调用函数
这增大了
它的空间和时间的开销
所以在使用循环
可以很容易的解决问题中
使用递归虽然可以简化
思维过程但是效率上并不合算
效率和开销问题是递归
最大的缺点虽然有这样的缺点
但递归的力量依然是强大
不可忽视的因为有些问题
使用循环结构很难解决
这个时候递归的作用就显示出来
事实上在现实世界的
很多问题当中都有
递归的特点
具有递归特点的问题
用递归方法求解
更加简洁
通过分析问题的递归结构
设计递归算法
来进行问题求解
计算机执行递归程序
是可以自动完成
它可以自动完成递归的调用和返回
这是计算机非常擅长
最后我们用
1965年诺贝尔物理奖
得主RichardFeynman
的这样一段话来结束我们
关于递归这一讲的内容
他说
我想知道为什么
我总是想知道为什么
为什么我想知道为什么
我想知道为什么我想知道为什么
用他这段话
有递归的层次在里面
有递归的这个思想在里面
我们就用这段话结束
递归这部分的内容
我们今天讨论的是
计算思维当中非常
重要的概念递归
递归这件事实际上
你早就接触过
小孩子大都知道
并且复述过著名的
老和尚讲故事
从前有座庙庙里有个老和尚
老和尚给小和尚讲故事
讲的故事是什么
从前有座庙庙里有个老和尚
老和尚给小和尚
讲故事
讲的是个什么故事
从前有座庙
这是一个无休止的进程
进行过程这个过程当中
我们说它有递归
它递下去了
但是没有归上来
下面请我们
把这个例子用C语言
做一个实现
现在把大家都知道
老和尚讲故事的这个过程
用计算环境来做一个
实现让计算机来干这件事
让它来说从前有座庙
庙里有个老和尚
只是这时候我没有用语音
我就是用显示来做的
这是用C语言所写的一个递归函数
这个递归函数叫做tellstory
tellstory当中你可以看到
它就一句话
直接输出
printf指的是一条
输出语句这条输出语句指的是
在显示屏上
显示这样一句话
从前有座庙庙里有个老和尚
老和尚给小和尚讲故事
讲的什么故事
还是这个tellstory
还是这个tellstory
的这个故事所以这是一个
递归函数你可以看到
自己调用自己
同样的问题在重复
同样的问题在重复
我们来看一下这个程序的
运行过程
这是用文本编辑器
编好的这个程序
我们来看它的运行过程
直接运行
你可以看到这个运行过程是
无休止的在进行
问题出在哪
是不是我们一直都在强调的
递归当中不但要有递归
递归当中你不但要递下去
还要归上来
直到最后这个程序
报错了为什么
因为我没有一个递归的出口
在这段函数的定义当中
我把这函数定义打出来
大家看得到
在这段函数的定义当中
没有一个递归的出口
我递下去了
我一直在往下走
我什么时候回来
我不知道什么时候回来
但现在程序回来了
怎么回来的
内存耗尽了你没有资源了
它就把你回来了报错了
这是报错了
你不断的在运行
不断的在使用内存的空间
在这里
直到它报错返回
这就是这个
递归程序最大的问题就是
我递下去了我没有归上来
所以死在这里了
所以没有递归出口的递归程序
是挺可怕的
老和尚讲故事这件事
最关键的就是它没有递归
深度的控制
它不知道从哪出来
我们在执行这段
程序的时候在屏幕上显示出了
有始无终的故事文本
一直都在说这个故事
但什么时候完
当然对于
现有的计算环境而言
它在分配给你你的程序运行
不能侵占
跟很多的内存
像内存的管理上
操作系统有我自己的内存
我在内存当中占据一块
还有其它程序占据一块
直到分配给你的内存
没有了
因为你一直在递归调用
一直它在保存
一层一层下去
一直都没有机会回来
或者释放一些东西
所以最终它报出了错误
这是我们说
这里就是我们讲的有始
无终你要有一个地方
让递归出来
你下去了还得回来
关于递归
我们在这里是通过一些
直观的有趣的例子
帮你建立一些概念
更深入的
理论上的探讨和研究
包括很多各种各样的递归算法
会在数据结构
算法的课程当中
做更深入的讨论
我们在大学计算机基础当中
强调计算思维是希望你能够
打好计算思维当中
一些重要概念的基础
像递归
我们来看递归的定义
递归的英文单词是
Recursion
在数学和计算机科学当中
是指在函数的定义当中使用
函数自身的方法
指的就是函数直接或者
间接的调用自己
它调用自己的时候我们说
规模会有一定的变化
我们要求是这个规模
要逐渐缩小因为最终我是
进行复杂问题的求解
每一步的分解
每一次递下去
我都希望问题规模缩小
所以递归问题可以分解为
两个部分
一个部分就是函数
知道怎么解决
问题的基本实例
就我知道怎么解决
最基本的一些问题
这就是我们讲的递归出口
你要计算n的阶乘
你要知道1的阶乘是多少
对于另一部分它可能
不知道结果是多少
不知道怎么求解
但是我知道怎么
把这问题简化
我不知道怎么计算n的阶乘
但我知道
有了n减1的阶乘之后
怎么去计算n的阶乘
简化的最终结果
我们说你在递归
递下去的过程实际上是
原始问题不断化简
不断变得简单或者
规模小的一个过程
简化的最终结果
是一个基本的实例
而基本的实例
是可以进行求解
下面我们来看两个讨论题
这两个讨论题是
对比了递归和循环我们
在做刚才的例子阶乘的时候
可以用循环做可以用递归做
这两者的能力而言
谁更大谁更小
谁更好写
谁更不好写
递归和循环相比
能力上来讲谁更强大
在书写程序的时候写递归好
还是写循环容易
递归函数的执行
我们说实质上是两步
一个是递下去归上来
我们把它叫做递推下去回归上来
这两个过程
这两个过程都由递归
终止条件来控制
逐层递推
直到递归终止条件
然后逐层回归
递归简洁
但是并不高效
循环的效率要比递归高
递归与循环在功能上是等价的
我再来讲一下
递归的过程
计算机当中是怎么实现
我们来看一下为什么说
递归简洁但是
并不高效
循环效率更高
原因在于循环我
就是一个程序执行下来就可以了
但是在递归的实现过程当中
我说我要计算5的阶乘
5的阶乘这个写递归函数的时候
5的阶乘
我要等于5乘以4的阶乘
这个函数的运行
我计算5的阶乘的这个
函数的运行
实际上运行到这它就停在这了
因为什么它需要
去计算4的阶乘
所以它启动了一个新的
过程去计算4的阶乘
对于4的阶乘它又是按照
阶乘定义从头开始执行
最终它会执行到
我要计算4的阶乘等于什么
等于4乘以
3的阶乘你可以看到
再往下我就不化了
算4的阶乘要算3的阶乘
算3的阶乘我要算
2的阶乘
最终我可以返回到
我们假设就已经回到这个位置
我已经算了4的阶乘是多少
最终我算出来了
4的阶乘等于
四六二十四假设我已经到这了
这个程序
在你算出来4的阶乘的时候
这一段函数的阶乘按我们
函数的调用就是fac4
我们刚才定义的函数fac4
运行就结束
就会返回到这里
你可以看得到
递归进行的过程当中
我在这里转去4的阶乘
我去调用这个函数
去计算4的阶乘
意味着5的阶乘
这个地方我是计算的fac5
我计算fac5的阶乘的时候
这个地方就断掉了
我要保存一个现场
然后转去计算4的阶乘
回来的时候我还要
回到这个现场
继续完成我剩下的计算
如果还有其它语句
为什么说它
效率不如循环高就在这里
我不断的要保存现场
去生成一个新的计算过程
完成更小规模的这个问题的计算
然后我还要回来
回到这个现场
恢复这个现场
最终完成
计算这个层次我们说
递归的深度你可以看到
从这个层次
一层层下去
再一层一层回归
它的计算效率是要
比循环要来的低的
我们刚才写的关于
阶乘的这段递归程序实际上
跟阶乘函数的递归定义是
几乎一样的很对应的上
所以它很好理解也很容易写
多数的情况下
写递归程序求解问题
比写循环
要来的容易
这也是我们喜欢递归的
重要原因之一
递归是一种典型的
抽象我们讲过
函数是抽象
递归函数也是一种抽象
递归本身是
计算思维当中非常重要的
一个概念当然也是我们
这门课当中一个非常
重要的概念
对于递归问题的求解
我相信大家是不是现在可以理出
一些设计递归算法的思路
首先就是要
准确分解问题的递归结构
哪些是当前能够直接处理的
哪些是当前不能直接处理
但是可以归结为
原始问题的较简单的实例
根据问题的递归结构特征
来规划递归的算法
能够直接解决的问题就设计
相应的算法解决之
这就是我们讲的递归的出口
最基本的简单的实例
用递归出口去解决
不能直接解决的通过递归调用
算法本身来解决
综合这两部分的结果就可以得到
问题的解决方法
这是从分析到设计你完成
用计算机来完成这种类型的
递归问题求解的一个基本的过程
递归的强大之处
我们用
图灵奖获得者尼克劳斯沃兹
曾经提过的这样一段话来说明
递归并不是简单的自己调用自己
也不是简单的交互调用
它是一种分析和解决问题的
方法和思想
简单来说递归的思想就是
把问题分解成规模更小的
具有跟原问题有相似解法的问题
分形非常适合于用递归求解
下面做一组练习看第一道题
这一组byob代码定义了一个block
这个block中定义了如何去画
一棵树
它的递归出口在这个位置定义
那么同样的
在这棵树中可以看到递归调用
这都是递归调用
自己调用自己
右侧的代码中这里有个空白
请你在空白处填入合适数值
这个数值要能够使得这段代码
画出中间的这棵树来
这里的正确答案是4
特别要注意递归的出口level
等于0
编程的时候要注意这样一些细节
刚才给的例子中level是1
作为递归出口
再看下面一道题
同样的对于这段代码如果
我把100改成了负100
byob画出的树会有怎样的变化呢
我们可以来试一下
我把它改成负100
层次画4层
我们把起始位置改上一点
还是画出一棵树的形状只是
这个时候树是
向下生长的方向相反
下一问问的是如果将树的层次
从4改到了负4
byob画出的数会有怎样的变化
你得先思考一下这个问题
我们在byob中来看
我还是把它改成正50
起点依然是
负100这棵树向上画
这个时候把层次从正4改到负4
这个树最终变成什么样子
程序的运行看它有什么变化
相信大家已经看出来
这个树
递下去归上来这是这棵树
是递归定义总是要按照递归函数
这个过程来执行它递下去的过程
是不是一直没有到底
一直在往下递
这个程序是死循环了
死在这里一直往下走
递下去没有回来原因在哪里
再来回过头来考虑
来考察tree的代码
我们这段代码中递归的出口是
什么就是什么时候递归的过程
结束了就是走到
if条件判断的这一部分
这就算是我
递归要出来了结束
而这里
递归递下去过程结束的条件是
level等于1
而我的level初值是负4
每次递归调用都做了一个简易
动作负4变成负5负5变成负6
负6变成负7意味着
我永远都到达不了level
等于1的条件永远都没有办法
去满足这个条件
所以造成这段
程序的运行是个死循环
这就是递归的过程和出口
没有把握好
这一单元我们讨论
典型问题求解的递归法
我们先通过一些简单的例子
把递归问题的求解
求解过程求解步骤
它包含哪些要素
进行一个介绍
我们先来看阶乘的计算
阶乘的定义是
大家在数学里都学过的非常
简单的一个概念
你说求解阶乘
我有很多种方法
我可以用循环做
但是在这里我们考虑的是
递归的方法
我怎么把这个大问题
分成小问题来进行求解
我们来看一下关于阶乘的定义
对于一个正整数
n的阶乘的计算
从公式来想这个是
应该等于1
乘以
一直乘到哪里一直乘到
1乘以n减1
最终在乘以一个n
这是我计算n的阶乘
我们来考虑这个定义
当然这个定义真正到程序
设计的时候
我可以用循环来实现写一个循环
我就可以解
我就可以求解出n的阶乘是多少
但是我们在这里试图运用
递归的方法
去考虑阶乘的概念
看能不能用递归的方法来
进行求解
我们用这个简单的例子是
为了说明关于递归
在递归问题求解当中的
一些基础的概念
我这里要计算5的阶乘
5的阶乘就应该是
1乘以2
乘以3
乘以4
乘以5
最终我可以算出5的阶乘是多少
且循环可以实现
我下面考虑另外一种思路
就是我们在这里讲的分治法
或者归根到底就是递归问题
求解的思路应该是怎么样的
我希望把这个问题分解
分解之后依然还是计算
阶乘问题只不过是
规模变的更小了
5的阶乘我们可以看到什么
从这里看得出
前面1乘以2
乘以3乘以4这是什么
这是计算4的阶乘
所以5的阶乘我可以通过
计算什么得到
计算4的阶乘
我就可以算出5的阶乘
同样是阶乘的问题
但是4的阶乘
比5的阶乘规模要小
回到我们这个我要
计算n的阶乘
我在这里要计算的是n的阶乘
n的阶乘我不知道是多少
但是我知道怎么样得到n的阶乘
n的阶乘要怎么样得到
我把它
分解成规模更小的
也就是前面这一部分
规模的更小的是计算
n减1的阶乘
最终在乘以n
这样就得到了
n的阶乘
下面你就再来看
我在这里要计算的是
5的阶乘我们就以
5的阶乘为例
来讨论
我最终要计算5的阶乘
我不想写那个循环
我来看看用递归的方法
怎么样去求解
第一步你得到的是
我要计算5的阶乘
想办法知道5乘以
4的阶乘是多少
在这里你可以看得到的是
我原本的问题是要
计算5的阶乘我现在
需要知道4的阶乘
这个问题转化
它变成了一个子问题
这个大问题我就只分解成
一个子问题
这个子问题当中依然
是计算阶乘但是规模变小了
只要计算4的阶乘就可以了
4的阶乘我还是不知道是多少
这个问题还要继续进行
分解再把它变得规模
更小一点
分解
4的阶乘等于什么
4的阶乘等于4乘以
3的阶乘
3的阶乘是多少我还不知道
我一步一步又往下走
3的阶乘等于3乘以
2的阶乘
递下去2的阶乘我依然
不知道我们说这个问题
分解到什么时候结束
要到这个问题我一看
就知道它结果是多少简单到
你可以直接进行问题求解了
这件事就可以
不再继续分解了
到这里了
1的阶乘出来
我知道的是什么
我知道1的阶乘等于1
所以你可以看到这是我们
递下去的过程
这递归两个字分开来看
递我是往下递
我5的阶乘转换成
转化为求4的阶乘的问题
3的阶乘的问题
2的阶乘的问题
1的阶乘的问题
但是这个递下去的过程
不能是无休止的
要有一个递归的基础
这就是我们讲的递归的
基础你递下去
要有一个点能够停止
然后在归上来
我知道1的阶乘是多少
我可以求出
1的阶乘了
这个时候我们说
递下去下面不能说
递下去这件事这件事没完
还要考虑第二个字我要归上来
这样归上来
第一步我就可以求出
2的阶乘是
多少
有了2的阶乘
我又可以一层一层的
往上归这个就跟
盗梦空间那个做梦是一样的
我一层一层下来
我在一层一层回去
我不能跳着回去
我从哪下来的
从哪回去
有了2的阶乘我们可以
算出3的阶乘
有了3的阶乘我能够
计算出4的
阶乘
对于这一层次
我要计算的是4的阶乘
实际上它是两个运算
一个是我要把3的阶乘
算出来另外一个运算就是我要
完成这个乘法
这里我首先算的是3的阶乘
完成这个计算之后做乘法
这样我就得到了4的阶乘
继续往回返
直到最终你的问题
得到了一个
解我计算出5的阶乘是120
这是我们把递归的过程
做一个仔细的分析
我们希望通过这个
分析能够让你
体会的到递归过程当中的一些
关键的基础
基础概念这过程该怎么做
所以由此我们可以总结出
关于阶乘计算的
递归定义
这就是阶乘计算的递归定义
对于这种递归定义方法
它为什么能够最终求出问题的解
我们数学归纳法当中是可以找到
理论上的支持
数学归纳法可以证明一个自然数
n的命题P(n)
证明当n取第一个值
n0的时候命题成立
n0对于一般
数列取值为0
或者1
这句话实际上
定义的就是我们
递归的一个基础
就是你递下去的时候
我到哪打止
这是你递归的基础
你必须要有这个基础
这个基础真正在程序设计的时候
我们把它叫做出口
因为你到这
你开始一层一层往回回来了
一层一层出来了
前面是你一层一层进去
第二句话说的就是
当假设当n
等于k时候
命题成立
证明当n
等于k加1时命题也成立
也就是你有了递归基础以后
我还有一个递进的步骤
n等于k的时候
n等于k命题成立
一定会有n等于k加1命题成立
就像我们刚才这个题所说的
我首先有一个基础
我知道1的阶乘等于1
下面我要做的就是
我要计算我要
计算n的阶乘
只要我知道n减1的阶乘
我一定知道
n的阶乘如何计算
这是一个递进的
关系建立
这样也就可以证明
对一切自然数n
这个命题P(n)
是都成立的
这是递归的一个数学的基础
我们下面来看一下
我不用阶乘的递归定义
我同样是可以把阶乘算出来
请大家考虑一下
我怎么样来写计算这个
阶乘的程序
我写的这个程序
希望能够计算
5的阶乘10的阶乘
能够计算任意
一个正整数的阶乘
所以这个我要计算几的
阶乘这个我
希望是用键盘录入
由用户来决定的
所以在程序的一开始
我们先写了一个输入的语句
你先从键盘请你从键盘
录入你要计算几的阶乘
下面就是要考虑
有了这个n之后
我怎么样来算这个阶乘
我能不能就把阶乘
公式的那个最简单的定义
把它搬过来
我们来看这个最简单的定义
这个定义我是不是就可以直接搬过来用
我能不能把这个公式就写在
我的程序当中
我们说实际上
你这个很难去写
因为这个整个的一个
一般化的这个公式是一个
做了很多乘法的公式
但是乘法的这个操作数
我们说这个不一定
不一定因为它
它取决于用户的输入
你可以来试着写一下
你说我在这中间
把这些语句先
搬到一边去
我来试着写一下
我最终要算一大堆乘法
把它算出来
我希望这里
这个是1
这个是
还没完
这是乘法
我们还得一层一层写
这也是乘
这就变成了
1乘以1乘以一直乘
我能不能把它写在1乘以
一直乘以到n
我们说这件事
没法写为什么说没法写
因为你不知道
n用户最终输入的是多大
你不知道中间你
需要多少个
其它的自然数就是
1到n之间有多少个自然数
我没办法确定
所以在程序里
这件事我用一个公式把它写出来
是没有办法做的
但是我们除了递归
我们是不是还有循环
在我们用递归方法求解之前
我们先来看看这个循环该怎么写
循环这件事我是不是能做
把这个删掉
循环计算的阶乘的这个结果
我们把它放到result这个变量当中
对于result这个变量
我给它个初值1
这有点像递归定义
里面的递归的出口
1的阶乘为1下面
这个result最终有多大
就取决于这个n有多大
这个result
应该等于什么
我们这里就可以写乘法
它应该等于什么
等于result
原有的result的值
再乘以循环控制变量的值
我们来看一下这个
计算的思路
写循环的时候我这件事
是怎么做的
计算我在result当中
首先记录的是1
然后循环我希望每次
乘以一个数
我希望怎么写
result
最终这个结果是等于
等于原有的它的值
在乘以一个新的
循环控制变量的值
而这个循环控制变量
i是从多少可以从2
一直到n发生变化
这是我们写的循环当中的一条语句
你可以来看
最初result的值是
1我们可以来看一下它的
运转的过程
i的值最初为2
所以第一个运算这个时候读出
result值是1
而i的值当前为2
所以这个时候算的是什么前两项
算的是1乘以2的结果
这个时候result值
算出来为2写回到
result这个变量
这个位置的值就为2了
循环的这条语句
执行完了之后意味着我还要回来
它重复执行这句话
只是这个时候i不再等于2了
而是i等于3
那也就是原有的1乘以2
现在的result当中进入的是原有的
1乘以2的数值2
在乘以3
实际上这是计算的
3的阶乘就经过i
等于3之后我算出来的是什么
是3的阶乘
3乘以2这里就写入了
新的数值为6
在中间你可以看得到
我通过这样一种手段
我每次乘一个自然数
每次乘一个自然数
这个自然数是怎么变化的
从1到n发生变化
知道乘到n了那就意味着
我从1乘到n的这个过程就结束了
所以我怎么乘
我先算出1乘以2的结果
我再算出1乘以2乘以3的结果
这就是一次循环一次循环
每次都把乘的这个结果乘积
跟一个新的自然数相乘
这样我就算出了
n的阶乘是多少
这里我们说有一个
循环控制变量
在程序当中我们可以定义
一个变量i
i同样需要一个
初值i的初值
我们就可以把它设成2
这个循环次数我们就不在用n来
表示了
我们的循环次数
应该是每次i的数值
它会发生变化
它应该到
我这里用repeat
用repeat的
条件控制好了
repeat until
不用这个语句
repeat until什么时候
i的数值每次增加1
直到这个i等于n
判断相等
这是逻辑运算符
逻辑运算符判断相等
判断谁和谁相等
两个变量
因为i的数值一直增加
增加到哪为止
增加到n为止
到这里
这个时候是乘以i
每一次都做一个新的相乘
还有一个很关键的动作就是
每一次循环之后
这个i的数值要增加1
我们就可以计算出
n的阶乘我们
来运行一下
我希望计算5的阶乘
把5输入之后
大家可以从
运行的舞台的
左上角可以看得到
n等于5了i等于5了
但是我的result是24
这个问题出在哪
我们知道5的阶乘是120
这里为什么是24
这个问题
出在这个循环控制条件这里
我这个循环什么时候结束
循环到i等于5
结束了结束了意味着
这条语句就没有被执行里面
在i为5的时候我是不是
没做这个乘法
所以它的最后的结果是24
所以这个循环控制条件这里
应该怎么修改一下
直到i大于n
我们把这个删掉
把它删除
重新用大于的这个
循环控制条件
直到i大于n
再来运行看
我依然计算5的阶乘
这个时候你可以看到
result结果是120
结果是正确的
不知道大家有没有看过一部电影
叫做盗梦空间
在盗梦空间这部电影当中
主人公是在他的梦境当中
去完成一些困难的任务
这个梦境还是有层次的
在他做梦的过程当中
有可能又梦到自己还在做梦
所以这个梦境是有层次的
而当他做梦进行到
一定的层次的时候
这个梦做完了
这个梦还要返回
返回也是有着一定的规律
它是一层
一层的返回的
这部电影的这种过程实际上就
包含了递归的思想
递归是典型问题
求解的一种方法
在计算机科学当中
在函数当中在数学当中
我们都看得到
归根到底它的典型问题的
求解策略是分治法
分治法采取的是
分而治之的思想
把一个复杂的问题
分成两个或者更多的相同
或者相似的子问题
只是这个子问题的问题规模
比原有的大问题要小一些
如果这个子问题我依然
不能立刻看出如何去求解
还可以继续把子问题
分成更小的子问题
你可以看到他这里
也是一种层次的划分
我一层一层的往下走
直到最后子问题可以
进行简单的直接求解
一看这个小问题
我就知道该怎么样去求解了
你这个问题分解
就可以不再进行了
原问题的解最终
可以通过子问题的求解
最终来得到整个问题的解
所以你可以看到这个
求解问题的过程
从大问题到子问题
再到更小的子问题
这个问题求解完之后
有一个返回到
子问题的过程
而返回到这个子问题的一个解
就取决于
这两个更小的子问题
如何来进行求解
它们的解该如何组合
所以这里你可以看到
为什么我说它跟
盗梦空间当中的梦境很相似
我在做梦的时候
我也是一层一层进入我的梦境
最底层的梦做完了之后
我又回到上一层的梦境
这个梦我醒了
我继续着我刚才从
哪个梦继续往下走
分治法是很多
我们讲到的这种把问题
分解一个子问题一个子问题
逐层下去再逐层返回
最终构成整个问题求解
能够得到的大问题的解的过程
这种方法
是很多高效算法的基础
一个原始的问题
可能现实世界当中问题
才是非常复杂的
一下子我不知道如何去求解
我可以把它
分成几个子问题
这张图当中它是
分成了两个子问题
如果这个子问题我依然看不出来
如何去求解
下面要做的就是把这个大
的子问题化成更小的子问题
这种分解的过程
把大的问题分成小的
子问题的这种过程
在人的问题求解过程当中
经常会碰到
我们经常会碰到一个复杂的问题
我们该怎么办
我们把它进行分解
最终你说
返回的这个过程
如果这个小的子问题我已经
可以求得这个解
我就可以把这个
小的子问题求得解之后
返回到上一层的这个问题
然后在看到还有没有其它的
子问题
如果还有其它的
更小的子问题
最终我可以凑成这个
这一部分子问题的一个解出来
这有点像什么就像我们刚才讲
盗梦空间的
那个梦境的返回过程
我这个小问题
求解完了之后它回到哪
构成了哪个子问题的一部分
这种层次结构
跟盗梦空间的这个梦境
一层一层下去再一层一层返回
它是有一些类似的
在盗梦空间当中
有一种典型的场景
觉得这个主人公
他开始进入某种梦境
也就是开始做梦
主人公我就把它用A表示
他完成任务最终
完成任务的过程是要
进入某种梦境我要开始做梦
他进入这个梦境之后
你做梦是一个过程
我可能梦见一件事两件事等等
多种多样件事
而在他中间的某一时刻
我做梦梦到了什么
梦到了我在做梦
我在梦境当中我又
开始做梦了
从这分开我又开始做梦了
这个梦境进入这个梦之后
一样的他是做梦的也是一个过程
一点一点的
在这个做梦进行的过程当中
很可能在某一时刻
做一个新的梦
这个梦你可以看到它一层一层的
走下去这个梦
可能没有在梦到做梦的这件事
我从头做到尾这个梦做完了
醒了醒了回到哪里
回到了刚才做梦的这个层次
我从哪儿进来的
我又回到了哪个位置
虽然这些都是我的梦
我们把它叫做梦1
在做梦1的时候
我又进入了第二个梦的梦境
我们进入了第二个梦的梦境之后
在第二梦境的梦境了我又做梦了
我进入了梦境3
只有梦境3我可能扎扎实实的
做完了梦醒了
醒了回到哪呢
回到又回到了
梦境2当中
这中间就有一些
递归的思想在里面
这种一层一层下去又一层一层回来
有点像递下去归上来
这就是我们讲的
递归的一个含义
所以从我们通过分解问题
通过分治法来进行问题
求解都可以看得到
刚才我们讲到的
梦境1梦境2梦境3
实际上我做梦的这三个过程
都是类似的
对于我们刚才提到的复杂问题
求解通过分治法
通过分解问题
可以看到问题的解决又
依赖于类似问题的解决
只不过后者的复杂程度
或者规模较原来的问题
要来的更小一点
一旦将问题的
复杂程度和规模化
减小到足够小的时候
问题的解法
是据我这个问题分解
进行到什么为止
进行到
我可以把它分解到
足够小我一看就知道问题的解是什么
就可以了
这个问题分解就可以
停在这一步当中
这样的一种问题
求解的方法
作为一种递归
实质上是一种特殊的
分治的方法它也是分而治之
递归的这个英文单词
叫做Recursion
递归是计算机科学是
计算思维当中的一个
非常重要的概念
下面我们就来考虑
怎么用
递归我们刚才的递归定义
来完成
阶乘的计算
我们在生成一个Sprite
对我们用这个Sprite来完成
用递归方法来进行求解
这个时候我需要
这个时候我们想一开始的
过程是一样的我们还是从这开始
同样的要求用户从
键盘来录入
你要几的阶乘
what's the number
同样的
我们还用这个n
n等于什么
n等于
answer
从键盘录入的
这些数据信息
都记录在answer
这个数据当中
n的数值是什么我拿到了n
就是我要算计算几的阶乘
我把这个
把answer赋给n
下面的动作就是要
考虑我怎么以
递归的方式
来完成这个计算
我刚才定义了这个结果
是记录在result当中
下面我希望
定义一个Block
这个Block完成计算
阶乘的动作
我要计算出这个阶乘
这个阶乘应该是一个Block
我希望以递归的公式来
求解阶乘问题
我们需要写一个Block
定义一个递归的函数
这个递归函数的名字我们就
用Factorial用Factorial
阶乘这个英文单词的前三个字符
fac
这个时候你可以看得到
我在sprite当中建立Block
说明它是一段独立的
代码是一个抽象函数的定义
这个函数定义可以是
没有返回值的
而我这里是
需要有返回值的
所以这个时候我要选择
第二类reporter
ok
下面我就开始来计算
这个阶乘
我计算阶乘这里是
有一个参数的
我把它抽象出来我计算的
计算的n的阶乘
这个n有办法要录入
对吧
我用number来表示
这是个形式参数
而这个参数
它的数据类型
则是一个
数值
它是一个数
选择number
有了这个数之后我就
可以计算
阶乘我要计算它的阶乘
按照我们刚才递归定义
我们来考虑
我要计算n减1的阶乘
和n的阶乘
大家这个时候要特别注意
我这个出口该怎么写
所以这个对于这个
函数的书写
实际上一上来
就是一个if
语句
这个时候我有个否则
number是多少
用户输入可能是1可能是100
可能是其它的数
这里有一种情况就是它
等于1的时候
这个时候就是我们的
递归出口
如果number等于的是
1这个数值
这个时候你就可以
报告一个结果
大家看到这里report在
ctrl这一类控制指令当中
在这个模块当中
我还需要一个变量
来记录最终的
这个计算结果
我在这里
在定义一个变量
这个变量来
记录最终的计算结果
从这里可以看得到
数字为1的时候
1的阶乘就等于1
最终的计算结果就是1
而我要计算
如果这个数值大于1
走到这条语句就
意味着这个数值肯定是大于1的
这个时候我们说把这个问题
的规模缩小
这个阶乘这个数值
应该是等于什么
这个数应该等于什么
应该等于number这个数
这就是我们的递归
它应该等于什么
它应该等于number乘以
本身这个
函数的调用
我计算谁的阶乘
计算number减
1的阶乘
我要拖过来
所以你看这个式子它算的
它是什么它是用number
乘以
n number减1的阶乘
这就是我们关于
阶乘概念的递归定义
这样我就可以
计算出number的阶乘
这里
通过这样一个式子我就
用fac的用
fac这个变量
记录了最终的结果
然后我们说这个函数是需要有
返回值的
返回值用report
用report
report的是什么
report
report谁把fac的值
返回因为fac当中
Factorial当中记录了
最终的这个数值
计算阶乘的一个
结果ok
我把这个关于阶乘的定义
写完了所以这个地方应该是什么
应该就是调用这个递归的函数
来计算n的阶乘
计算n的阶乘
计算完了你说看不见结果我们
用输出语句
用say语句把它做一个输出
这个语句当中
我用一些字符串
连接的
定义
我用一些字符串连接我希望
完整的说出一句话
我希望输出是
n比方说我要求你
计算5的阶乘我希望你
能够说出来5的阶乘等于120
所以这个时候我们需要
一些关于字符串的
操作的
运算符这个运算符就是join
我用join
所以说什么我这里希望你
能够
说出来
n的
阶乘
阶乘就是冒号
阶乘的符号是感叹号等号n
n的阶乘等于
这句话里面
我现在希望关于
这段程序它的
输出的结果是
5的阶乘
等于
我希望这个精灵学这样
一句话
5是由用户输入的
而这段内容是固定的
这是一串字符串
这是我们刚才计算出来的结果
实际上是三部分的字符串
绑在一块这是我所要的
输出结果
三个字符串绑在一块我
需要两个join操作
这个地方还不能直接写
感叹号等于号
我还需要一个
我还需要第二个join操作
在操作运算符当中
第二个join
第二个join当中
我才能写上感叹号等于号
最终的这个结果
是result
现在我们来看
这个精灵的运行
我要计算5的阶乘
你可以看到它说出来这句话了
5的阶乘等于
这就是我们讲的递归的基本概念
它基本的运行的一种思路
通过这道题我们再把关于
递归的定义
递归过程当中你必须要注意的
再来做一个总结
递归在BYOB当中
在很多的程序设计
语言当中很多的计算
环境当中都是用
递归函数去实现的
在这里在BYOB当中
我们定义了这样的一个
递归的函数
这个递归的函数叫做Factorial
这里在递归函数当中
两个步骤是非常清晰的
第一个步骤就是在
n等于1的时候
在我计算n的阶乘
在n等于1的时候
最后的运算结果就是1
也就是这个函数值1的
阶乘的计算
就等于1这是什么
这是对递归出口递归基础的定义
这句话是非常重要的
当然每一个步骤这两步实际上
都是缺一不可的
第二步就是我们本身
递归函数的一个递归的定义
第二步就是
这个函数本身的一个递归的定义
这就是我们用递归
递归的方法
来进行问题求解的一个
基本的思路
下面我们在回顾一下啊
这段程序以及它的运行过程
把这个递归的过程在进行一个
总结
所以递归的基本过程基本定义
在加深一个理解
在很多的程序设计语言环境当中
这类问题求解都是
这种使用递归的问题求解
都是通过递归函数来实现的
在BYOB当中
我们也是通过递归函数
最终完成的这个事
我们在这里定义的这个
递归函数就是这个Factorial n
这是一个非常典型的
递归函数的定义
为什么我说它典型
它就是跟你的递归的定义
跟我们在这里完成的阶乘
函数的这个递归定义
有很强的对应关系
我们这个递归定义实际上说的是
就说的就是我这个
在递归函数里所定义的这个
if语句
这个递归定义实际上说的就是
n等于1的时候n的阶乘等于
n大于1的时候
n的阶乘等于n乘以
n减1的阶乘
我们来对应
这句话n的阶乘等于1
我们把它叫做递归出口
或者是递归的基础
体现在这个递归函数当中
我们在这可以看到这是
递归的出口
是递归的基础
这句话非常关键
少了这句话这个递归
过程就无休止
就没个头了
这是第一个if语句的一个条件
第二个if语句我们没有写条件
其它的情况之下
我们都完成这样一个计算
这个计算你可以对应这个公式
这个fac这句话说的是什么
fac等于n乘以
facn减1
我的递归函数叫什么
叫F这里是叫
Factorial我这个就
用刚才演示当中这个缩写
简写了的这个单词
这个是什么这就是我用来
计算阶乘的
所以我们为什么说这个函数
定义很典型就是它的递归
定义递归定义出来了
递归函数我也就会写了
最终我们
这是一个有返回值的
我要把n的阶乘计算出来
然后告诉给你
所以我用了一个report
把这个最终的计算结果输出
我们再来看主程序当中的
调用关系
用户输入用户
完成了我要计算
几的阶乘的这个定义
记在answer当中
这里写的是这里我们
讲了一个新的语句就是
输出和join的一个组合
我希望你
输出的是什么
5的阶乘等于120
这是一串字符串我怎么组合
我先输出了5
又写了一个
感叹号等号这个字符
最终写了结果120
这就是最终的一个写的结果
用say语句把它做一个
输出用join把三个字符
连接在一起
我们希望的是
计算工具的机械化 计算过程的自动化
那么什么是计算的自动化
我们如何来自动地完成计算
在你完成自动计算的时候
首先我们需要一个
逐步进行的计算步骤
我们来考虑厨师做菜的过程
假设我现在想设计一个机器人
来自动地完成做菜的这个过程
我们需要什么
那么厨师要完成一道菜的烹调
首先我需要一个菜谱
我要知道如何去做这道菜
第一步做什么 第二步做什么
怎么蒸 蒸多久 怎么炒 炒多久
这是我的
菜谱所决定的
那么第二个
我需要的就是我要按照这个菜谱
准备好了材料之后
逐步地去实施这个菜谱
到最后炒出一道菜来
前面我们以厨师做菜为例
描述了在计算过程的自动化过程当中
计算步骤
也就是后面我们将要学习的
算法的重要性
算法是计算过程自动化的灵魂
最后我们用尼葛洛庞帝在他的
数字化生存一书当中的话来结束
今天的课程
计算不在只和计算机相关
它决定了我们的生存
一六七三年德国的莱布尼兹
改进了帕斯卡的设计 增加了乘除运算
计算装置几乎每一步运算
都需要人工的干预
操作数由操作者来提供
计算结果也要由操作者重新进行安排
那么 这些发明在灵巧性上
都有很多的进步
但是无一例外 它最终都没有突破
手工操作的局限
但是直到
十九世纪二十年代英国的
数学家查尔斯巴贝奇才取得了突破
使得
从手动机械越入机械自动的时代
巴贝奇提出了自动计算的
一些基本概念
就是要使
一个计算机器一个计算装置
要能够完成自动计算
我们不仅需要有手段能够记录
参加运算的操作数
也必须要有手段
能够存放计算步骤和运算规则
并且使得这样的计算机器
要能够取出这样的数据
在必要时能够进行一些简单的判断
决定自己下一步的计算顺序
查尔斯巴贝奇于一八二二年
完成了第一台差分机
在一八三四年设计了分析机
在他的分析机当中
提出了一些创造性的建议
从而奠定了
现代数字计算机的基础
巴贝奇的思想是非常超前的
当时的科技水平和机械工艺技术
达不到分析机制造的要求
使得这部以齿轮
为原件以蒸汽为动力的分析机
一直都没有完成
巴贝奇的分析机设计非常复杂
我们下边通过两个相对来说简单的例子
来试图去理解巴贝奇的
分析机的设计思想
一八零一年
法国人杰卡尔
发明了提花织布机
提花织布机利用
打孔卡片来控制
织花的图样
这部提花织布机在工作的时候
无需变更
任何机械的设计
那么不同的卡片只要输入的
给它的这个打孔卡片的不同
那么它织出的就是
不同花色的图案
这就是杰卡尔的提花织布机
可以看得到中间这些都是打孔的纸片
这些纸片上
有各种各样的孔
这些孔决定了这些织布机的织布针
该如何工作
从而可以织出不同的图案来
对于杰卡尔的提花织布机
你觉得它的设计上
哪些地方最有趣呢
计算机已经成为人类生活中
重要的一部分
融入到人类社会的方方面面
并且依旧在迅速改变着世界
影响和颠覆着我们的观念和习惯
计算机科学的发展
对社会产生巨大影响
我们不仅在越来越多的
利用计算机做事情
也在越来越多的使用着
计算机科学里的一些描述问题
解决问题的方法
大学计算机基础课程
将以计算思维为导向
通过深入理解计算机系统
分析自动计算的力量所在
计算的本质及局限性
初步建立利用计算机
进行问题求解的基本思路和方法
欢迎学习大学计算机基础课程
下面我们进入
计算装置与计算机单元
第一讲 计算的机械化与自动化
劳动创造了工具 而工具又扩大了
人类探索自然界的功能
人类一直
希望创造一些工具
能够替代人类进行体力劳动
同样也希望能够制造出一些工具
来替代人类的脑力劳动
就科学计算而言
我们希望有自动的机械的装置
来完成复杂的科学计算
所以从一开始就要思考这样一些问题
到底什么是计算
人又是怎样完成计算的
我如何能够制造出一些机器来
帮助人类完成科学计算
这一讲我们讨论计算工具的演化过程
开始讨论是什么
成就了今日的计算力量
我们来做一个简单的加法运算
二十八
加上三十五
我先写下的是
要完成运算的操作数
有两个数值我希望完成加法的运算
按照列竖式的计算规则
五加八等于一十三
进位之后得到结果六十三
那么回顾你所完成这个
科学运算的过程
这个加法运算的过程
那么首先我们需要
有手段能够记录下参加运算的数
而完成运算的过程我还需要很多
加法的运算规则
加法的运算规则
有了这样一些规则之后
把这个规则应用在
我的数上面
我要参加加法运算的两个数上面
那么最终我得到了我所需要的
加法运算的结果
那么我们下面来看
我希望有机器
能够完成
哪怕像我们刚才所演示的
这个简单的科学计算
我们来看在算盘上我是如何
完成二十八加三十五这个动作的
那么算盘上我们先记录下这样两个数值
一个是二十八一个是三十五
我们从二十八开始
要完成加三十五的这样一个动作
我需要有我
珠算的这个加法口诀
按照加法口诀当中
加五的这个动作应该
是五去五上一
所以十位上的数值变成了三
再往下我要加的是三十五
那么在十位上就应该是三加三
三加三的话应该是
按照珠算的加法口诀
应该是三下五去二
得到的结果是
六
这样我们就加出了
二十八加三十五等于六十三
那么在这个过程当中
我们需要有手段来
记录下我要参加运算的数
也要 知道
这个计算过程是由人来完成的
算盘只起到了记录数的这样一个作用
整个的运算过程运算规则
以及把这些运算规则
应用到数上 最终计算出
计算结果的这个过程
是由人来完成的
所以说算盘是手动地
辅助人类完成运算的一个工具
关于算盘的描述 我们看算盘上
可以记录数值数据这是对的
算盘的运算是基于十进制的
实际上算盘的运算
不仅仅是基于十进制的 我国早期
有很多算盘是
基于十六进制的
那么算盘只能完成加法和减法运算
这种说法是不对的
那么
对于一个算盘而言
如果我用的是加法口诀
那么我完成的是加法运算
同样的我还有乘法和除法的口诀
像我们小时候背过的九九乘法表
同样可以作为珠算乘法运算的口诀
只是相比算盘的加减运算而言
乘除运算的速度要慢很多
单对算盘的运算速度而言
加减运算的速度比较快
做乘法和除法的运算速度是比较慢的
算盘是手动的计算工具
人们希望有
能够完成自动的
运算的机械装置
在一六四二年
法国数学家帕斯卡创造了第一台
能够完成加减运算的机械运算器
用来计算税收
取得了很大的成功
帕斯卡的加法器
归根到底它是基于十进制的
他用 五个齿轮
来表示五位数的
十进制数字
那么 每一个齿轮
都从零到九分成了十等
那么 现在动画里演示的
就是我怎么样把二十八这个数值
输入到这个加法器当中
在完成加法运算   加三十五的
动作的时候
那么 我的
加法器的操作是在
十位的数值上拨下三
在个位的数值上拨下五
这就完成了加三十五的
运算 运算结果显示在
上面的这个小方框中
那么这种计算 你可以看到
它是一个自动的计算过程
加法运算我所做的只是输入两个数
一个二十八一个三十五
真正加法的这个动作
是由帕斯卡加法器自动完成的
那么它是如何
来完成这样一个加法的运算的呢
此处无教师声音
杰卡尔的提花织布机
有可编程的思想在里面
通过在打孔卡片上
设计不同的穿孔
那么 可以提供
丰富多变的提花的图案
提花织布机可以
解读这个打孔卡片
根据打孔卡片上的卡
可以决定它的机械动作
而这个解读过程也
类似于现代计算机的解码思想
提花织布机根据打孔卡片
边解读边织布的这样一个工作过程
也类似于现代的计算装置的工作过程
巴贝奇的分析机使用的也是穿孔的纸带
通过穿孔纸带来完成最初的
数据和运算规则运算步骤的录入过程
而巴贝奇的分析机在运转
的时候会去解读这个打孔纸带
逐步地完成
一个自动的计算过程
此处无教师声音
我们再来看第二个例子
我的手上是我的同事王挺给我推荐
的一款八音盒
这个八音盒可以
播放不同的音乐
在我的手上
有一个打好孔的卡片
这就是一个打孔的卡片
我把乐谱打在这个纸带上
我们来看这个八音盒的工作过程
我把输入的这个
打好孔的这个纸带
插入到这样一个机械的工具当中
按照输入的纸带上所打的乐谱
那么这个八音盒可以播放音乐
某种意义上来说这个八音盒
也是一个计算工具
它可以识别这个乐谱
然后按照它的机械设计
按照它本身八音盒的设计
播放出完整的音乐来
只是这个过程它还不是自动的
它是通过我手摇来进行的
通过这两个例子 我们希望你能够理解
巴贝奇的基本设计思想
我们下面就来看一看
冯诺依曼体系结构当中的
五大计算机组件
在冯诺依曼体系结构当中
定义的第一大计算机组件叫做
算术逻辑单元
在冯诺依曼体系结构当中
运算器
叫做算术逻辑单元
是对数据进行处理和运算的部件
由于经常进行的操作
包括有算术和逻辑运算
所以就把它叫做
ALU
全称叫做Arithmetic Logical Unit
第二大部件叫做控制单元
也可以把它叫做控制器
控制器就是用来实现
本身的一个自动化的过程
它来实现指令的自动装入
和自动执行
而在实际的计算机的
实现结构当中
通常我们会把控制器
和运算器集成在
一块芯片上
这个芯片就是计算机的核心部件
称为中央处理单元
这也就是我们通常所说的CPU
在CPU当中有运算器和控制器
运算的数据和指令
都来自于内存
所以在冯诺依曼体系结构当中
第三个非常重要的部件
就是存储器了
存储器
我们把它分成了内存和外存
计算机在运行的时候
它的数据和指令
通通放在内存当中
CPU也是直接跟内存打交道
内存有它自身的一些特点
存储器部分
包括有内存和外存
都是计算机用来存储
信息的记忆部件
但真正计算机在运行的时候
运行的指令和数据
都要进入到内存当中
那么 它才有资格
去抢占和使用CPU
完成最终的计算
我们举个例子来说
我们在使用计算机的时候
机子一启动
你说我希望把QQ挂上
这个话说起来就应该是
我希望启动QQ
那么 启动QQ
可能你的动作就是你用鼠标
去双击这个企鹅
那么这个过程你一旦双击
就意味着我原来存在
外存当中的QQ程序
就准备启动要进入内存了
那么进去了内存之后
我们就说这个应用程序启动了
它就有资格去使用CPU
去完成一些计算
完成你的通讯过程了
无论是内存还是外存
我们都把它看作是存储器
这是冯诺依曼体系结构
当中的第三大部件
那么第四大部件就是
冯诺依曼体系结构当中的
第四大部件就是
输入设备
我怎么样
指挥计算机去工作呢
我们说标准的输入设备
就包括鼠标和键盘
我通过键盘和鼠标
来输入程序和原始数据
第五大部件就是输出设备了
输出设备是用来输出计算机的
处理结果的
标准的输入设备
就包括显示器
你的笔记本显示屏
以及打印机
冯诺依曼体系结构
当中涉及了五大部件
那么 这五大部件要协同工作起来
共同帮助人
或者说共同使得计算机
能够进行问题求解的工作
这中间一定要有信息通道
五大部件之间一定要有信息通道
这种信息通道我们就把它叫做总线
总线作为
五大部件之间的一种信息通道
按照所传输信号的不同
我们把它分成了三类
第一类是数据总线
第二类是地址总线
第三类是控制总线
我们下面通过一个
简单的计算机的工作过程
来更进一步的来理解
冯诺依曼体系结构
我现在希望在机器上完成
一个简单的加法 这个加法
我就是想让它做2加7等于多少
第一件要做的工作
就是我要想办法
把这两个要参加运算的
运算数2和7
通过设备输入到计算机内部
那么在这里可能选择键盘
因为键盘上有2和7
我可以通过键盘把2和7
输入到计算机当中
计算机处理数据
实际上是通过CPU和内存
两个协同工作来进行的
2和7这两个数字
首先要进入内存
之后才能去抢占CPU
利用CPU当中的算术逻辑单元
来完成加这个动作
加法的结果出来之后
你可能有两个选择
一种选择就是
我把9我存放在我的硬盘
或者我的U盘
我存放在某一个位置上
存放在我的外存当中
还有一种可能就是
我通过标准的输出设备
把它输出
我用显示屏直接把9打出来
这也是一种选择
这是一个
计算机工作的过程
完成简单的一个2加7
等于9的动作
你可以看得到
这五大部件之间的协同工作
以及繁忙的信息通道
进行数据传输的过程
现在计算机
我们都把它叫做冯诺依曼计算机
因为现代计算机都
具备同样的体系结构
也就是我们刚才介绍的
冯诺依曼体系结构
五大部件包括
算术逻辑单元 控制单元 存储单元
输入设备 输出设备
这样五大部分组成的计算机
我们就把它叫做冯诺依曼计算机
计算机作为一种工具
改变了人类的行为模式
和工作方式
提高了人们的生活
质量和工作效率
那么人类有史以来
还没有哪一种广泛使用的工具
能够像计算机这样
既为使用者提供了
如此广阔的创造空间
又对使用者提出了如此
之高的知识要求
所以我们今天开始讨论
计算机的系统组成和工作原理
你可能会觉得
我又不是造计算机的
我干嘛要去学这个
工作原理
只要用会了就可以嘛
事实上我们说不是这样的
计算机这种工具
它太强大了
你只有深刻地理解了
计算机系统
才有可能在你的
工作和生活当中
最大效能的
去发挥出
计算机这个工具的长处
那么我们前面讲到了
图灵机
那么图灵机的工作
是理论上的突破
那么到制造出计算机来
我们还有一段路要走
早期我们看到过很多
计算机器
这些计算机器
在内部固定了一些
固定了一些程序
比方说一个计算器
它可以有固定的数学计算的程序
它不能拿来做文档的处理
也不能用来玩游戏
如果你想让机器做更多的工作
那么你可能需要
改变一些结构上的设计
你需要重新去连接
导线  元器件可能要做很多的变动
我们今天要讨论的就是
如何让你的电子机械装置
有通用计算的思想
我们今天就讨论通用计算
最早的思想 以及体系结构的形成
计算机的发明
在有了图灵关于计算的理论之后
我们还需要有一些理论基础
数字计算机的发明
需要有理论上的突破
第一个我们要介绍的就是
布尔代数
1850年左右 英国数学家布尔
就已经创立了布尔代数
布尔代数系统
使用的是0 1表示
用一个关于0和1的代数系统
用基础的逻辑符号
来系统的描述物体和概念
布尔代数 构成了现代电子
计算机的数学和逻辑基础
布尔代数是把逻辑表述
映射到符号
采用数学的方法
来处理逻辑推理
这布尔代数的系统
当中 基本的符号
就只有0和1
我们从这两个基本的
布尔量出发
来定义布尔代数
当中那些基本运算
我们首先看这个
与的动作
指二元布尔量之间
与的操作
这个与的操作有
很多种写法
对于两个布尔量a b之间
这个与你可以写成
a乘以b
也可以a和b连着写
既然它是布尔量
那么它的取值就
只有两种可能
要么为0要么为1
那么加在一起
两个布尔量之间的0 1组合
就有四种情况
0 0
0 1
1 0
1 1
我们来看它们与的结果
那么很多时候 在有些书本当中
会把这种操作叫做and
我们用原点表示逻辑与的动作
在a和b布尔量都为0的时候
a和b
运算的结果依然为0
0和1
与完之后也是0
1和0
同样为0 只有在两个布尔量
都为1的时候
a与b的结果才会变成1
第二种二元的
二元布尔量的运算是或
或有的时候会写成a加b
也可以用英文字符OR来表示
同样的 对于这两个布尔量的组合情况
一共是四种
那么做布尔
二元运算如果是或的话
得到的结果
在布尔量 两个布尔量值
都取0的情况下
a加b的值
a或b的值为0
而其他三种情况
a或b的值都为1
那还有一种非常重要的
一元的布尔运算
我们把它叫做非
或者用英文单词用not来表示
这是只需要一个
布尔量参加的运算
假设为a
它的取值情况 要么为0要么为1
而它的非的
对a进行非操作之后得到的结果
在a取0的情况下
你对它进行非的运算得到结果为1
而在这个
布尔量取值为1的情况下
得到的值则为0
这是三种最根本的布尔运算
下面请大家看这样一个问题
我这有一个布尔代数的表达式
请你来回答它与下面哪一项是
等价的
这个答案是D
我们来验证一下为什么是D
这是我们原始的表达式
这里出现了两个布尔量
一个是x 一个是y 我们来看一下
布尔量x 布尔量y
对于它们的
所有的情况组合
有00
下面我们来计算一下右侧的值
按照我们刚才
给出的一些简单的定义
来计算一下
最终这个表达式的值会是什么
我们首先来算一下not x的值
来看一下
那x的值如果为0
那么not x值就为1
而这一边
当前y的取值为0
那么not y的取值就为1
那么做布尔运算
或的时候两端的值都为1
所以这个时候 第一项在
x和Y都等于0的情况下
这个表达式的值为1
对于下面一个 也可以推断出
它为 1
对于第三种组合1和0
x取1 not x取值就为0
而y取0 not y的取值就为1
对于布尔运算当中的或操作而言
只要有一项为1 最终的结果为1
再看第四种情况在x y都为1的情况下
如果x为1 意味着x的非为0
那y为1 y的非也为0
而0与0进行布尔运算  或的话
得到的结果就是0
这是题目当中所给出的表达式
运算的结果
我们再看四个选项当中的第四项
第四项给的是
x
与上
y
这个时候我们来看
这中间做的这个布尔运算
与的动作
与的动作我们说了 它有一个特点
就是里面只要有一项为0
结果都是0
这个时候我们可以看到与起来
就是前三项
在x y当中只要有一个0
与后的结果就为0
所以我们可以看到 在我们做非之前
上面三项实际上都是0
只有最后一项为1
x y的取值已经
四种组合都在左边了
在做最后的取非运算之后
最终这个表达式的结果是1110
这样也就验证了
我们这两个表达式之间是
等价的
这两个表达式之间是等价的
因为我们具有同样的真值表
在x y取同样值的情况下
我们的结论都是同一个
我们有了图灵机的理论基础
现在又能够把布尔代数跟
开关电路对应起来
这样实际上已经为计算机的发明
奠定了一个非常好的基础
下面的问题就是我怎么样
能够设计一台计算机
能够让它具备通用性
然后让它做各种各样的工作
让这台机子
具备通用计算的功能
冯诺依曼做出了伟大的贡献
在1945年的6月
冯诺依曼和戈德斯坦 伯克斯等人
联名发表了一篇长达
一百零一页纸的报告
这个在计算机史上是非常有名的
叫一百零一页报告
是现代计算机科学发展的
里程碑似的文献
在这篇报告当中
把计算机分成了五大组件
那么这种
关于电子计算机的逻辑结构设计
为现代计算机的发展奠定了基础
已经成为计算机设计的一个
基本原则
在一百零一页报告当中明确指出了
计算机是利用存储器
这个存储器指的是我们现在所说的内存
来存放所要执行的程序
你所要执行的指令
都放在程序的
都放在计算机的内存当中
这就是我们讲的存储程序
控制的基本工作原理
那冯诺依曼和他的同事们
依据此原理
设计出了一个完整的
现代计算机的原型
并确定了
存储程序计算机的五大组成部分
和基本工作方法
EDVAC
于1949年五月建成
它是世界上第一台真正实现
内部存储程序的电子计算机
其中也凝结着冯诺依曼等人的设想
也是后来所有
计算机的真正原型和范本
我们先看一下计算机系统的概念
然后我们再回过头来
讨论
冯诺依曼体系结构的计算机
是什么样的
存储程序控制的工作原理
又是如何工作的
一台计算机买回来只有硬件部分
而没有安装任何软件的时候
我们把这台机子叫做裸机
这台裸机是没办法工作的
因为它只是一些硬件摆在这里
真正要使这个系统转起来
我还要安装软件
那么计算机软件是相对
硬件而言的
那么什么是硬件
我所有的电子机械装置
我们把它叫做计算机的硬件
计算机的软件是相对硬件而言的
它是指由计算机硬件执行
以完成一定任务的所有程序和数据
这些我们都把它称作软件
计算机的软件
我们又把它分成了两大类
一类是面向系统的 面向计算机的
我们把它叫做系统软件
另一类是面向用户的
我们把它叫做应用软件
那么一台机子我们刚才提到
买回来是一台裸机
没有软件它是转不起来的
一台裸机买回来第一个要安装的软件
就是我们最重要的系统软件
也就是操作系统
安装了操作系统之后
你可能还需要其他的软件
首先可能需要安装防病毒的软件
还需要一些
我要做一些
办公文档的处理
我可能需要安装WPS
在这台机子上
我要使它完成各种各样的
我所需要的工作
还包括我
包括我日常可能需要一些生活娱乐
包括游戏
你都还需要
安装相对应的一些应用软件
而我们刚才所提到的
冯诺依曼对现代计算机
整个给出了一个结构设计
这个结构我们把它叫做
冯诺依曼体系结构
而这个体系结构的设计
针对的是
计算机的硬件部分
也就是我们刚才提到的
所有的电子机械装置的总称
叫做硬件
那么硬件它的英文单词是hardware
实际上直译它是五金的含义
指的是实实在在看的见的东西
刚装配好的计算机硬件
在你安装软件之前
它还仅仅是一个没有活力的躯干
它的那些功能
都没有办法用起来
要让它获得活力 为人服务
就还得去激活它操纵它
让它按照人的意志来工作
这个时候我们就需要软件了
为了和硬件这个名称相对应
人们把所有使用
计算机的技术资源称为软件
它的英文单词就是software
从另一个角度来看
计算机就跟人一样
如果没有思想 只有一副躯壳
那么很难称的上它是一个完整的人
正是有了
正是因为有了丰富多彩的软件
才构成了一个完整的系统
才能使得计算机的基本功能
得以应用和发挥
布尔代数可以应用在逻辑当中
因为用0和1
很自然的可以表示真和假
我们可以用0去表示假
用1来表示真
这中间涉及
变量和布尔运算的表达式
代表了一种陈述的形式
我可以去表达一些命题
表达一些有真假意义的陈述句
而这些陈述句最终可以用在
逻辑推理当中
而逻辑推理看作是
对人的思维方式
人的的逻辑推理过程当中的
人的推理过程的一种抽象
所以我们说
布尔代数应用在逻辑当中
可以帮助计算机完成一些基本的
逻辑表示和逻辑推理问题
布尔代数另一个重大的应用
是在电子工程当中
布尔代数在电子工程当中可以用于
电路设计
这里的0和1就代表了数字电路中
一个位的两种
不同状态
典型的是高电压和低电压或者是
开关电路当中的开和关
这样 我的电路
就可以用布尔代数来描述了
电路就可以通过包含变量的
表达式来描述
两个这种表达式
对这些变量的所有的值都是等价的
当且仅当对应的电路
有相同的输入输出行为
此外 所有可能的输入输出行为
都可以使用合适的
布尔表达式来进行建模
我把人的思维过程
人进行问题求解的一些过程
进行了抽象 进行了数学建模
下面的问题就是
我怎么样落在具体的物理实体上
或者落在具体的电子机械装置上
来做一个实现
而电路就是再具体不过的一种
物理表示了
这样我们就把
布尔代数这样一种数学理论
跟电路联系起来了
而完成这个工作的人就是shannon
shannon在1938年发表了著名的论文
叫继电器和开关
电路的符号分析
首次用布尔代数
进行开关电路分析
并且证明布尔代数的逻辑运算
就我们刚才讲的逻辑与
逻辑或 逻辑非
都可以通过继电器电路来实现
就你的逻辑推理过程
我可以用电路实现
同时明确也给出了
加减乘除等运算的电子
电路的设计方法
这篇论文成为
开关电路理论的开端
还有一点必须要提的是shannon
是现代信息论的创始人
现代信息论的出现对现代通讯技术
和电子计算机的设计都产生了
巨大的影响
我们下面来看看
如何把我们刚才所讲的
与 或 非
三种布尔运算
怎么把它跟电路对应起来
我们先来看看布尔代数的非运算
如何跟开关电路对应起来
在这个电路图当中有一个电阻R
有一个
灯泡A同时还有一个开关
对于开关而言它有开和关两种状态
我们可以用0和1表示
灯泡A同样也是布尔量
它要么取值为0表示它是灭的
要么取值为1表示它是亮的
我们来看A和B之间
有没有一些关联
如果合上B开关
相当于我把A短路掉了
这个时候灯泡就应该灭了
我们看AB之间的关系
在开关合上
也就是它取值为1的时候
灯泡A被短路掉了
它是不会亮的
所以它的取值为0
而当开关没有
闭合也就是它
取值为0的时候
我们可以看到这个
从电源流出来的电流
就会流经灯泡A
灯泡就会发光就会亮了
所以它的取值为1
从这你可以看到
A和B之间就是一种
互为非的关系
A为B的非 同时B也是A的非
这样我就用电路描述出了
这种布尔代数的非的运算
我们来看或运算的这个
电路
我们来看右侧的这个电路图
电路图当中A和B
无论哪一个开关闭合
都意味着A和B
所对应的布尔量取值为1
而这都会导致整个电路是导通的
这样对于布尔代数当中
所定义的或运算
我们也找到了等价的
开关电路
最后我们再来看与运算的
与运算的定义当中
与运算的定义当中
指的是
一定是两个
布尔量都为1的时候
最终的结果才会是1
否则的情况都是为0
那我们来看用
这显然的我们可以
通过串联的电路来
来表示
这两个开关
就代表着我们的两个布尔量A和B
A和B的取值要么为0要么为1
那么这条
电路什么时候算是连通的
只有在A和B都闭合
也就是取值都为1的时候
整个电路才是连通的
由此我们也就得到了
A与B的开关电路
这样我们就把
我们就把布尔代数
跟开关电路联系起来了
这也就是使得我们的数学理论
扎扎实实的落在了电子机械装置上
刚才我们讲解了布尔代数
也讲解了布尔代数怎么
跟开关电路联系在一起
下面请大家完成这样一道作业题
请把下面的这个布尔表达式的
开关电路画出来
这是数学中非常经典的
百钱百鸡的应用问题
问题记载于中国古代的
张秋建算经
是这本书的最后一道题
这个问题最终导致的是三元
不定方程组通过对三元不定方
程组来进行求解
它的重要之处还在于
开创了一问多答的形式
这道题最终的
结果是一个
怎么把所有的解求解出来
这是在
张秋建算经之前的中国古算术
当中是没有的
我们现在考虑的就是
用数学的求解方法这个题该
怎么做
用数学问题求解的话
首先也是假设
我在这里需要知道的是
最终要买多少公鸡母鸡和小鸡
设自变量
假设最终购买的公鸡是
x只
母鸡是
y只
小鸡是
z只
这是我的假设
最终是要满足题目所说的条件
满足的条件是100文钱
要买100只鸡
首先是
第一个条件是x加y加z等于
100最终还要刚好是100文钱
公鸡是5文钱
母鸡是3文钱
小鸡是
1文钱3只
所以最终的结果是也要是100
这是
两个方程
下面对第一个方程做一个
变幻
这个变换是个等价的变换
分别把它叫做1
和2
把它做变换的目的是看能不能
找出一些
特定的关系出来
把第二个式子乘以3
把分数部分去掉
把它跟1做相减得到一个
新的方程
这个方程
可以得到的是
14x加上8y
等于200
把这个式子化简一下两边
都除以2式子还是相等的
7x加上4y
等于100
这是第三个公式
由3我可以
做出一些推导
我可以求出y等于
由3得出y等于
100减7x
除以4
再往下写100除以4就是25
就应该是25减去
4分之7x多减一个减
2x再加4分之1x两边式子相等
这是我得到的第四个
方程
这里既然出现了4分之
x不喜欢分数
把分数做一个变换令x等于4t
xy都只能取
自然数小鸡不可能半只或
4分之1只
x一定能够被4整除假设
x等于4t
t显然是自然数
我最终求得的xyz
也要是自然数
这样再带进去就可以把y表示
成t的函数y等于什么
y等于25
减掉7t
同理也可以得到
同样的计算方法
同样的方法我们可以
z也表示成t的函数
z就等于
减
x
减y
这里就是100减4t
再减y减25加上7t
由此可以得到
加上3t
这是
z的数值
这样就可以得出一组关于t的
表示x等于
x等于4ty等于25减7t
z的结果最终是75加3t
而我们这里给出的约束条件是
xyz表示的都是小鸡的数目
所以xyz
都是自然数
对吧
xyz
均为自然数
所以有4t大于等于0
25减7ty也是大于等于0的
z75加3t
也应该大于等于0
由此可以解得
可以解得一个不等式
这里决定了t大于等于0
这里决定t
小于等于7分之25
最终得到的不等式是t
大于等于0小于等于7分之25
在0和7分之25之间
的自然数为
t可以等于
t可以等于
t可以等于
t可以等于
自然数的选择对于t而言
就是0123
在t等于0的时候可以求得
的一组解
则是
x是等于4t
所以它也等于0
y等于25减7t
t为0所以y等于25
z则为
75加3t
z是75
在t等于1的时候x等于
4t也就等于4
由此求得y等于
18z等于78
t等于2时
x等于8
y等于11
z等于81
t等于3的时候x等于12
y等于
z等于
所以回顾数学方法可以看到
中间我们用到了假设的自变量
xyz这是代数
他们之间的数量关系
要了解
然后利用人类问题求解的方法
利用我们的思路
最终求得问题的解
我们用数学的方法来求解问题
实际上是通过我设自变量
设xyz
然后根据各种各样的
已知的
条件和信息利用我列的
出来的方程和方程组
利用数值之间的关系完成代换的过程
我们再来看计算机
求解问题的过程
再用计算机进行问题求解时
一些重复的动作很多时候
用循环来实现
用一些重复的动作
试图去列举出问题所
涉及的所有情况有哪些
所有的情况中哪些是满足约束
约束条件可以用if条件判断
把约束条件用if语句描述出来
之后用每一种情况每一种可能
去尝试
而答案最终要满足
问题当中给出的所有条件
首先把这些条件
怎么用计算机能够理解的方式
表示出来有各种各样的运算符
今天引进了关系运算逻辑运算
符可以描述这样一些问题
下面要考虑的是问题所涉及的
实例组合有哪些
每一种实例情况都不能错过
错过的每种情况都可能是解
这里我们说要求xyz各有多少只
x的选择是从0到100
y的选择我们放宽xyz的选择
都是自然数都是0
到100之间的自然数
这种组合情况是非常多的
这中间只有一部分的组合情况
是满足我的要求
我这里的约束条件两个
一个是100文钱一个是
100只鸡
满足这两个条件的
才是最终问题的答案
现在就是希望
通过重复的判断
每种情况我都去判断
看能不能凑出100文钱100只鸡
满足条件的才是我所要的解
能否枚举出所有可能的组合
一一检查它是否满足条件
这就是我们讲的
穷举
从思路上先确定枚举的对象
枚举的范围判定条件
枚举对象
我对谁实现枚举
对xyz这三个自变量
公鸡的数目x母鸡的数目y小鸡
的数目z枚举的范围
首先确定xyz是自然数
公鸡的数目一定是在0到20之间
母鸡的数目在0到34之间
小鸡的数目z
则在0到100之间
判断的条件就是这两个条件
一个是100
只鸡
一个条件是100文钱
做完这个分析之后就可以设计
算法
我们在这里要枚举出所有可能
的实例这里
x有多少种选择y有多少种选择
z有多少种选择
这是一种组合的情况
在这样的情况下
我们假设x等于0y等于0z等于
0看它是不是解
然后判断
第二种情况等于把所有情况
都穷举一遍验证是否是问题的解
这里依然用循环控制
不知道大家能不能考虑一下
我在这里的循环
该怎么样来写
这是我们今天的第一个例子
在这个例子中我们用到了循环
这个循环只有一层
我要确定的变量是x是谁
所以首先假设x等于1
然后假设x等于2
x等于3
x等于4
所以做了一层循环
这个一层循环中让x从1变到4
每一次循环
都完成对四句话的判断
这是我们讲的
一重循环
用一重循环完成了
第一道习题
在第二道题中有两个
变量需要
判定
要知道第一个老鼠咬坏的地方
是什么
把它假设为x第二个被老鼠
咬坏的地方假设为
y
所以在题目中我们
在x等于0的时候把y的值从0
到9发生变换
看有没有0
x取0的时候y有没有解
那么
再来一层则是x发生了变化
x等于1的时候
y的变化又从头开始
依然是从0
到9完成一个
循环那么
下面的过程就类似了
x等于2的时候y的变化过程
依然是从0到9
直到试完所有的情况最后
一层x等于9的时候y的变化
过程依然是从0
到9
所以对于这样一个
枚举的思路是这样去枚举
最终的实现是把它用一个
二重的循环
有两层循环
就是x每发生一次变换y的值
都要从0到9重头到尾走一遍
最外层的循环控制着
x从0到9的变换过程
内层的循环每当x
确定一个值之后
y都从0
到9
发生变化这是一个二重的循环
再我们百钱百鸡的问题中
有三个变量最终想求出值
这个解不唯一
三个变量一样要枚举所有情况
这里已经确定公鸡的数目
是0到20只
母鸡数目是0到33只
小鸡数目是0到
100只这种情况的组合
数就是20乘以33乘以100
所以对下面这两个判断
条件下我执行的次数是多少
这就是最终完成判断的次数
我们的
枚举所有实例的思想依然
沿用
前面的思想
x等于0的时候
我们先看y等于0的情况
x等于0y等于0的时候而
z的情况要从0到
100逐一去
下一个要变化的100种情况
着101种情况试完之后
如果是解输出如果不是解
还要继续找因为要找出所有解
所以过程是持续进行的
下一个变化的就应该是y
从0变化成1
这种情况说明在x等于0y等
于1的时候z的变化过程
是不是还是要从0到100
进行尝试
这也是一样这种情况完之后
就该y发生变换
y直到什么时候呀
y直到变完
等于33
在y等于33的时候我最终
在试完
0到100的情况
这里说的是x等于0y
等于33的时候
z的选择还要从0
到100去试一下
这样才试完所有x等0的情况
下面再来考虑
x等于1以及其他情况
在x等于1的时候这一组过程
还是要重新进行
所以可以看到z的变化过程
就是一层循环
而在x等于某个固定数值时
y的变化是从0到33
这就是最外层的一个循环
这又是一重循环
最外层的循环是x等于0
开始
从x等于0到x等于2
这一层
对这一
我们用到的是三层的嵌套组合
最外层是
x控制x不断变化
在进来一层控制y的变化
最内层的循环是
z的一个变化
这是三重的
循环嵌套
一个不落每一个情况都是尝试
这是遍历的过程我遍历
穷举出所有的实例来
公鸡的数目
x从0遍历到20母鸡的数目
y从0遍历到33
小鸡的数目
z从0遍历到100每一层遍历
进来都是每当确定一种
实例情况xyz有了一组
组合之后都完成这样一个条件
的判断判断x加y加z是不是100
5x加3y加3分之z是不是100
如果满足这两个条件
就是我们找到的一组解
这个时候就可以把它
用小精灵说话
把它输出
事实上这是算法的描述
这就是我们
给出的算法的描述
这是一种算法的
我们考虑这个算法描述
有很多同学都想到了
这里是不是一定需要三重循环
我能不能做一个
化简简化
是可以做的
当我确定公鸡母鸡数目之后
小鸡已经无从选择
也就是这里一个条件是要求
x加y加z最终的结果要是100
所以z完全没有在
对于z的遍历和穷举没有必要
z的值直接用100减去x减去y
就可以完成这个
最终的判断
算法可以改造一下用两重循环
在我有了
公鸡数目x母鸡数目y确定之后
小鸡数目只有一种选择
z只能是100减x减y
我没有必要再去
尝试它那么多的情况
这样三重循环就简化成两重
这就是算法两重循环计算量
有明确的缩小
这也是我们计算机问题求解中
必须要关注必须要追求的
我要效率高
我要用尽量少的计算资源
计算速度要快要用尽量少的计算资源
这里小鸡的数目z等于100减去
x减去y
判断条件也就提升为
一条我不再需要完成两条判断
只要完成这一个判断
前面那个已经通过
这个设定了
满足了
下面的联系留给大家
用byob实现百钱百鸡问题求解
对于这个运行结果不做演示了
如果在你解这道题
过程中碰到有问题
请你参照视频中的程序
来对照看一下算法
如何从算法到程序
在这里一层一层循环可以看到
第一句话公鸡的数目从0到20
这里用100整除5来表示的
x最初设了一个初值可以看到
然后是变化范围
这里用的repeat循环
用的循环是repeat until
我循环直到x大于20
x超过20不是解不用试了
我循环到
21打止
这是循环结束的条件
最外层的循环
进来之后是
母鸡的数目从0到33完成遍历
这是内层循环
不管x取什么值首先进来的是
y的值母鸡的数目都要从
0到33开始
x等于0的时候你做过了
x等于1y还要从0到33开始
来做一种组合
这样才能穷举出所有的情况这
是对应的这一层的循环
第三句话说的是小鸡的
循环进来
这里用两个repeat循环
代表了穷举了母鸡公鸡的所有组合
只要确定xy数目z的数值
也就出来了
z等于100减x加y的和
xyz都有值了之后就可以完成
这个判断了
这个判断就是百钱问题
最终出来的钥匙100
块钱百钱
如果if判断成立意味着
这一组xyz就是我要找的解
这里通过列表通过join运算
最终输出
把它记在result当中
关于列表
列表这部分内容在程序设计
在我们这门课中没有讲
有兴趣的同学可以自己翻一下
程序设计byob程序设计的文档
那么这两重循环还标出了xyz
每次的变化都是通过递增1
来实现的
可以看到从算法
到程序的对应的过程
从这可以看出计算机进行问题
求解的过程是你理好自己的思路
写出算法
有了算法后根据算法写出
程序这是一个一气呵成的过程
回顾百钱百鸡问题求解方法
我们特别的
写了它的数学
用数学
用方程组怎样进行求解
用算法用程序怎样进行计算机
的问题求解
请你比较两者的不同
会有这样的不同因为
数学求解方法是适合人类的
而计算机的问题求解方法最终
要落在计算机这样一个
自动计算的工具上
要了解计算机的特点
以它能够接受和理解的方式
它在电子机械装置上
最终完成机械重复
的运算实现算法和程序
数学求解方法强调的是
我要了解这些变量
这些数值之间的关系
当然也包括等价关系
进行各种各样的代换最终
试图去找出满足约束条件的解
计算机问题求解中有很多方法
这里强调的是枚举我要穷举出
所有可能的实例逐一
检查
是否满足条件
而这个过程对于计算机而言
它是有自己的优势的
它是自动化的一个过程
你的判断
你的实例的变化只要找出规律
用重复循环
我可以充分发挥计算机的优势
计算机
很擅长于做简单重复劳动
它的电子机械装置决定了
它得到的结果是确定的
它不会今天对明天错
它一定是确定的结果
它的自动化的过程
完成自动计算的过程
是非常高效的
下面对今天讲的枚举法做
一个总结
枚举法是利用计算机运算速度快
精确度高的特点
对要解决问题的所有可能情况
逐个检验
找出符合要求的答案
枚举法是通过牺牲时间
来换取答案的全面性
对于计算机而言
由于计算机的计算速度很快
所以它做简单重复劳动
跟人比是有优势的
利用枚举的方法来
完成计算机的问题求解包括
三大要素
第一大要素确定对谁进行枚举
穷举哪些实例枚举对象是
枚举对象有怎样的枚举范围
它的变化范围是哪些
第三大要素是判断条件
根据什么
来确定
你所枚举的对象哪个是解
哪个不是解
在算法的设计过程中
重要的是枚举的实例该如何表示
要确保枚举遍历
所有的实例
这里用循环用选择用循环结构
来确保
枚举所有的实例选择结构确保
条件的判断
枚举算法因为要列举问题中所有
可能的答案所以具备一些特点
一是得到的结果一定正确
因为一种情况都没有漏掉
算法过程简单穷举实例
充分发挥了计算机的
优势
缺点在于
我可能做了很多
无用功浪费了时间
从人的智能而言可能一下分辨
出哪些可能不用去试
它根本不可能是解
对于复杂问题而言
用穷举的方法组合数
非常之多
这里可能会有组合爆炸的问题
除了这一单元我们给出的实例
下面留一道作业
这道要计算丢番图的年龄
丢番图是古希腊
著名的数学家
在
丢番图的墓志铭上
有这样一些记载
坟中安葬着
丢番图
它没有明确指明它的年龄
只说童年占他年龄的六分之一
又过了十二分之一
开始长了胡子
又过了七分之一
他结婚了
5年之后
他有了一个孩子
这个悲剧就是这个孩子
最终只活了它父亲的
年龄一半
希望你根据题所给
出的信息
计算出
丢番图的年龄用枚举法
来求丢番图的实际年龄
我们介绍的枚举法是一种
非常直观简洁的计算机
求解方法它干净利落
是一种简单重复劳动可能
人不愿意干计算机很擅长
不会错
是和求解的问题中要求他
所涉及的实例是确定的
明确知道它的范围也知道
应该怎样去尝试
实例最终要满足一定的条件
才有可能成为问题的答案
求解方法上就是枚举出所有
实例去判断是否满足条件
这种方法的特点是典型体现了
计算过程自动化的计算思路
这种方法充分体现计算机
的高效率
但是枚举法
不适合于求解很多复杂问题
对于复杂问题需要更聪明的方法
计算机问题求解枚举方法的实现
大多依赖于循环
下面大家一起做一个练习
题目是一个老鼠咬坏了账本
账本中有些位置被它咬坏了
用叉代表被它咬坏的地方
想恢复下面等式
叉代表哪个数字
对于它而言典型的方法用穷举
一个一个去试对人而言
0123456789第一个有叉的地方
时10种选择
第二个有x的地方时0到9
10种选择
这两个组合在一起有100种选择
这个题需要确定叉代表什么数字
对于数字而言叉的位置
代表了一位数字要么为0要么
为1要么为2
或者是一直到9
意味着一个x是10种选择
这里有两个位置被老鼠咬坏了
有两个叉
这不是两个相等的x我用叉
表示被老鼠咬坏了
第一个打叉的地方
有可能是10个数字当中的一个
第二个叉也可能是10个数字中
的一个
所有情况是10乘10一共是
100种
组合
检查所有的组合一定可以找出
这两把叉可能是什么
如果人来求解可以很快剔除一些
数字因为人
它是有很高智能的
利用经验和常识
对数字的了解对数字具备的知识
可以缩小范围但不是今天讨论
的内容今天讨论的是
对于这种情况一种一种去
检查用穷举的方式穷举100
种情况一定可以找出
x代表的数字是什么
这是一种
简单重复劳动是计算机最擅长的
它在计算这个过程中
程序不错硬件不失效则计算结果
是确定的
而且计算过程是非常高效的
请大家思考这个过程该如何来
用byob做一个实现
在这个问题中
原本列的公式中都是用叉
表示被老鼠咬坏的地方
最终要求出这两个数字是什么
实际上这里是两个未知数
在byob中要涉及两个变量
一个是不够的它们不一定相等
所以这里涉及两个变量
这个还用x来表示
这个位置的数值
用y来表示
无论是x和y它
的选择都是10
都有可能是0到9中的某个数字
首先
设计好这两个变量
一个叫做x
另一个叫y
对于这个问题
我们
自顶向下的
来考虑最终
是100种组合情况事实上
以有序的方式进行
x的变化范围
是重复10次的
在
控制中依然选用10次的循环
对于y的变化过程是不是
也是10次的变化过程
真正完成组合是这样
当x选定
一个值的时候
当x为0的时候要重复
10次
来确定
y的值
最外层循环代表了x的变化过程
开始x的值为0之后
x值要每次增加1
这样通过10次变化之后变到了
这是循环10次
来表达x的变化过程
x取定0的值的时候y的可能
也是从0到910种可能
每次思想在于这里用到了循环的
嵌套
用两重循环
x每取定一个值y就从0
到9发生变化
当x等于5的时候我们试试y从
0到9有没有可能有解
当x等于6的时候又来试试y
从0到9有没有可能有解
这是一个双重的选择
而y的变化过程
每一轮当
x发生变化之后
我都要
把y从0到9完成一个变化的过程
这等于我先把xy变化的过程写
进去下面完成判断
在这个题中判断就是一句话
一个判断条件
先把条件是一个判断相等
先把相等的关系运算摆在这
谁跟谁相等是两个乘法运算的
结果相等
所以写上两边都是乘法运算的
结果
在这两个乘法运算中
一个数是4158我先把它写上
第二个数
固定的数是3564
剩下的两个乘数中都有未知数
第一个是5x这是一个加法
是50加上x
第一个数实际上50
而
个位上是x
这个x要通过变量来
右边这个乘法算式中
第一步也要做加
这个位置写的是y3
这个y是10
乘以y
还需要写一个乘法
这个地方应该是10
乘以y
y需要拖动过来
这里加上
一个数是3
这就是你的
要完成判断的表达式
这个控制依然要用
if语句
我要完成这个判断
对吧
如果这个式子相等了
这个组合使式子相等了意味着
这就是我要求得的组合
把解做一个输出
这个时候输出的可以看到
x是多少y是多少需要
一组数值不是一个数
来看怎样把一组数值输出
要用到操作符中的join命令
连接两个字串
一个说的
x
一个说的结果
是y
下面我们来看程序运行
看能否找出两个数字是多少
x是等于4
y等于6
只输出一组解解是唯一的
x的值
为4y的值为6这种输出的形式
看起来不直观我稍微修整
我在
依然使用
jion这个命令
这个jion修改这样
先来输出x等于然后
给出x的结果
这里还需要一个jion
下一个我希望输出y等于
下面再来看这种输出格式
得到的是什么
这时候明确告诉你x等于4
y等于6这是最后的运算结果
这道题我们用到了二重
循环最终求出这两个数字
刚才给出的两个例子考虑的是
在计算机中
如何用循环去实现
穷举法枚举法
这是一种简单的重复劳动
用循环可以很自然的完成这种
问题求解的过程
下面我们通过一个实例
对比一下计算机的问题求解
跟数学中我们也进行了
应用问题的求解这两种求解过程
关注点重点是有所不同的
我们通过下面的例子做一个分析
跟数学中的问题求解
各自强调的重点
再用计算机进行问题求解的时候
特别注意的问题又有哪些
今天我们讨论计算机问题求解
先从最简单的问题求解方法开始
今天重点讨论的叫做枚举法
或者穷举
现实生活中有这样一类问题
可以通过穷举所有的实例
来找到满足
要求的解
这样一类问题也很适于用
用计算机进行问题求解
在我的问题领域中有很多实例
这些实例
有一些
是我所要找出来的
穷举法枚举法在我们所讲的
典型问题求解模块中
是一种最简单的问题求解方法
这道题是这样说的
这四个人都有一句表达
秦政说不是我
秦明说张根干的
张根又说是张潇
张潇说
张根胡说
在这四句话中我们已知的作案
信息是什么
我已知的信息是三个人说的是真话
一个人说的是假话
我们现在根据这些信息
想找出做了好事的这个人
其实问题求解的思路是清楚的
我一共只有四个人
我可以做假设
假设是秦政干的是不是能够
对这四个
命题得出三句是真的的结果
如果是说明秦政是一个选择
这就是典型的枚举的思路
四个人我一个一个去试
看是否有一个人能满足这道题
的要求保证这四句话中
三句是真话
这道题真正能够求的它的解
要能够在计算机中求的它的解
这中间还有一些概念我们
这中间还有一些基本的运算
我们先做介绍
问题就是这四句话我在计算机
内该怎么表示
这四句话本身
是四个命题
这中间是我们在数学中
在高中数学接触过的一些
逻辑表达
我们来看看这种逻辑表达
在计算机当中在
程序设计计算环境中
该如何体现
不管是什么样的语言
什么样的程序设计环境
一般都支持类似的运算
在这道题中提到了是谁不是谁
是谁意味着
两个对象相等
这是一种关系运算
所以我们先来看
运算符中的关系运算
这是三种基本的关系运算符
我们这里提到了是谁
事实上这就是判断相等
我要找的这个人是不是跟
秦政相等
这是一种相等的判断
这是我们先介绍的
关系运算符
这里还提到不是谁
这不是
以及我们前面讲的并且或者
这是我们讲的逻辑运算
在BYOB当中
在运算符中
关系运算符下面有三个
这三个符号代表着
三种逻辑运算
并且 或者以及否定
这跟我们在布尔代数中
讲授的基本符号有些类似
它们代表的含义也是相通的
这些运算符支持我们把
用自然语言描述的应用问题
我的应用问题都来自于现实世界
都是用我们的语言来描述
我怎样把它
表示成计算机能够接受的
我需要一种
特定的形式化的语言
这些语言当中
包括关系运算逻辑运算
它能够描述出我们平常所说的
而且 或者不是谁
我用自然语言描述的问题
最终我可以用形式化的语言
用计算机可以理解的语言
把它表示出来最终完成问题求解
我们强调问题求解的第一步是抽象
抽象紧跟着就是你的知识表示
怎么把现实中的问题
转换成机器可以理解
最终可以完成计算
在byob中提供了
两组一组关系运算符
一组逻辑运算符来描述
现在一回到我们这道题
这道题出现四位同学
这四位同学都有可能是做了好事
的首先面临的是把这四位同学
说的四句话在计算机中表示出来
简单给四位同学编个号
秦政是1秦明是2
张根是3
张潇是4
我最终要找出做了好事的人
我们现在不知道它是谁
给它取个名字叫x好了
现在就是要找出x是谁
秦政说不是我
他认为x
不等于1我用1来表示秦政
这是第一句话第二句话是秦明
说的我并不关心这句话谁说的
我关心是它说的内容
我们这个题已知的
要解决问题的信息是
三个人说的是真话
我要找出最终这四句话
里面有三句要是真话
就是看四个人中谁能满足
这个条件
他说是张根干的也就是说
x是等于
3张根用3表示
我把它划一下
1秦政2秦明3张根4张潇
张根说是张潇x等于4
张潇说张根胡说
张根说的又是什么呢
是张潇它否定了张根说的
这个人是张潇
x一定不是张根
所以这是这样四句话
这四句话我用简单的
表达式表达出来我们知道
在byob中是没有不等的
我可以用否定词
可以用逻辑运算符中的否定词
现在我们去byob
看一下怎么表示这四句话
同样的我在这里在求解过程中
设计一个变量求出
x是谁
用x存放做了好事的编号
我用1234表示的
这四句话我可以先把它写出来
这四句话我就表示出来了
刚讨论了求解这个问题的思路
四个人逐一去试
先从秦政开始
然后秦明
张根张潇我先假设是秦政干的
看它能不能使这四句话
最终的运算的结果中有三句话
的判断是真
一句话的判断是假
如果能满足这个条件
就说明这件事是它干的
如果不是再来试试是不是
秦明张根张潇
通过四次
重复的四个动作先假设是秦政
再假设是秦明
而后面的动作序列可以写成
一段程序
一个一个去试这就是讲
的典型的枚举思想这里我们
x的取值最初的假设是x等于1
从秦政开始
一直到x等于4
到x是张潇的假设
最终完成这个判断
这个过程可以用循环来实现
循环的次数是4
我先把循环表示在这里
循环次数确定为4
循环4次中每一次都要完成判断
一开始假设x的值为1
x为1我们来完成一些判断
判断语句是if
在控制指令当中
那么这里还有一个值
需要计算的就是
我需要统计一共对了几句话
只有真话数是3的时候
才是我要找的那个人
这个时候还需要变量来统计
用y来记录
有几句是真话几句是假话
y的值最初
y也需要初值最初为0
如果这个
这四个条件为真
就意味着它的
说了一句真话就要修改
y的值
使y的值
增加1
这表示说的话为真
对下面这四句话做同样操作
每当他说一句
真话的时候
y的值都增加1
这是第二句话
如果它使判断为真
也就是满足第二句话
我们把y的值在增加1
这是第三句话
第四句话
这样四个条件的判断
是不是就完成了
最终哪些是满足我们条件的
还需要一个if判断就是判断
当y的值在这一轮计算中
如果y等于3
需要一个相等的关系判断
如果y的值为3
这就是我要找的人
我把这个x的值输出后
这是我要找的解
我们把x的值输出
就直接输出x
因为这个就是我要找的
做了好事的人
这是一轮的判断
对每一个人都要执行这个过程
这个过程执行完之后没找到解
那么我要修改谁的值
我要修改x的值
试完了秦政
我要试秦明 张根 张潇
一个一个试
这是整个程序我们就完成了
我们来看它的运行结果
程序运行完之后得出x是3
也就是这事是
张根干的
这个例题就是通过循环
实现计算机问题求解的枚举方法
逐个去试
让x分别等于1 2 3 4
通过四次循环找出好事是张根干的
下面我们用二进制完成一个加法运算
假设我有两个数需要需要相加
这两个数是101
另外一个数是110
这两个数都是二进制的数
那么根据二进制加法的运算规则
那么1加0这里为1
0加1这里依然为1
而这一位上是1加1
我们说1加1的结果会产生一个进位
这里落下为0
进位落下来是1011
那么相对应的我们考虑这是
二进制的加法
对应的我们可以用十进制
做一个验算
101对应的是十进制当中的5
而110对应的是6
那么这个相加的结果就应该是11
我们来验算一下
这里是2的0次方
2的1次方
到这里是2的三次方
2的平方
那么最终这个数就应该是
1乘以2的三次方
加上1乘以2的1次方
加上1
这个结果就是8加2加1
最终为11
请大家完成这样一个练习
刚才我们考虑的是
如何把一个R进制的数
转换成十进制
因为十进制在我们
科学计算系统里是非常重要的
因为人习惯的是十进制的系统
而计算机使用的是二进制
所有十进制的运算
最终要让机器能够完成
在计算机上都要转换成二进制
下面我考虑怎么样把十进制的数
转换成二进制的数
在这个转换过程当中
整数部分和小数部分
是要分开来考虑的
我们用一个例子来说明
这个转换的过程
我希望把十进制数45转换成二进制
这是一个十进制的数
假设十进制的45转换成
二进制后是n位
表示则为B的n减1
B的n减2
一直到B的1 B0
其中每一个Bi的值要么为0
要么为1
我们把这样一个二进制数
转换成它的十进制表示
左右两端依然是相等的
得到的结果应该为
Bn减1乘以2的n减1次方
加上Bn减2
乘以2的n减2次方
加上B1乘以2的1次方
加上B0乘以2的0次方
现在我们把这个等式
左右两端分别都除以2
等式的左边除以2
得到的结果商为22
余数为1
再来看等式的右边
从权值2的1次方开始往上走
每一个数都有2的倍数
除以2之后
这一部分依然是个整数
对于上面右边除以2
右边的式子除以2
商为
B的n减1乘以2的n减2
一直加到B1为止
这是它的整数部分
余数则为B0
既然等式的左右两边相等
必定是商也相等
余数也相等
由此我们就可以推导出
B0的值为1
再往下 我们试图去求出
B1的值是同样的做法
两边继续除以2
在去掉了这个余数之后
对商为22 这两边的商继续做
除以2的动作
等式的左边变成
商为11
而余数为0
这个余数
对应的必定就是B1的值
由此我们可以推导出B1的值为0
以此类推
我们可以求出45的二进制表示
把任意一个十进制数
转换成二进制数
整数部分和小数部分
分开来考虑
整数部分就是除2取余法
下面我们看个例子
把整数47转换成二进制
按照算法 算法是除2取余
我们看一下
它转换成十进制的过程
除以2 47除以2之后
商为23 余数为1
继续每一步
现在除以2是对着商的结果
23除以2 结果是11
余数仍然为1
11继续除以2
这里大家要特别注意的就是
这个算法终止的条件是什么
我除以到
我的除2
除到什么时候为止
余数一直都记在旁边
那么现在是11除以2
商为5余数依然是1
这个过程还要继续
5除2 商为2余数为1
再往下
2除以2 得到商为1
这个时候余数为0了
这里就是特别要注意的地方
我们的除2取余的算法
并不是这个时候结束
除以2取余的算法
一定要除到商为0为止
所以现在的商是1
算法还不能终止
继续做除以2
这时候除以2之后
商为0余数为1
这样才是我们整个这个
从十进制整数
转换成二进制整数的算法
才能算是结束了
这个计算过程
把47这个整数转换成二进制的
过程就算结束了
最后我们的结果应该怎么看呢
按照我们刚才所讲的
推导出来的这个过程
得出来是它的最低位 事实上
所以我们得到的这个
47除以2得到的这个结果
应该是从下往上走
最早得出来的这个余数
实际上是它的低位
而最后出来的这个余数
则是它的高位
所以47真正转换成
二进制之后
写出来的这个二进制结果
应该是101111
所以把47这样一个十进制的数
转换成二进制
得到的结果是101111
刚才我们简单回顾了一下
十进制和二进制
日常的生活当中
还有多种多样的进制
比方说1分钟60秒是60进制
当时间走到59秒时
再下一步就是分钟加1
而秒的计时从0又重新开始
这是基于60进制
下面我们总结一下
如果我们采用的数制
有R个基本符号
我们就把这种数制叫做R进制
R则称为这种数制的基数
对于R进制而言它的运算规则
则是逢R进1
而这各种进制之间的
转换算法是重要的
尤其像我们经过
中学信息技术课的学习
相信大家都知道计算机是基于
二进制来完成运算的
而我们人所熟悉的是十进制的
十进制系统
那么学习二进制和十进制
之间的转换就非常重要
我们现在来看
任何一个R进制的数
怎么转换成十进制的数
我们用a来表示任意一个R进制的数
那么这个数它可能包含有
n位的整数部分
和m位的小数部分
n位的整数部分
小数点分开
m位的小数部分
这是一个R进制的数
那么对于R进制而言
每一位的位置不同
它所代表的权值也不一样
那么从小数点往左
这个权值每次增大R倍
把它按照权值展开
这个数得到的是
a的n减1乘以
R的n减1次方
一直加到a1
乘以R的1次方
加上a0乘以R的0次方
小数点往右
则为a的负一乘以R的负一次方
加上a的负2乘以
R的负2次方
一直加到a的负m乘以R的负m次方
我们把它用更一般的数学
公式Σ来表示
i从负的m到n减1
那么这个数的表示就应该是
aiR的a次方
这个公式就是我们把任意一个
R进制的数转换成
十进制数的转换公式
i为整数
我给大家准备了一个趣味问答
为什么数学家认为
万圣节和圣诞节是同一天呢
我们再来看小数的转换
对于一个十进制的小数0.64
我们看如何把它转换成
二进制的表示
假设它的二进制表示为
0.B负1 B负2
一直到B得负m
假设这是它的二进制的表示
我们把它展开来
则变成B负1
乘以2的负1次方
加上B的负2
乘以2的负2次方
一直加到B的负m
乘以2的负m次方
那么对于小数部分转换成二进制
算法是
两边乘以2取整
我们来看两边乘以2之后
两边都乘以2
0.64就变成了1.28
同样的等式右边乘以2之后
这个数字变成B的负1
加上B的负2乘以2的负1次方
一直加到B的负m
乘以2的负m加1
对于整式的右边而言
这是它的整数部分
而后面这是它的小数部分
既然两边相等
整数部分必定相等
小数部分也必定相等
由此我们可以得到
B的负1的值为1
那么两边都减掉这个1后
这个数字变成了0.28
等于B的负2乘以2的负一次方
一直加到B的负m
乘以2的负m加1次方
再往下算 我们求出B2是多少
继续做两边乘以2的动作
则左边变成了0.56
右边则变成了B的负2
一直加到B的负2
我们可以多写一个
B的负3一定是乘以2的负1次方
一直加到B的负M
乘以2的负m加2次方
我们看左右两边而言
在它的右边
B的负2实际上代表了它的整数部分
余下的代表它的小数部分
由此我们可以得到
整数部分必定要相等
我们得出B的负2的值为0
以此类推
我们可以从B的负1
一直求出来 求出到B的负m
看它们的值分别是多少
下面请大家完成练习
把十进制数213转换为二进制数
应该是多少
下面我们再来看二进制
二进制的基本符号
只有0和1两个基本符号
它的基本运算规则
0加上0等于0
0加上1等于1
1加上0也是1
下面来看1加上1的情况
1加1等于2
当我们这里只有两个基本
符号0和1
在这里这是二进制
它的运算基数为2意味着逢二要进1
那么这里
到达了2逢2进一
这里落下来为0
而这里变成10
1加1等于10
我们来写下一些二进制的数
我们先写上十进制的对应
1 2 3这是我写的十进制的一些数字
那么对应的我们来看
在二进制当中
它的二进制表示
应该是多少
二进制当中只能出现0和1
两个符号
十进制的1在二进制当中
依然是1
而十进制的2到了二进制的表示
就变成了
1上面加个1 逢2进1
变成了10
而3则对应着2再加1
则是11
11再加1的情况 我们来看
这个时候读的时候注意
我们读一一 不读十一
因为我读个十百千位
就表明了你是十进制的
几个基本的运算
那么这里读一一
表明这是二进制的一一
一一再加的话
1加1等于2 我们是二进制
逢2要进1
有进位下面为0 再往上
依然是1加上进位为
逢二进一之后落下为0
所以11加上1的结果是100
这是4
5是4加1 再加1变为101
再加1到6 到110
我们就从110这个数来看
前面我们讨论过
在十进制当中
每一个数所处的位置
代表的权值大小是不一样的
而在这里
类似的我们也可以
得出在二进制当中
它所处的位置不同
她所代表的权值
同样是不一样的
我们就拿110来说
那么在十进制当中
我们说每相邻两位的差距是10倍
在二进制当中
相邻两位的差距是2
在二进制当中相邻两位的比是2
最末位这里是2的0次方
中间的这位代表的是2的1次方
而最高位这里是2的平方
那么由此 我们把它展开也可以
得到110这个数是
1乘以2的平方
加上1乘以2的一次方
加上0乘以2的0次方
所以这个数转换成十进制之后
它是6
下面我们看一个带小数点的
二进制数
我们来看这个数
代表的如果是十进制的话
它应该是多少
这是二进制的101.11
按照二进制的表示当中
每一位权值的不同 我们可以知道
101第一个1代表的是2的平方
第二个1代表2的0次方
那么小数点往右
第一位1所代表的是2的负1次方
而最后一位1代表的是2的负2次方
所以经过运算 这个数应该是
4加上1加上0.5加上0.25
最终的结果是5.75
我这里有一个问题
请大家来回答
天河一号今年100岁了
到今天为止它到底运行多少年了
这个正确答案应该是c
我们说天河一号从2009年
公布开始到今天正好四年
而4这个十进制数字
用二进制表示出来刚好是100
我们今天进入一个新的单元
叫0和1的故事
今天是第一讲
介绍计算机与01表示
现代电子计算机是基于01表示的
从科学计算的角度来讲
01表示就是我们通常
所说的二进制
二进制是一种非常
古老的进位制系统
由于现代被用于电子计算机当中
于是旧貌换新颜
身价倍增
我们从以下三个方面来进行讨论
我们首先从数学的角度
来讨论进位制系统
研究各种各样的
进位制之间的转换算法
第二方面 我们从工程的角度来考虑
为什么我们的自动计算工具
我们的计算机会采用的是01表示
最后我们讨论二进制计算
固有的一些特点
我们通过分析一个案例来进行
人类的科学运算是基于
十进制为基础的
对于十进制而言
基本的计数符号
从零开始 0 1 2 3 4 5 6 7 8 9
这是十个基本的计数符号
如果这个数值逐步增大的话
那么我们通过这些基本
符号的组合
来记录下数值的大小
比方说437
各种各样的数值都是
这10个基本符号的组合
比方说这样一个数365.32
那么在这个数的表示当中
出现了两个相同的计数符号
都是三但这两个三
处在这个数的位置不同
它所代表的数值大小是不一样的
小数点往左
5的位置的权值是10的0次方
六的位置的权值为10的1次方
而三的位置的权值为10的平方
小数点往右
0.3表示的是三个0.1
也就是三个10的负1次方
2所在位置的权值为10的负2次方
所以这个数我们可以这样表示
可以把它写成3乘以100
加上6乘以10
加上5乘以10的零次方
再加上3乘以10的负1次方
加上2乘以10的负2次方
那么这样 这个数值的大小
就是365.32
十进制加法的基本运算规则是
逢10进1
那么10在十进制当中是
非常特别的数
我们把这个数叫做
十进制的基数
现在我们考虑一个小数
一个纯小数 这个小数是0.6875
我希望把它 这是一个十进制的数
一个十进制的小数0.6875
我希望把它转换成一个二进制的小数
按照我们刚才说明它的算法
这个算法应该是
乘2取整的算法
我们来看下乘2取整的过程
该是怎么样进行的
这个数是0.6875
乘以2直接的结果
就每一步都做乘以2的动作
这个数乘以2之后
它的结果是1.375
你乘出来的这个整数
现在要把它拿掉了
那么下次再乘的时候就不考虑
这个整数部分了
那么乘2取整的过程继续要进行
那么这里得到的结果就是0.75
依然要进行
每一步实际上都要做乘以2的动作
0.75乘以2
得到的结果是1.5
继续乘以2 这个时候乘以2
我们刚才强调过了
是对着它的纯小数部分
所以得到的结果是1.0
乘以2的过程 继续进行下去
没有太大的意义
因为我的纯小数部分已经变成0了
那么再往下乘
它也是0 这个结果就变成了0
这里特别要注意的
就是跟除2取余
整数转换成二进制的过程
不相同的地方
或者说正好相反的地方
这个时候最早出来的1
最早出来的整数的部分
事实上是把一个
十进制的纯小数
转换成二进制的纯小数
是它的最高位
我们刚才在除以2取余时候
我们说这个取得过程是从下往上
最晚出来是最高位
而在小数部分我们得到的是
最早出来是最高位
所以这个取得过程是从上往下取
0.6875它的小数表示就应该是
它的二进制的小数表示
就应该是0.1011
这样我们就得到了0.6875
这是我们的十进制数
它转换成二进制之后
结果是0.1011
这代表着一类纯小数转换成
二进制的纯小数的过程
我们再来看怎么样把
十进制的小数0.64转换成二进制
我们刚才总结了算法是
乘2取整法
乘以2之后1.28得到了二进制的表示
它的最高位为1
剩下是0.28乘以2
0.56它的最高位0
1.12继续乘以2
0.24再继续乘0.48
很多同学是不是已经发现
这个乘2取整的过程
是一直可以持续下去的
所以对于十进制这个0.64而言
我们找不到完全等价的二进制表示
我们只能说按照精度
我取它的一定的位数
这个时候0.64二进制表示
只能约等于0.101
对于小数而言
并不一定都能找到等价的转换
对于十进制的小数
不一定找到等价二进制表示方法
下面我们来看 为什么
对于一个很简单的十进制小数
我用二进制都无法
找到非常准确的表示
为什么计算机当中
依然采用的是01的表示呢
用01表示来完成
信息的表示和处理
有些什么优势呢
答案为A
下面给大家介绍一个
小工具
在windows操作系统当中
都有计算器
在附件当中有计算器
那么在计算器的查看菜单当中
有两个选项
一个是标准型 一个是科学型
打开科学型
那么大家可以看到
上面有很多进制
这个计算器是可以完成
十进制和二进制之间的转换算法的
我们可以验证一下213的
对于十进制的213
它的二进制表示应该为
1101 0101
也就是我们这里这个选择的A项
大家要从进制的角度
从数学的角度来看
不要想着这是10月31号
12月25号这是
八进制的31和十进制的25
我们来看
八进制的31
按照刚才我们所总结的
R进制转换成
十进制的算法
它就应该等于
按权值
一次展开再相加
那么三乘以八的一次方
加上1乘以8的0次方
所以这个数展开之后
应该是24加1
按照十进制的加法
得到的就是十进制的25
对于这个问题选择是D
上面ABC三个说的
都不正确
数据是使用01表示的
我们在讲信息编码的时候
介绍过
程序使用的是ASCII编码
这句话是错的
再讲计算机组成
工作原理的时候我们介绍过
一个计算机软件要运行
首先要进入内存
无论是程序还是数据
放在内存当中
使用的都是01的表示
程序是软件
数据也同样是软件
cpu可以理解数据
也可以理解程序
计算机系统包括软件和硬件
在1946年第一台电子数字计算机
Eniac诞生的时候
Eniac通常把它叫做
健忘的神童
它并不是一个标准的
存储程序计算机
EDSAC问世的时候由于没有程序
并不能解决实际问题
直到8个月之后
设计者才使得它能够运行起来
这让人们充分认识到了计算机
吃软不吃硬的怪脾气
最早的计算机没有软硬件的划分
软硬件的明确划分在1969年
IBM耗资50亿美元的IBM360
系统电脑获得空前的成功之后
宣布自1970年1月1日起
IBM的电脑产品
不再含混的分为
电子元件硬件设备
外部设备
操作系统程序等类
而只是分为两大类
软件和硬件
软件和硬件
部分分开计价
由此也就形成了
我们现在所说的
计算机系统的
两个重要组成部分
一个是电子机械装置
硬件部分
另一个就是程序和数据
所组成的软件部分
软硬件的明确划分并不是想说
软件硬件是水火不相容的
事实上
计算系统最终要能够
完成很多计算任务
需要软件硬件协同一起
共同来承担计算任务
在计算机
总体设计和基础元件的
制造当中
清一色都是男性的设计
但在软件方面
却是巾帼不让须眉
这一部分我们要介绍一些
在计算机软件的发展当中
有过突出贡献的女性人物
第一位我们要介绍的人物是
艾达拜伦
相信大家还记得查尔斯巴贝奇
我们一直再说
自动计算的思想
来源于查尔斯巴贝奇
从1842年开始
Ada从事了一项
开创性的工作
她试图为
巴贝奇所设计的分析机
编写指令编写程序
所以我们经常会说
Ada是世界上第一位程序员
为了纪念这一位计算机程序的先驱
计算机界
把一种结构性的
程序设计语音
命名为Ada
格里斯霍普
第一位女性少将
她参加了
美国海军mark1号的设计
她的主要贡献集中在
程序设计语言与编译器领域
为了纪念格里斯霍普
软件方面的杰出贡献
计算机界设立了
格里斯霍普奖
到目前为止女性的
图灵奖得主有三位
2006年的图灵奖
颁给了
IBM的终身院士
Frances E.Allen
她的主要贡献是在
编译器理论方面
2009年的图灵奖
颁给了
麻省理工学院的
Barbare Liskov
Barbare Liskov
是美国历史上
第一个获得计算机博士的女性
她的主要贡献是在
面向对象程序开发方面
2012年的图灵奖
则颁给了同样在
麻省理工学院工作的
Shafi Goldwasser
她的主要贡献是在密码学方面
软件这个词的英文是
Softwarw
指的是一系列按照特定顺序
组织的电脑数据
和指令的集合
在计算机系统当中
有着各种各样的软件
通常情况下
我们把这些软件分成两大类
一类是系统软件
一类是应用软件
系统软件主要面向计算机
管理计算机的硬件资源
我们有最重要的系统软件
就是操作系统
另外一些系统工具和编译器
也属于系统软件
像我们
熟知的windows
Linux
这些都是操作系统属于系统软件
应用软件主要是面向用户的
帮助用户
来完成一些任务来使用计算机
完成计算任务
常见的应用软件
包括文字处理软件
我要书写文档
我要制作图表使用文字处理软件
我要上网浏览我们则需要浏览器
这是一类支持你
进行上网进行Web浏览的软件
刚才我们提到
软件就是程序和数据
组合在一起我们把它叫做软件
程序和数据有何不同
我在下面列了四个选项
接下来用lego小车来体验一下
存储程序控制的
计算机基本工作原理
为什么计算机有了CPU
我们说是有了大脑
程序才是灵魂
这个lego小车完成自动计算
核心部件是白色长方形的东西
叫做NXT
是lego小车的大脑
并不是说有了CPU有了大脑
就可以完成操作完成运算
核心思想还是要讲
程序才是灵魂
这台机子摆在这里虽然我有轮子
我有大脑是不是就可以前进了呢
一定要对它编程给它程序
它才有可能完成它的任务
下面通过让这个小车
行走一段距离前进一段距离
来体验整个计算系统
是如何一块来协同工作
而在这中间为什么又说程序是灵魂
为什么说基本的工作原理
是存储程序
再加上由程序控制呢
这个小车有轮子 有CPU
通过一些连线把它连接在一起
这只是它具备了完整的
能够行走的硬件
真正使这个小车动起来
还有一些工作要做
使用ROBOTC来对小车进行编程
最终希望它能动起来
我们来看看使小车动起来的流程
应该是怎样的
首先小车上就像计算机买回来
首先要安装操作系统一样
这台小车上也要首先安装
操作系统
安装完操作系统之后我希望
编写我自己的程序来
让这个小车动起来
新建一个文件
我希望使这个小车动起来
它自动的帮我写好了
一个程序的框架
这个程序的框架是task main
下面我们让这个小车动起来
无非就是它的两个马达
给它同样的力度让它一起前进
两个马达连在了ab端口我们来看
给a端口的马达50的力度
给b端口的马达也是50的力度
给了力度之后希望它们
以这个速度前进一段时间
我们以毫秒为单位的话
我们让它前进一千毫秒
这就是我用这个环境完成
编程的一个过程
剩下的事情
就是我在台式机上所完成的这段程序
最终要交给这个机器人
交给这个智能小车
它才能完成这个动作
那么你可以看到我们下面要
做的工作就是要编译
把这段代码编译成这台
机器小车可以理解的01序列
这个编译工作是在
台式机上来完成的
是由RobotC这个计算环境来完成的
通过编译之后
就把这个程序下载
到这个小车上
这个下载是通过
小车与计算机直接的这个连接是
通过蓝牙进行
通过蓝牙把这段程序
下载在这个小车当中
这个小车上的核心运算部件
就是这个长方形的白的的东西
我们把它叫做
NXT
这个NXT大家可以看一下
它的上下两侧
有很多连接的端口
可以看到这里有很多连接的端口
那么
下面的这四个端口
是用来连接输入的
可以连接各种各样的传感器
我可以给它连接声音
传感器光电传感器
作为这一台小的
智能机器人的电脑的输入
那么同时对于这个智能机器人
对于这个lego小车
我还有一些输出
输出主要是指的马达
我要给小车
从这个cpu输出我可以给马达
一些电力给它一些力度
让它以一定的力度前进
这是它的输出表现出来
会表现出让机器小车
能表现出一些的动作
我现在的连接是
输入点没有连接任何传感器
对于输出端口我们通过AB
两个端口连接了两个马达
我现在的任务就是我希望给
这两个马达一定的力度
使得它能够沿着一定的速度前进
那么现在我这个小车
不但有了它自己的操作系统
也有了程序
有了它可以读懂的
程序代码这个代码是已经
编译好的0101的序列
那么现在我们来看
它的执行过程是怎样的
它是不是能够按照我们
刚才写的这个程序完成任务
我们先让这个小车来运行来看
所以我们讲的计算机的基本功作原理
是存储程序控制
实际上这是两层含义
一层含义首先是
计算机要有手段
存放计算的过程
和步骤也就是我们讲的存储程序
也就是这个小车我们在演示的时候
我们进行了编程
最终把程序下载编译
编译之后把它下载到
这个小车的部分
这是我们讲的存储程序的含义
那么第二层含义就是有了这个程序之后
整个计算机的工作
是在程序的控制下来完成
计算机工作原理两句话
一个是存储程序
一个是程序控制
而这个小车在我把程序
去下载到这个车上之后
那么在往下运行就是
只要选择这个程序
那么整个运行就按照这个
程序所规定的来运行
像我们刚才所定义的
我就是给了它马达一定的力度
让它前进的
一千毫秒也就是一秒钟
就是我们讲为什么程序
是一个灵魂就是没有这个程序
计算机
对于计算机而言
有了cpu就是有了大脑
但是有了程序才有了灵魂
同样也通过这个程序
这个计算机才具备了
通用性我需要改
使得计算机完成不同的功能
那我就需要编写不同的程序
只要改动这个程序
运行这个程序
那么这个机器就会
按照它所给出的指令
一步一步的去完成这个操作
这是我的同事周丽涛
所制作的一个flash动画
通过动画我们来看一看
如何完成加法的操作
这个式子写在这里指的是
我要完成a加b的操作
然后把这个运算结果送给c
我们来看一看
完成这个动作
计算机主要部件之间是如何
进行协同工作的
在这个动画当中主要是
画了一个CPU
希望通过CPU的内部运行
我们来看c等于a加b
它是如何完成计算的
这个CPU的内部当中可以看到
包含有冯诺依曼体系结构当中
的两大部件一个是控制单元
一个是算术逻辑单元
算术逻辑单元又进行了
一层的细化
包括加法器
还有寄存器
整个CPU中也有一个寄存器
不管寄存器还是寄存器组
最终都是用来暂存数据的
数据要完成运算
需要一些地方暂时存放一下
在CPU内部有很多这样的寄存器
那么CPU完成运算
它的指令和数据都来自于内存
在这里写的是主存就是内存
大家可以看到ab都来自于内存
最终通过指令译码
知道它要完成加法的操作
a首先进入了加法器
b暂时存放在寄存器当中
通过算术逻辑单元完成
加法运算得到c之后
c首先
存放到了寄存器组
然后通过主存交换数据
把c输出到主存储器当中
我们来看一条指令的执行过程
就是指令周期的概念
一条指令的执行周期
从取指令开始
取指令 分析指令 执行指令
最后一步完成执行指令之后
指令计数器的递增
指令计数器是用来记载
我的指令现在执行到了哪条
下一条指令应该
从哪个位置去指令来进行运行
每一条指令执行完之后
指令计数器都有递增的动作
每一条指令的执行过程
包括了四个部分
第一取指令 第二分析指令
第三执行指令
第四是指令计数器递增
从这可以看出
左侧的图给出了一个
CPU的典型组合
CPU中首先有控制单元
有算术逻辑单元
还有很多的寄存器组
就是Register
寄存器组是用来暂存数据的
那我们现在来看有了硬件设计
有了冯诺依曼体系结构之后
整个计算机运转
的基本工作原理
我们把它叫做存储程序控制
那么这里面核心的思想
就是程序一词
在日常生活当中我们会
碰到各种各样的程序
运动会的安排是程序
没有程序比赛过程就会乱套
所有的运动赛完了
程序执行也就结束了
演唱会一台晚会的节目也是程序
所有节目演完了
程序执行也就结束了
新生入学报到的手续
也是一种程序
报到的手续办完了整个程序的
执行也就结束了
在这些地方程序
表示的都是按时间
先后次序
出现的事物
有时候人们用程序来表示处理
或工作的步骤
那么一部计算机发展
的历史就可以看作是计算机
程序精彩纷呈
层出不穷的历史
也是用程序
如何去调教计算机
让它为人类而工作的一部历史
我们来看一个很简单的例子
大家每天早上要去上学
看我们上学准备的这个程序
应该是怎样的
我的问题是希望你能做好上学的准备
你要完成的工作包括这些
请你排好一个程序
来完成所有的这五项上学准备的工作
那么这个程序就应该是
醒来 起床 洗漱 着装 吃早餐
通过这个例子希望大家能够
体会程序当中这个序
是非常重要的概念
同样我们在计算机当中也有程序
那么顺序程序是一类非常重要的
程序控制结构
我们再来看计算机当中的程序
那么计算机的本能就是能够
识别并且执行属于它
自己的一组机器指令
以此我们可以说
程序就是完成既定
任务的一组指令序列
那么计算机按照程序规定的流程
依次执行一条一条的指令
最终完成程序所要实现的目标
计算机的硬件系统最终
只能执行由机器指令组成的程序
那么大家在高中的信息技术课
中应该已经学过
计算机的硬件系统
它的工作原理是基于01表示
最根本的运算是二进制
所以我们可以说计算机的
母语是什么计算机的母语
就是0101
最终的指令
都是由0101所编好的
一组一组的01代码
那么程序我们刚才提到过
程序在执行之前
那么执行意味着我要使用CUP
在执行之前必须首先要装入内存
那么程序执行的时候CUP
负责从内存当中
逐条的去取出指令分析
识别指令最后来执行指令从而
从而完成了一条指令的执行周期
那么CUP本身就是这样周而
复始的工作直到程序的完成
刚才我们提到的0101指令
实际上是对指令
是指对计算机进行程序控制的最小单位
所有指令的集合称为计算机的指令系统
那么对于一条典型的指令而言
它包含有两个组成部分
这是机器指令的格式
指令当中首先要指明的是
我要执行什么样的操作
这就是机器指令格式当中
非常重要的一部分我们把叫做操作码
你要先告诉我
你要执行一个怎么样的操作
你是做加法 做减法
还是做数据传输
你先通过操作码来说明这件事
第二个
在机器指令当中需要指明的
就是你的操作数
你要做一个加法运算那么
谁来做这个加法运算
操作数据有的时候可能是
一个 两个或者是多个
操作码规定了机器
要执行什么样的操作
而操作数则指明了
这些操作
这个操作是建立在那些数据上的
程序则是一组指令的集合
指的是为完成一项特定任务
而用某种语言编写的
一组指令序列
计算机的这种工作模式
我们就把它叫做存储程序控制
这也是计算机工作的一个基本原理
存储程序控制这个计算机
工作的基本原理
也就决定了人们
使用计算机的一个基本模式
就是编写程序
然后再运行程序
计算机具备的两个基本能力
一个是能够存储程序
就是在程序  在计算机 计算工具
在计算装置运行过程当中
要有办法存储程序
第二个就是有了这样的程序之后
能够自动的按照指令顺序
或者自动的执行程序
计算机的存储程序控制
工作原理也就决定了
计算机的工作模式
就是编写程序和运行程序
这些程序有的是你个人编写的
有的是软件公司提供的
是你购买的
如果CPU是计算机的大脑的话
那么程序就是计算机的灵魂
我们通过编写程序
去处理我们的数据
这些数据包括图形 视频 音乐和文档
同样是这些程序
使得我们的CPU
使得我们同一套
电子机械装置
能够完成不同的任务
而计算机程序设计
也成为了21世纪
一项重要的基本技能
我们前面提到的机器语言和汇编语言
那么大家可能也能体会到
用机器语言和汇编语言
编程有多么的困难
在使用机器语言和
汇编语言编程的时候
你必须要理解
每一个CPU的指令集合
正是由于用机器语言和汇编语言
在编程上有一定的难度
所以人们又发明了
很多高级的程序设计语言
那到底什么是高级的
计算机程序设计语言
计算机程序设计的高级语言
对计算机而言是足够精确的
同时对人而言是容易理解的
在计算机当中我们把它
叫做可读性比较好
对于计算机而言人机之间
进行交互我们说基于
计算机程序设计语言
而计算机的程序设计语言
可能有成百上千种
但是从根本上来说
这所有语言的程序设计能力是等价的
计算机程序设计的高级语言是
独立于CPU的
它一般不包含于任何特定
CPU指令相关的内容
这给人的编程带来了很大的方便
但是我们也知道计算机的母语
是基于01表示的
所以要使得计算机能够
按照你用高级语言编写的程序
能够运行
我们首先需要的是要把
高级语言翻译成机器语言
不同的程序设计语言有它各自的特点
在表现形式上也有很多不同
这要体现在语法和语义两个层次上
这是pascal的赋值语句
我们下面这一条是c语言的语句
你可以看到它们在语法规定上
是略有不同的
而计算机语言跟人所熟悉的语言
在表达上是由一些差别的
其中一个差别就在于
人的表达如果你在跟人进行
交流的过程当中
有的小的错误
可能并不影响你整个意愿的表达
但对于计算机而言
任何一个小的错误
你少一个分号少一个冒号
都会导致这个程序的运行
发生错误
而对计算机而言
它是非常确定的非常明确的
任何一个小的错误
都可能导致计算机无法运行
那么不同的语言
它在语义的表达上也是不相同
就是刚才我们用lego机器人的时候
编写的一段RobotC的代码
这个时候编写的代码
我们就把它叫做源代码
这段代码在我们使用
RobotC编辑环境输入结束之后
在小车能够运行之前
我们首先完成的工作
就是编译和下载
这个编译工作
就是指的把一段c的代码
把这段类似于c的代码
把它编译成了这台小车
能够理解的0101的表示
所以我们首先要区分的概念
就是源代码和目标代码
这里左侧的类似于c的表达
就是我们的源代码
右侧的这个01表示就是目标代码
把我们刚才所编写的
类似于c的这段RobotC程序
把它翻译成0101
那么工作不是由人来做的
而是由计算机上一个
自动的程序来完成
这个程序我们就把它叫做编译器
同样能完成
另外一种完成翻译工作的形式
我们把它叫做解释器
那么解释器跟编译器略有不同
编译执行的方式指的是你把
大段大段的程序
编辑完成之后
对整个的程序进行翻译
翻译之后会形成目标代码
而解释执行则不一样
它不是按整个程序
不是你整个程序完成编程之后
才进行翻译工作
而是一条一条语句
边编辑 边翻译 边执行
最终并没有执行
独立的目标代码的文件
在计算机编程的过程当中
有时候我们把组成计算机程序的指令
都叫做代码
那么程序可大可小
完全取决于你
希望计算机编程
来完成什么样的任务
那么大到它可以包含
几百万行的代码
有程序员有专门的软件公司开发
我们可以对比一下
高级语言程序与低级语言程序
在编码方式上的不同
这幅图片左侧的就是
高级语言的代码即pascal语言
而右边的代码则是由汇编语言
所完成的同样的操作
你可以看到
用汇编语言编写的程序你
必须了解
机器的指令集合必须要了解机器的硬件
即使是用汇编语言所写的程序
如果要按计算机运行同样要完成
一个翻译工作把它翻译成0101的代码
完成这个翻译工作的程序
把它叫做汇编程序
前面我们介绍了
计算机的程序设计语言
我们介绍了程序
计算机的语言分成两大类
一类是低级语言
一类是高级语言
严格来讲只有汇编语言和
机器语言算低级语言
说语言低级并不是能力欠缺
功能欠缺
而只是在你编程的过程当中
要跟机器的硬件打交道
要跟CPU的指令集合打交道
最后我们来看一个问题
下列各项中与众不同的是
在所有五项当中
有四项都是应用程序
只有E选项阿凡达是
一部电影的名字
所以与众不同的选择是E
按照计算机所采用的基本原件
我们说计算机的发展经历了四个阶段
第一代电子计算机
是电子管计算机
那么它才用主要元器件是真空电子管
那么这一代计算机的一切操作
包括输入输出在内
都由中央处理机集中控制
那么这个时候的计算机
主要用于科学计算
而随着晶体管的发明
晶体管在计算机的研制当中
也取代了电子管
这就是我们说的第二代电子计算机
它使得计算机的体积大大减小
同时寿命延长价格降低
为电子计算机的广泛运用创造了条件
那么第二代电子计算机使用
晶体管制造的计算机
使用了晶体管以后
电子线路的结构大大改观
那么制造高速电子计算机的设想
也就更容易实现了
那么随着集成电路的发明
第三代电子计算机是
使用了集成电路的计算机
那么集成电路包含的元器件的数量
一到两年翻一番的速度在增长
那么发展到70年代初期
大部分电路元件都已经
以集成电路的形式出现
甚至在拇指指甲那样大的
约一平方厘米的芯片上
就可以集成上百万个电子器件
这样我们也就进入了
第四代计算机
那么这个时候的集成电路
我们把它叫做大规模集成电路
那么在计算机的发展历程当中
一共这个划代
按照它所组成的元器件的不同
我们一共把它划分成了四代
而四代之后我们不再对计算机进行划代
而第五代计算机在计算机
而第五代计算机它是有明确的指代的
由于人工智能的迅猛发展
日本有一个非常庞大的
野心勃勃的计划
就是要制造人工智能计算机
他把这个机器叫做了第五代计算机
你可能听过计算机的发展
遵循了摩尔定律
那么什么是摩尔定律呢
戈登摩尔是英特尔公司的创始人之一
那么戈登摩尔在一九六五年准备一个
关于一个计算机
存储器发展趋势报告的时候
他整理了一些数据
那么在他绘制这个数据表的时候
发现了一个惊人的趋势
这个趋势说的是每个芯片上
每一个新芯片
大体上包含其前任
两倍的容量
那么每个芯片的生产也是在前一个芯片
产生之后的十八到二十四个月之内
如果这个趋势
持续的话
计算能力相对于时间周期
将呈现一个指数形式的上升
他的这个观察资料
就是我们现在所说的摩尔定律
这个定律说的就是在价格不变的时候
集成电路上可容纳的晶体管数目
约每隔二十四个月就会增加一倍
那么后来这个时间被修订为十八个月
摩尔定律是计算机发展的一个经验定律
那么考虑一九六五年
电子元器件的发展程度
那么那个时候一个芯片上
可能只能集成几十个部件
当时很多人把摩尔的预测
看作是一种神话
虽然摩尔所预测的这个发展速度
令人难以置信
但是几十年以来IT行业的发展
始终遵循着摩尔定律预测的速度
也可以说摩尔定律在很长一段时间之内
主导着这计算机行业的发展
一九六五年的时候集成电路刚刚问世七年
那么当时也只有几十只元器件
来集成在一个芯片上
摩尔当时的预言听起来
好像是科幻小说
那么此后也不断有专家认为
芯片集成的密度
已经到顶
但以后的事实证明
摩尔的预言是正确的
那么摩尔定律
所阐述的发展趋势
一直延续到今天
成为计算机界的黄金定律
摩尔定律反应了集成电路的发展趋势
它的发展速度是相当快的
摩尔定律延伸开来主要有以下三种版本
那么第一个版本说的是
集成电路芯片上
所集成的电路的数目
每隔十八个月就翻一番
无论是你的处理器芯片
那么意味着电子元器件数目的增加
带来计算能力的增强
那么另外一个角度
作为存储器芯片而言所集成的
集成度的提高
带来了存储能力的增强
换句话说
我的计算速度计算能力
每十八个月就翻一番
而我的存储容量也可以做到
每十八个月就翻一番
那么第二个版本说的则是
微处理器的性能每隔十八个月提高一倍
而价格相对的就下降了一半
第三个版本
则是说用一个美元能买到的电脑性能
每隔十八个月翻一番
这是经济学上的摩尔定律
那么在电子管的发明之后
电子元器件取得了迅猛发展
一九四七年底贝尔实验室
研制出了可以替代电子管的晶体管
晶体管能够完成电子管的一切工作
而且又解决了真空管本身带来的缺点
性能也更加稳定
晶体管发明者获得了诺贝尔物理学奖
那么晶体管的优点在于
它更小更便宜
晶体管与电子管比更小更便宜耗能也低
同时带来的优点是更可靠更稳定
那么我们对比晶体管和电子管
用一个简单的事例来说明
二十年代的助听器由于使用了电子管
它的重量可以达到十六磅
那么晶体管的发明马上使它变成了
火柴杆的大小而得以放进了耳朵里
这就是我们讲的晶体管是
电子恐龙的缩骨法
那么电子元器件的迅猛发展
它体现在集成电路的发明上
一九五八年的九月
德州仪器公司的工程师
在一个大拇指盖大小的
锗晶片上
放置了五个原件其中有四个是晶体管
那么在晶体管的发明之前是很难想像
把各种元器件组合在这么小的地方的
晶体管出现之后
那么集成电路改变了
晶体管电阻电容器以及导线各行其是
而把它们组织到一起
形成了集成电路
随着技术的进步
硅晶片越来越小也越来越薄
而在上面的晶体管数目和管线则越来越多
从这个方面我们可以看到
集成电路上所集成的
晶体管数目增加的速度
那么这个最早的四零零四这个芯片上
集成了两千三百个晶体管
而到了酷睿双核
这个集成晶体管的数目则
达到了两亿九千万个
我们还可以从元器件之间的间隔距离
来体会集成度
那么在ENIAC机器上
元器件之间的间隔是五厘米
而到了一九七二年
四零零四微处理器芯片
这个间距则是十微米
我们回顾一下计量单位
我们有毫米有毫秒有毫
我们一般用M来表示
表示的是十的负三次方
那如果毫还不够小的话我们还有微米
这个表示一般用U来表示
代表这个数量集是十的负六次方
那么再往下则到了纳这个级别
用N来表示纳则代表是十的负九次方
所以我们通常讲的十毫米
指的是十的负三次方米
十微米 微米则指的是
十的负六次方米
而纳米则指的是十的负九次方米
到了一九七四年八零八零微处理器芯片
元器件之间的间隔距离
平均为六微米
而现在我们早已进入了纳米级别
这个图片上给出的就是一个
六十五纳米的芯片
自动计算的发展从算盘的手动计算
到机械计算 到电动计算
直到电子数字计算机的发明
很多科学家所处了突出的努力和贡献
我们在计算机发展的这个历程当中
只能有选择性的介绍一些
对计算机科学发展
具有影响力的事件
如果你对计算机发展有兴趣
那么计算机学院还开有关于
计算机发展史的选修课程
那么下面我们就选择一些有代表性的事件
来进行介绍
一八八四年美国的工程师赫尔曼霍雷斯
制造了第一台电动计算机
他采用的是穿孔卡片
和弱电流技术进行数据处理
那么这台电动计算机是用于
美国的人口普查的
它在人口普查中大显了身手
美国哈佛大学应用数学教授
霍华德阿肯受巴贝奇思想的启发
在一九三七年得到了
美国海军部的经费支持
开始设计马克一号
那么这个项目是由IBM来承建
于一九四四年交付使用
马克一号采用的全是继电器
长五十一英尺高八英尺
看上去像一节列车
它有七十五万个零部件
里面的各种导线加起来总长有五百英里
总耗资是五十万美元
马克一号的计算速度
在做乘法运算的时候一次最多需要六秒
除法十多秒
运算速度并不是特别快
但是它的运算精度非常高
能够达到小数点之后二十三位
虽然马克一号是一种自动计算
采用的是继电器
但是我们并不把它看成是
第一台电子数字计算机
第一台电子数字计算机我们认为是ENIAC
那么虽然马克一号跟ENIAC的建成时间
相距并不远
但是在技术的采用上相距比较大
ENIAC采用了电子管技术
而马克一号用的是继电器
ENIAC的全称是
电子数字积分计算机
一九四二年在宾夕法尼亚大学
任教的莫克利
提出了用电子管组成计算机的设想
这一方案得到了
美国陆军弹道研究所的关注
那么当时正是第二次世界大战之际
新武器的研制过程当中
弹道问题涉及许多复杂的计算
单靠手工运算已经远远满足不了要求
急需自动计算的机器
于是就在美国陆军部的资助下
于一九四三年开始了ENIAC的研制
那么这台机子是在一九四六年完成的
当时它的功能确实是出类拔萃的
它可以在一秒钟之内进行
五千次加法运算三百次乘法运算
那么与手工计算相比速度加快了许多
原来六十秒钟射程的弹道计算
需要人工是二十分钟的时间
由ENIAC来计算三十秒就可以结束了
但是它的体积是非常庞大的
占地超过了一百七十个平方
它的组成元器件上包括
一万八千个电子管
还有一千五百个继电器
七万只电阻以及其它各类的电器元件
所以运行起来耗电量也是非常巨大的
另外它的存储容量很小
只能存二十个字长为十位的十进制数
而且是用线路连接的方法来编排程序
因此每一次解题都需要靠
人工来改接连线
在算题的时候准备的时间
大大的要超过实际计算的时间
尽管如此ENIAC的研制成功
还是为以后计算机科学的发展提供了契机
而每克服它的一个缺点
都对计算机的发展带来了很大的影响
那么可以看得出来ENIAC在工作的时候
ENIAC这台计算机的工作模式
跟我们现在所认识的计算机
可以说是完全不一样的
你看不到它的鼠标看不到它的键盘
人们工作需要解题
那么你要到机房里去
通过搬动六千个开关来进行
ENIAC本身是一个独一无二的设计
从来都没有被复制过
一九四三年设计的冻结意味着
这台计算机的设计在某些方面缺乏创新
发展得并不好
尤其是缺乏存储程序的能力
ENIAC的主要组成元器件是电子管
而在电子管的发明之后
电子元器件取得了迅猛的发展
这些发展给计算机带来了翻天覆地的变化
ENIAC有超过一万八千个
各种类型的电子管
为了解决电子管本身散热大的问题
ENIAC的工作现场出现了这样一番景象
两台十二匹马力的鼓风机
一旦是ENIAC开始算题了
它就会以每分钟
六百立方英尺气流的强风吹个不停
而在计算的关键部件上都挂上了
温度计调节器和恒温器
用来降温
我们又回到超级计算机
超级计算机又叫做巨型机
那么巨型机指的是运算速度非常快
可以达到每秒几千亿次
乃至几万亿次千万亿次
运算速度的超级计算机
而一个国家巨型机的发展水平
我们也把它看作是这个国家
科技发展水平的重要标志
为什么这样说在于
我们所涉及的个人计算
你可能觉得我有一个个人电脑就足够了
但是大规模的科学运算
事关国计民生的一些行业
你比如说天气预报
像一些国防的尖端技术像石油
和地质勘探 卫星图像处理
这些领域都是需要大量科学计算的
高科技领域
我不知道大家有没有感觉
我是有很清晰的感觉就是
天气预报越来越准了越来越靠谱了
为什么现在超级计算
而在天气预报这个领域
我要算出精确的要能够精确的预报出
未来三天未来一个星期
甚至未来一个月半个月的这个
天气情况 需要分析
计算大量的卫星云图
这是大规模的数据
这是个人电脑所不能承担的
一定是巨型机 一定是超级计算机
那么事实上很多国家都竞相投入巨资
来开发速度更快性能更强的超级计算机
巨型机的研制水平生产能力以及应用程度
已经成为衡量一个国家
经济实力科技水平的重要标志
那么大家可能知道
国防科大是以超级计算机而文明的
全球超级计算机五百强
每年上下半年各排名一次
这是最新的
二零一三年六月份所出来的排名情况
那么排名第一的
国防科技大学
是我们学校研制的天河二号计算机
你可以看到它的运算速度达到了每秒
三十三点八六千万亿次
那么这个千万亿就是我们介绍的PETA
而三十三点八六PETA次运算速度
排名第二的是美国的泰坦
而我们的天河一号计算机
在两千零九年也曾经排名世界第一
二零零九年天河一号
排名第一
它的当时的运算速度是二点五七PETA次
而四年之后
而二零一三年我们再次排名第一
这个运算速度已经达到了
三十三点八六PETA次
从这里大家也可以体会到
计算机的飞快的发展速度
从另一个角度也验证了
摩尔定律的准确性
我们国家的超级计算机排名世界第一
这是非常令人鼓舞的
同时我也想提醒大家
越是在国家飞速发展的时候
你可能越要注意
作为科技工作者着也要清醒的认识到
与国外相比我们还存在着哪些差距
那么在本次五百强的排名当中
中国大陆上榜的机器数目是六十五个
而美国
则有二百五十三台机器上榜
由此我们计算出
中国大陆的运算速度总和
是二百二十三PETA次每秒
那么这相比
半年前的五百强
这个运算速度是有了一个提高的
但是这个时候我们也要看到我们
事实上跟一流的国家
比方说跟美国之间
在计算能力上计算速度上
我们在总的
计算能力上还有着一定的差距
那么我们用两张大的图片
一张图片讲的是
可以看到计算机对整个社会经济
对全球的影响
那么从这张图明显可以看到
计算机对人类社会
对人类之间的关系
对国家之间的关系
对人与人之间关系的影响
人类有史以来
也从来没有一种广泛使用的工具
更新的速度像计算机这么快
那么下面我们来从超级计算机的角度
来体会一下计算机的发展速度
我们在介绍这个发展速度之前
先学习一些计量单位
如果描述这个每秒做多少次运算
由于发展速度的加快 这个次数越来越多
我需要一些计量单位来进行描述
我们用KILO也就是大写的K来表示
二的十次方
一零二四 这是一个计量的单位
那一零二四只是大概的等于千
K这个词在英文当中本身代表的就是千
而在计算机科学当中
一K则代表的是二的十次方一零二四
而每一个计量单位之间的差别
都是二的十次方
也就是近似的等于十的三次方
用一M来表示
一零二四K
而用一个G来表示一零二四兆
一M我们叫做一兆
一兆来表示一零二四K
一G则是一千零二十四兆
那么如果你的速度再快我们说到TERA
一T等于一零二四G
它代表的是二的四十次方
近似的等于十的十二次方 也就是万亿
再快我们还有PETA
一P等于一零二四T代表的是二的五十次方
现在大家已经知道这个PETA
因为现在的计算速度
就已经到了PETA这个级别
那么如果计算速度再快再往上
二的六十次方 我们还有一E
这张图当中我们可以看到
我们现在的计算速度
世界上最快的计算机达到了PETA这个级别
你可以看到他每秒钟可以完成的运算速度
那么刚才我们提到
在我们讲这个计量单位的时候
实际上是沿用了
我们在科学运算当中
原来使用的一些计量单位 比如K M G
分别实际上在
在科学计算当中他们代表的是十的三次方
而在计算机科学当中我们
实际上用K来代表二的十次方
它并不完全等同于原来K的含义
所以在一九九九年的一月电工委员会
又引入了
Kibi Mebi Gibi等词头
以及同样的缩写符号
原有的缩写符号加上I
来精确的表示
二的十次方二的二十次方二的几十次方
你要清楚的是在计算机科学当中
谈论K
指的是二的十次方事实上应该用KI来表示
然而我们说
这套计量单位由于缺少官方的支持
所以很多人都还继续使用原来
国际的计量单位
常用的图像文件格式
刚才看了一种是JPEG
JPEG之前还有一种是位图文件
文件扩展名为.bmp
在bmp文件中
除了像素深度可以选择之外
不采用任何其它压缩技术
即没有数据压缩在里面
所以带来的也就是
bmp文件所占的存储空间较大
JPEG文件全称是联合图像专家组
文件扩展名是.JPEG
它是静态图像数据压缩的国际标准
可以用不同比例
对图像文件进行压缩
压缩比较高
适合大量图像数据处理
而GIF文件
是一种图形交换格式
文件扩展名是.GIF
适合在网上进行传输交换
一个GIF文件中可存储
多幅彩色图像
逐幅显示在屏幕上
就可以构成一幅简单动画
PNG图像指便携式网络图形
文件扩展名是.PNG
它是一种无损压缩的位图图形格式
改善并取代GIF
广泛应用于互联网和其它方面
下面这两幅图中
左图为一张带有
8位透明通道的PNG图像
右图是
被置于
透明成像棋盘的
我们先看如何编写
一个简单的批处理程序
在windows操作系统当中
有三类文件是可执行文件
大家所熟知的.exe文件是可执行文件
我们安装的大多数应用程序
最终的可执行文件的类型
很多都是.exe文件
第二类是.com命令解释程序的
第三类就是我们今天会提到的
.bat的批处理程序
那么这里批处理程序指的就是
我把一组处理命令把它编写
成一个文件这个文件中
命令之间存在一定的逻辑关系
这里可能有逻辑判断有分支
有循环这也是程序
我们来看这样的程序该如何编
编写批处理程序可以直接用
记事本在这里就叫change
因为我们希望用这个程序
来改变计算机的文字和背景的颜色
就把它叫做change
同样记事本来进行编辑
这个编辑过程也是我们完成编写
批处理程序的过程
我们来编写一个简单的批处理程序
希望通过这个简单的
程序帮助你理真正的程序
应该是什么样子的rem在批处理
程序当中
rem代表下面是一个注释语句
这条语句不需要执行只是写给
编程人员看的
一看就知道这段程序是用来干什么的
下面我们来
根据时间
来设置一下显示的颜色
用一个变量
这个变量取的就是当前的系统
之间用百分号
去表示我取
当前这个机器的系统时间
根据时间完成一个判断
如果时间在12点之前
也就是上午
我们希望它显示
文字的颜色为9
我们在介绍
多媒体信息表示的时候强调过
这些信息最终
存放在计算机中
都是01编码
都可以把它用某种
以某种数字的形式表示出来
同样的如果时间是下午
也就是超过了中午12点的话
我们让它换一种颜色
用1来表示
可以看到这个时候表示颜色
出现了16进制
只有在16进制当中
用e表示15
暂停一下恢复到原始的表示
这就是非常简单的一个
批处理程序我们把它保存
然后退出那么
现在还是文本文档修改文件类型
把它改成bat批处理文件回车
确实要修改这个时候我双击
.bat文件在windows操作系统中
它的文件管理中认为.bat
文件可以直接执行所以它按照
处理批处理的方式
一条一条去执行指令
这个时候双击来看
程序的变化
我的机子上装了
360它把它看成一个病毒我们
把360先关掉
这个时候可以看得到
它显示出了每一条语句的
执行过程第一条注释语句
它没有任何反应
第二条读出了系统时间是
11点39分26秒
这个时间由于小于12
颜色就变成了9
否则的话它显示的是
1现在是请按任意键继续
也就是我们给出的
？？？？？？？？？指令它停在这里
下面向我修改下这段程序
颜色9难看
我们
编辑这个批处理文件把这两种
颜色换一下看看e是什么颜色
退出保存
下面进入dos的命令模式
来完成批处理程序的运行
它在g盘g盘我们用
dir可以查看change的bat
这个时候可以运行change
这个时候看到这次的执行
过程当中第一条值
第一条是是注释
它没有做任何
行动之后现在读出的
时间是11点
42分39秒
由于时间
小于12实际上
是第一条if语句执行
这个时候看看colore
是黄颜色这就是
利用文本编辑
利用记事本
来编写一个程序
所以我们这里讲的批处理程序
它跟windows中的其他可执行
文件有所不同像.exe文件是不可读的
它是源代码翻译之后的结果
批处理程序是可以读的
它中间有一条一条的dos命令
来组成这是我们用文本编辑
器来编写成的
程序虽然程序是一个简单的
批处理程序但它也
它就是一个程序所以在中间
你可以看到程序设计的基本思想
像if语句像顺序结构像归编
成的一些基本的
关于编程的一些基本的概念
在计算机当中是随处可见的
图像的数字化
把它跟图形分开来看
图像和图形是从
绘制生成图片的角度
来进行区分
对于图像而言
像素是组成位图最基本的元素
像素这个词我们平时听得多
我们去购买相机
会得知其是一千万像素
这个像素跟图像中的像素
是一个概念
组成位图最基本元素
这种格式的图适合存储
图形不规则而且颜色丰富
没有规律的图
平时拍的照片都是位图
通常用于表现色彩丰富
细腻的人物和自然景物
位图跟分辨率有关
若在屏幕上
以较大倍数来放大显示位图
就会出现马赛克现象
我们来看一下
这就是典型的位图
把这个位图放大来看
请大家注意看
位图在放大的过程中
这里已经可以看见一些马赛克
我们找一个
看上面这个图
看上面部分的
马赛克的变化
这就是我们讲的马赛克
这里可以看到一个一个小的
像素点 虽然这么说
但它不是数学上点的概念
我把这个屏幕划分成了
很多行 很多列
通过这些行列
划分出一个个小方格
这就是所说的像素
而我们把它缩小来看
这幅图片很逼真
当把它放大到一定程度
就可以看到一个一个的
马赛克
一个方格只存放一种颜色信息
所以可以看到
这个企鹅嘴部
的马赛克现象
位图通常通过扫描仪数码相机
等设备来获得的
这些设备把模拟图像信号
转换成数字图像数据
刚才已经提到这种转换基础
是像素
再通过一些图形
再通过图像的处理软件
像Photoshop ACD See
等对位图进行处理
与位图图像相对应的
叫做矢量图
矢量图也叫向量图
它用计算机记录的是
点线面的位置
和颜色信息的描述
矢量图不像位图
一个一个去描像素点
若画一个圆 它记录的是
圆心和半径
圆心的坐标和半径大小
矢量图中无直接点线面信息
重现时
看图软件就解读这些描述
重新把它绘出来
这样图形的放大缩小不会失真
适合存储
标志线路图设计图等
这种格式的优势
是放大不失真
占的空间也较小
常见的Flash动画就是矢量绘图
左边是一个图像
放大后可看到马赛克现象
而右边是矢量图是向量图
它记录的是它的
形状的特点
线的信息
以及一些交点的信息
而这些信息在放大缩小的时候
不会出现失真
下面我们专门来看
位图的数字化过程
按一定的空间间隔
从左到右 自上而下
提取画面信息
并按一定精度
进行量化的过程
假设用相机拍摄了一幅照片
这幅照片存放在计算机中
它怎样用怎样的01编码去表示的
首先要做的是
把这照片从左到右
从上到下
划分成行和列
那么这些行列
就区分了一个个小方格
每个方格
就叫做一个像素点
这里提到的连续图像
假设它是一幅照片
这幅照片最终存放在计算机中
也要经过一个数字化过程
这个过程同样是要经过
采样 量化 编码三个阶段
采样就是我们刚才提到的
从左到右自上而下
把它划成一个个像素点
行和列取的多和少
决定了取多少个像素点
这是你的采样
采样之后每个像素点
有它的颜色信息
这颜色信息存放在计算机内
用多少个二进制位来存放
这就是量化
有了采样和量化之后
后面就是对这幅图像编码
你可以看到我们
沿x轴方向以等间隔来采样
采样点数可以划成n个
沿y方向同样可以进行均匀采样
采样点数为m
这样整个图片就划分成了
一个m乘n的离散样本的矩阵
这里的像素点是m乘以n个
下一步是对图像进行量化
把每个离散点
即刚才划分好的
每个像素的亮度
或颜色的取值
用若干位数的
二进制编码来表示
矩阵中划分出的每个点
都是一个个的像素点
下面可以看出来
每个像素点的颜色信息不一样
这幅图片中
有类似于白色的
有偏黄色的有棕色的
如何表示这些颜色信息
用多少个二进制位来表示
这就是量化的作用
评价一幅数字图像的指标
包括图像的分辨率
刚才划分的行和列
得到的像素点数
就是图像的分辨率
这幅图片的分辨率
就是1024乘以768
图像的分辨率越高
每个像素点
存放所需要的
二进制位数越多
即像素深度越深
数字化后的图像越逼真
图像的数据量越大
用一千八百万像素的数码相机
拍摄的图像
冲印成36寸的照片
能否达到最佳质量
这是我们讲的像素点
实际上是采样的概念
采样之后的每个像素
的颜色信息取值
依然是连续的
要对它进行离散化处理
这就是量化
将近似的颜色
划分成同一种颜色
将颜色取值限定在
有限个取值范围内
每种颜色与一个
不同的二进制数进行关联
这是最简单的一种量化
这幅图片上的颜色信息只有三种
只有白色黄色和黑色
用两个二进制位足够区分
量化指的是
你为每个像素点的亮度
或颜色进行取值
这里只有三种颜色
用012就可以表示出来
用0表示白色
用1表示黄色
用2来表示黑色
真正的关于这幅图片的
颜色信息
就是存放在这个
图片中的像素点的颜色信息
通过一个二维矩阵存放下来
这就是量化的过程
在有限的取值范围内
将近似的颜色划分为
同一种颜色
有了采样量化之后
最后进行编码工作
使用二进制的编码来
表示像素点的不同颜色
再一行行存放到文件中
这就构成数字图像文件的
数据部分
现在这是十进制
对于这一行信息
真正存放在计算机中
你可以看到
我用一个字节来存放
一个像素点的信息
事实上这里不需要一个字节
因为只有三种颜色
两个二进制位就够了
用全零
来表示白色
用1表示黄色
用10表示黑色
关于这幅图片
这一行的信息
一共区分了
七个像素点
这就是这行7个像素点的颜色信息
这就是我们讲的
评价数字图像的第二个指标
像素深度
像素深度指
表示每个像素的颜色
所使用的二进制位数
一般用二进制位的概念
也把它叫做位深度
像素深度决定彩色图像中
可出现的最多的颜色数
或黑白图像中
最大的灰度等级数
对于数字图像的属性
我们可以把它进行分类
这是一种单色图像
只有黑白两种颜色
即黑白图像
这就是256度的灰度图
256灰度图指
像素深度
即位深度是8位
用一个字节存放灰度信息
这是256色图
意味着颜色信息
用一个字节存放
只有256种颜色
一个字节只能区分256种颜色
说这幅图像是真彩色意味着
至少用24个二进制位
来存放
一个像素点的颜色信息
有了这些概念后
可以计算数字图像的数据量
可以用字节来表示
现在讨论的都是未经压缩的
即没有通过压缩算法的
这个数据量等于
总的像素点数
乘以像素深度
计量单位是字节所以要除以8
可以通过查看图片属性
来找到这个图片的分辨率
对于这幅8鲜花图片
我们点击鼠标右键
可以看到它的属性
在这个属性中
可以看到它的颜色信息
在详细信息里面
可以看到它的
分辨率是
1024乘以768
可以看到它的
采样频率是1024乘以768
位深度是24位
由此就可以计算出
这个图片所需要的存储空间
这幅图片的像素
点数为1024乘以768
每个像素点
用24个二进制位来存储
最终要把它转换成字节
所以还要除以8
这个数值计算出来之后为
2359296个字节
进一步把它化简成KB的形式
2304KB
继续化简
它大概是2MB的存储容量
我们来看一下这幅图片
真正在
存储上用了多少空间
八仙花属性可以看到它的
容量大小
实际上它只用了
584K字节
这就是这种文件格式
大家要注意这个文件格式的
扩展名为.jpg
这是一种图像文件的压缩格式
下面我们看数字图像处理技术
我们介绍三方面的内容
一个是颜色的概述
现在很多图像都是彩色的
也有灰度的
这些灰度信息和颜色信息
如何在计算机中表达
这是我们讲的颜色
在计算机内
存储和处理的描述
第二部分介绍一幅图片
一个图像的数字化过程
国际照明委员会
特别规定了
700纳米的波长代表的红
就是纯正的红
而绿是546.1纳米
蓝是435.8纳米
这三个色光
为三基色
每种光的强度区分为
256个级别
也就意味着
用8个二进制位
一个字节可以存放
一种光的强度
每种光的颜色
用一个字节来表示
所以在RGB模型中
由这三原色可以
组合出很多颜色出来
每种色光采用不同强度
而每一种每种色光刚才提到的
分成256个级别
也把绿色分成256个级别
蓝色也是256个级别
这意味着每种色光强度
可以用8个二进制位来表示
1 2 3 4 5 6 7
可以用八个二进制位来表示
那么RGB的三原色模型
放在一起就需要24个
二进制位
而24个二进制位
可以算出它能表达多少种颜色信息
即256乘以256
乘以256
这个结果是
167 777 216
通过RGB三原色模型可以
描述出这么多种颜色信息
RGB的颜色模型
依然不能表示出
自然界中所有颜色
但对于表达人眼能够
感觉到的颜色来说
已经足够
下面我们来看一个例子
RGB的颜色模型
是如何相加
来得到其它丰富的颜色信息的
我们简单的来画一个框
可以看到这种颜色有点偏蓝
点击鼠标右键
可以看到有设置形状格式
我们可以看一看
填充的信息
可以看到这里是纯色的填充
对于它的颜色信息
我们可以看到
它的颜色模式我们现在
采用的是RGB颜色模型
拉开这里还看到它有
HSL的颜色模型
我们刚才介绍的是RGB模型
RGB模型是
红绿蓝三原色相加得到的
你可以看到对于
每种颜色而言 对于红色
有256个级别 即最小为零
你可以看到颜色的变化过程
我们把红色改为零
你可以看到
它的颜色发生了变化
这当前的颜色
刚才红色为79的时候颜色
红色变为零时颜色如上图
它最大值为255
输不进256
度量值必须介于0到255之间
表示用一字节存放这种红色光
假设它是255
你可以看到这两种颜色的
红色强度从0到255时
红色就很强了
蓝色基本变成玫瑰红
这是用RGB颜色模型如何组合
变化我们的颜色
RGB都取零得到黑色
若只要红色
就把蓝色和绿色都变成零
红色调到最大的强度
这是得到的大红色
若只要绿色
那么红色和蓝色光调到零
绿色调到最大强度255
要得到纯蓝色
把红和绿调到零
由此我们可以得到一个
正方体
对于一些特殊的颜色 黄色
品红 青色 以及白色
通过正方体可以调出来
我们看一下操作系统中
如何设置显示器
屏幕分辨率和它的颜色模型
在屏幕上点击鼠标右键
可以看到有屏幕分辨率
进入高级设置之后
可以看到有对监视器的管理
点击监视器可以看到
一个是屏幕的刷新频率
这是对硬件显示器的
刷新频率的设置
下面就有它的颜色模型
这里可以看到采用的是
真彩色32位
刚才介绍的RGB颜色模型
每种光的强度是
用8个二进制位来表示
一共是24位
还有8位
三种光的强度一共24位
还有8位是用来干什么的呢
32位真彩色模型
到底是什么含义呢
而32位真彩色
是指在24位真彩色图像基础上
再增加一个表示
图像透明度信息的Alpha通道
32位的真彩色实际上是
3个字节24位的RGB模型
加一字节Alhpa灰度通道
这一单元是0和1的故事
今天讨论多媒体信息表示
我们前面介绍了
文本信息表示
介绍了数值的信息表示
这一讲的内容主要介绍
图形图像音频视频
这样一些信息在计算机内
是如何表示
计算机当中到底是
如何处理多媒体信息的
对于各种各样的媒体信息
怎么样来进行信息表示
是我们今天要讨论的内容
下面我们来看这是波形
波形文件声音的数字化过程
这是典型的波形文件
这种波形文件我们说
它是一种模拟信号
指的是时间和幅度
都是连续变化的信号
在计算机当中我们再三强调的是
它存放的就是0和1
就是数字信号
所以你的声波
你的声音文件你演唱的歌曲
如果要在计算机当中
进行存储和处理
一样的是要经过数字化的过程
我怎么把你的振幅
怎么把你的频率
以0101的编码形式体现出来
时间和幅度都是连续变化的信号
这是我们讲的连续信号
也就是模拟信号
而计算机
它是离散的有限的概念
只能处理离散的信号
所以我们首先面临的是把这些
信号离散化
数字化的过程是将
连续的模拟声音信号转换成
时间和幅度都离散的数字信号
而这样的一个转换过程
要经过采样
量化以及编码三步
采样指的是在连续变化的时间当中
我选择哪些时间点
去记录振幅的高低
而量化是我怎么样与01编码的形式
把这个振幅的大小记录下来
最终才是我完成编码的一个过程
由此我们就得到了一段
数字音频
这样我就可以在计算机当中
来进行存储和处理
下面我们就来看采样
采样指的是每隔一个时间间隔
在模拟声音波形上取一个幅度值
我们刚才看到这个声波是什么
声波本身是随着声音连续变化的一个波形
而我们在声音的数字化过程当中
第一步要做的事
就是连续变化的声音
我怎么把它离散化
我怎么样在中间采样
找一些时间点
只要我这个时间点采的足够多
可能你的耳朵就分辨不出来
听起来还是一个连续演唱的歌曲
所以就是讲的
我们取的点足够多的时候
可以将连续的波形再现出来
那么采样频率越高
表明相同时间之内
采样的次数越多
获得的采样值也就越多
数字化后的声音也就越来越逼真
采样的周期可以是均匀的
也可以是不均匀的
均匀采样是
指采样频率是相同的
采样频率越高
也就意味着采样周期越短
数字化后得到的声音就越逼真
刚才讲的采样是从时间上
怎样把它划分成一些离散的点
量化则是把声波信号从
振幅上如何划分成离散的点
为采样点确定振幅值
是对它的振幅值进行限定和近似
本身振幅从声波信号来看
也是连续变化的
我现在怎么把它量化成离散的点
这里可以看到
我对声音的振幅进行了一些量化
可以看到我把它量化成一个个均匀的点
这个时候可以来看
在采样点离散均匀采样的
这些时间点t1上
事实上真正的声波信号
它的振幅是在这个位置
我们如果
从这里来数的话应该是0 1 2 3
它应该在3.5左右
而在这里
因为我量化值量化之后
我就没对中间具体的值在给出一个
在给出一些连续变化的值
我们只对这些离散的点进行定义
这里就是1 2 3
可以看到采样之后
横坐标轴上的点都变成了
一个一个离散的点
从这里看到它是均匀采样的
那么这张图当中对这个声波信号
在振幅上也进行了量化
那么最低的一个点依然是0
上面的点是均匀量化1 2 3 4 5
那么真正做完
这种离散的量化
如果真正要二进制表示出来的话
那么这一位
2就用10来表示3则就是11
4是100
5是101
那么量化之后才是编码的问题
我们先不考虑编码我们先来看
那么在经过了这样的量化之后
那么t1这一时刻
它这个
振幅的值应该是在3.3和3.4之间
精确的值但是我均匀量化之后
我只有3和4
那么对于t1点的
量化值之后这个值可能就是3
而对于t2这个点可以看到
它差不多
就在5这个位置它是5
对t3这一点量化之后
这一点依然是5的值
而t4这一点可以看到
往上走这是678
基本它是8了
而t5也是8
t6则为10
那么这是量化之后每一点它的值
事实上跟它原来真正的值
是存在着一定的误差
你可以看得到
我们这样对时间
进行采样的过程当中
那么这一个波形的变化
包括这一种波形的变化
也都没有采集到
因为在t2和t3之间这个值都是5
它并没有记录下中间波形
变化的范围
这就是我们讲的线性量化
按照固定的幅度来划分这是一种
等间隔的量化方法
最后一步就是编码了
我们对时间进行了采样
对振幅进行了量化下面
就剩下最后一项工作
来进行编码量化后的幅度值
用二进制数来表示
量化的位数这也是量化的深度了
表示量化的采样值数据的
二进制位数
通常我们把它叫做采样的精度
下面我们介绍PCM编码
这种编码的名称叫做脉码调制
就是将声音
通过采样量化编码来
转换成数字信号
对模拟声音信号使用均匀采样
线性量化
以及四位编码的数字化过程
在横坐标上t1到t2时是
采样的时间点
纵坐标上假定幅值的范围
是从0到15
并且将幅值量化为16个等级
16个等级刚好就是用4位的01编码
刚好可以进行表示
四位的位模式刚好区分16种等级
例如在t1采样的t1采样点
它的采样值事实上大概是3.35左右
那么量化之后取值就为3
编码就是0011
这就是PCM编码的形式
这样我们可以得到这些采样点当中
在这些采样点上的编码格式
在t1采样点量化编码的结果
就是0011
而t2的采样点得到的是0101
这就是音频波形的PCM编码
事实上
这种脉冲编码调制
最简单的一种声波数字化的形式
下面我们对比两种声音的
数字化过程
一种采样频率是11KHz
8位的量化位数
另一种采样频率是22KHz
16位的量化位数
经过采样量化之后
把连续的时间和连续的振幅
都变成一些离散的点
不同的采样频率
意味着我们在时间轴上
所取的离散的点是不一样的
而不同的量化位数
则意味着我们在量化的幅度上
找到的离散点也是不一样的
我们先标出左边这幅图当中
进过采样量化之后
得到的关于这个波形的
一些离散的点的描述
最终存储在计算机当中的
就是这些离散点上的信息
我们在来看右边这幅图当中
进过采样量化之后
得到这样一些离散的点
那么对比这两幅图上的
离散的点你可以看得出
右边这幅图离散的点也更密集
也更接近于我们原来的波形形状
计算机存放的
并不是我们连续变化的波形信息
存放的都是经过采样量化之后
得到的这些点
我们可以看得出来的是
只要你的采样频率足够的高
量化的精度也足够
声音的数字化之后的结果可以
尽可能的去逼近
原有这个波形
可能可以达到使你的耳朵
无法分辨
听起来似乎是真实的音乐
但事实上而言
在声音的数字化过程当中
失真是绝对的
一定是丢掉了一些信息
把连续的变成了离散的有限的
我们在强调一下
数字音频的技术指标
也就是声音数字化之后
它的技术指标主要是通过
采样频率和量化位数来描述
量化位数代表采样精度
采样频率越高表明相同时间之内
采样的次数越多
也就是在这个时间轴上
我找的时间点越密
获得的采样值也就越多
数字化后得到的声音就越逼真
常见的采样频率
有44.1KHZ
折半之后有22.05KHZ到11.025KHZ
采样的精度越高
也就是量化位数越多
16位的量化位
跟8位的量化位相比
就更能细腻的表示声音信号的
变化程度减少量化上的失真
关于声音的数字化过程
还有一点是特别的
人有两个耳朵
两个耳朵都接收不同的声音信号
这是我们讲的双声道
我平常听mp3
也是两个耳朵上带耳机
而这两个耳机传来的
声波是不太一样的
两个声波交织在一起听到的是
更美妙的音乐这就是双声道
双声道又称为立体声
单声道它只产生一个波形
而双声道产生两个声音波形
立体声不仅音色音质好
而且听起来要比单声道
更具有空间感也就是真实感
但是你应该可以想到的是
它存放在计算机当中两个声道
有两个声波的数字化过程
但它所占的存储容量要更多
从而导致计算量也更大
声道数指一次采样
所记录产生声音波形的个数
通常电话通讯是单声道的
而CD都是立体声音
下面来看数字音频数据量的计算
我们先看数据率的概念
数据率指单位时间内的数据量
也就是一秒钟
需要多大的数据量
数据率指采样频率
也就是你有多少个时间点
每一个点都要经过量化
存放在计算机当中一个点对应
一个量化的位数
我还要乘以声道数可能是
两个声波信号或多个声波信号
这个计量单位上可以是二进制的位
也可以是字节
下面来完成一个计算过程
现在有一张CD
存放有一个小时的数字音乐
现在没压缩不考虑压缩的情况
计算它的数据量
既然是CD首先要考虑的
它是双声道
我们前面提到过
CD的采样频率是44.1KHZ
而量化的位数是16位
它是立体声的双声道
数据量的计算等于数据率
乘以持续的时间
而数据率等于采样频率
乘以量化位数乘以声道数
我在这里以字节为
计量单位来完成计算
持续的时间这里是60分钟
采样频率是44.1KHZ
16位的量化位数声道数是2
除以8表示我将以字节
来做计量单位
我的时间是60分钟也是3600秒
通过计算我可以得到
一个小时的CD
需要多大的存储容量
数字比较大进一步把它进行
化简用KB用MB来表示
除以2的10次方也就是
1024之后可以把它换成62万多KB
这个数还是挺大的继续除以1024
得到大概是606M
字节的存储量
下面我们介绍视频和动画技术
把在空间和时间上
相互关联的图像序列连续起来
就构成了动态图像
一幅幅独立图像按一定速率
连续播放
形成连续运动的画面
这样的一幅幅图像我们把它叫做一帧
帧是构成动态图像的最基本单位
这是利用人眼所具有的
视觉暂留的特性
最终形成了视频和动画
视频可以看做是实时获取的自然景物
而动画是由人工或由计算机产生的
视频和动画的评价指标包括帧率
帧率指的是屏幕上每秒显示帧的数量
不同的制式帧率不一样
对于NTSC制式
大多在美国 加拿大 日本使用
每秒是30帧
另外一种制式
只在我国及德国 英国应用较多
PAL制式
每秒显示25帧
一帧是一幅完整的图像
数字视频的获取
主要有两种渠道
一种是通过数字化的设备
如数码摄像机
数码照相机 数码光盘等
第二种途径是模拟视频设备
输出的模拟信号
由视频采集卡转换成数字信号
再存放到计算机中
而视频质量取决于
采样原始图像的质量
以及对视频数据压缩的倍数
动画的形成也是利用
人眼所具备的视觉停留的特性
这就是最简单的GIF动画
通过几幅静态图像
按一定时间间隔连续播放
给你的感觉就是
看到了似乎是动画在播放
小鸟在飞
对于视频存储容量的计算
我们同样考虑未压缩的情况下
首先你要考虑图像的容量
因为它是一帧帧图像连续播放
同样还要考虑它的音频的容量
下面我们来计算这样一道题
存储一分钟的视频
每秒25帧
每帧是352乘以288个
静态真彩色图像
给出像素点
也给出每个像素点的
像素深度是真彩色
希望你来计算它的存储空间
既然是真彩色我们考虑
给你24个二进制位来存放
每一个像素点的颜色信息
计算它一分钟的存储量
对于图像的容量 我们来计算
我一共有
352乘以288个像素点
每个像素点用24个二进制位
每秒25帧
一分钟一共60秒
那么计算出来
这些图像存储容量
一共需要435兆
对于视频而言还有音频信息
音频的采样频率是
44.1K赫兹
用16个二进制位来表示
声波的振幅
既然是CD音质它是双声道 乘以2
一分钟等于60秒
由此可以计算出
音频需要的存储空间是10.1MB
这就是我们
存放一分钟的视频
一共需要445.1MB
这是对视频存储容量的计算
这一单元是0和1的故事
我们继续数值信息表示
八进制的基数为八
它的基本数码包括0 1 2 一直到7
它的基本运算规则是逢八进一
所以在你计数的时候
如果数到了七
再后一位 就是十进制的八
但在八进制中 逢八进一
所以十进制的八
在八进制中的表示是10
我们前边介绍过
如何把一个二进制数等价地转换成
十进制数
把一个八进制的数
等价地转化为十进制
它的算法跟
二进制的数转换成十进制的数
算法是类似的
都是把每一位
按照这一位上的权展开
然后按十进制的方法来求和
就可以得到
一个八进制数的十进制表示
我们这里有一个八进制的数是474
把它转换成十进制数来看一下
八进制数是474
把它转换成十进制指的是
每一位按它的权值展开
对于八进制而言
末位表示的是八的0次方
7这一位的权为
8的一次方
而最高位这个4的权为
8的平方
所以这个数转换成十进制数是316
我们下面来看一下八进制
和二进制数之间的对应关系
我们看一下二进制三位的位模式
表示我用三个二进制的位
来表示一个数
那么对于八进制的7
用二进制表示出来就应该是111
对于八进制的6则是110
我们从后往前看
对于5就是101
这是二进制三位的位模式
这指的我用三位的位模式
来表示八进制的八个基本数码
从这里我们可以看到一些
对应关系
就是在八进制
到二进制的转换过程中
可以找到这八个基本数码
和二进制三位位模式之间的对应关系
我们通过一个例子来看一下
二 八和十六进制之间的转换
这个例子中的二进制数
既有整数部分又有小数部分
我们看这个数
转换成八进制十六进制该如何进行
这个基本思想就是
在二进制转换成八进制的过程中
三个二进制位
转换成一位八进制位
那么在你转换的过程中
从小数点往左是整数部分
小数点往右是小数部分
如果这个数要转换成八进制
我们说是三位变一位
那么三位变一位的话
从小数点分别往左往右
每三位一组进行划分
那么这个划分的过程当中到最两端
可能发现不足三位的情况
那么对于不足三位的情况
要用0进行补齐
这个补0非常关键
我在这个数的两端进行补0
并没有修改这个数
这个数还是原来的大小
我们再来看
如何把它三位换一位来进行换算
从左往右
第一个碰到的三位的位模式是010
那么它对应八进制的2
而100对应的是八进制的4
101对应八进制的5
小数点往右
010对应八进制的2
111对应八进制的7
而100对应八进制的4
所以这样一个二进制的数串
转换成八进制之后就变成
245.274
我们再来看
怎么把它转换成十六进制
同样地
小数点往左往右
四位一组进行划分
在两端的时候如果碰到
不足四位的以零补齐
剩下的就是每四位一组
找到它对应的十六进制的表示
1010对应的
十六进制表示为A
而0101为5
小数点往右
0101为5
而1110
为E
所以这个二进制数串
转换成十六进制后的数值是
A5.5E
反过来我们再来看
如何把一个八进制或十六进制的数
转换成二进制
转换的规则是
一位变成三位
我这里有一个八进制数是175.206
我希望把它转换成二进制
转换成二进制是
一位要变成三位
对于第一个1就变成001
而7对应的是111
5对应101
小数点往右2是010
这里特别要注意
就是这0一定要变成三个0
最末一位是6
对应的是二进制的110
所以这个数变成二进制的表示是
这样一串数串
我们再来看怎么把
十六进制的数转换成二进制
这里因为是十六进制的数
所以再转换成二进制的过程中
是一位要变成四位
那么从最高位开始
3就应该是0011
而到D则是1101
B是1011
小数点往右是9
则是1001
5是0101
8是1000
这样我们就得到了
这个数的二进制表示
我们再来看十六进制
如果一种进制是十六进制
那意味着它的基本数码应该是十六个
像我们前面的十进制八进制一样
我们一样是从0开始
从0 在十六进制中
它的前十个基本数码
与十进制的是相同的
从0到9
那么9之后怎么办呢
它既然是基本数码
它应该就是十六进制中的一个位
那么9之后
如果 我在十六进制中写10
那么这个1应该代表的是
16的1次方
如何表示十进制中的10呢
我们用英文字母大写的A
来表示十进制中的10
在十六进制中的表示
我们用大写的B来表示
十进制的11
在十六进制中它是一个基本数码
所以我们把它用大写的B来表示
一直到F
用F表示十六进制中
最大的一个基本数码
也就是十进制中的15
所以十六进制中的16个
基本数码是
从0到9再加上A B C D E F
考虑十六进制跟二进制之间的对应关系
既然我有十六个基本数码
那意味着三位的位模式表示
十六进制的十六基本数码是不够的
至少我需要四位的位模式来表示
十六进制当中的这十六个基本数码
第一行我们给出了
三十二位的二进制数串
因为我们一开始就讲了
计算机是基于01表示的
都是01编码
那么意味着
我可能用三十二个二进制位
来表示一个信息
那么这三十二个二进制位
所形成的01串
就是这样一串
大家看了这一串
我想大家一定有自己的感觉
它难以阅读 也不太好处理
在你平时书写的时候也容易出错
所以更多的时候
我们是引入了十六进制
这也是我们介绍八进制
介绍十六进制的原因所在
把它转换成十六进制的表示
使得它看起来
短小精干 一目了然
那我们刚才事实上从
十六进制的十六个基本数码
跟二进制四位的位模式
之间的一种对应关系
大家可能已经猜测的出
如何把一个二进制数
转换成十六进制
那么可能有的同学已经在开始考虑了
就是减法怎么办呢
我们先来看看帕斯卡
帕斯卡这样一个机械的自动加法器
它是如何完成减法的
我们通过这个动画来看一下
帕斯卡的运算器怎么做减法
大家注意看这个上面
现在你可以看到五个0
在做减法时它会做一个切换
把它切换到五个9
大家注意看
切到五个9了
然后它就会考虑开始做减法
它要算的这个数据是
31减掉16
我们来看看它是怎么做减法的
大家特别要注意的是
它输入31的方式
跟我们前边的是不一样的
齿轮转动的时候
是从这个齿轮的最下面
按照顺时针的方向
一直转到3这个位置停止
这跟我们输入加法运算数不一样
加法运算数是直接数到3
然后一直把它
按顺指针方向转到1
一会儿我们再来看
它为什么要这样做
我们继续把这段看完
而它输入1的情况你也可以想象到了
在做加法时我们输入1
是从这里开始
顺时针方向走一格就可以
然而在做减法的时候
31的一位上的输入
是从根部这个位置
绕一大圈到1这个位置
这是1的输入
可以看到
上面显示输入的数值为31
再来看减16是怎么做的
你看它在减16时并没有把1
从根部开始绕一圈
它是按正常的加法运算的1来表示
从1顺时针走一格走到根部
可以看到 它直接走到了根部
而这里16一样的
按加法运算的6的输入
这时候大家可以看到
上面已经给出了运算结果
就是15
下面我们来分析一下
帕斯卡的计算器
它到底怎么做减法
我们现在同样的来考虑31减16这个减法
来看看人是怎么做31减16的
31减掉16
我们的计算过程
是从最末一位开始
也就是从个位开始
个位上就应该做1减6的动作
而这里1减6减不够
所以只能从三上借一位
所以这个减法就变成了
11减6
这个数值为5
而3因为借走了一位则变成了2
2减1得到的结果就变成了15
这就是我们完成31减16的过程
做这个减法的过程中
可能大家已经看到了 借位很棘手
我怎么能不借位就
完成减的动作呢
在这个例子中
都是两位数 对于两位数而言
减法要保证不发生借位
那么最大的数就应该
用最大的数去减 这个数应该是99
所以不管你减法减多少
只要它是两位数
我用99去减 一定不需要借位
那我们看这个减法变成了什么
我要算的是31减16
在31减16的时候
我发生了借位
而我觉得这个借位很难处理
我希望用99减16
这个式子要两边相等的话
31减16还在
因为我多加了一个99
那我干脆再多加一个
这等于我加了一个一百
再减去一个一百
这样 我这个等式两端依然相等
这时我继续
往下算 这个式子就变成了31加上
由于我在这里选的是99
如果减数是一位数
那么选九就够了
如果减数是三位数
那就得选999
总之 我要保证
不需要借位就能完成这个运算
这个地方就变成了83加1
减100
同样地 这个加起来就变成了
115减100
所以最终的结果是15
所以这样我们就把借位的情况处理了
因为借位
如果你要用电子机械装置去
完成这个借位操作的话
这并不是一件简单的事
所以帕斯卡这样处理加法器
这里的基本思想
就在于补数的概念
我们现在先介绍
什么是9的补数
之所以把它叫做补数
是为了区分于后面将要讲的补码
我们这里都是十进制
我用C来表示补数
用9表示是表示关于9的补数
而在关于9的补数中
我们这里用到了9 99 999
所以这里用1表示
一位的9对a的补数
对于它而言 它的补数就是9减a
假设a等于3
在a等于3的情况下
那么它的补数应该是9减3等于6
我们再来考虑多位的
这是一位数字的补数定义
我们再来看多位的
这个补数的概念就应该是
10的N次方减1减a
再往下算我们可以算出
C 9 N
如果我要做减法的话a减b
就应该等于10的N次方减1减括弧的a减b
再往下推算就变成了
10的N次方
减1减a加b
大家来看
这串数值实际就是
a本身关于9的补数
所以它就变成了C9N a加上b
这里的核心思想在于
我本来是做的一个减法
我本来是需要做a减b的
但通过补数的运算
最终把它转换成了一种加法
这是其一
其二的话 你看一位操作数
就变成了a的补数
最终我们要在帕斯卡计算器上
完成31减16的计算
它对31做了一个特定的处理
这个处理事实上就是求出了
31的补数最终与16进行相加
最终得到31减16的运算结果
那么对于计算机而言
它完成加法的时候有加法器
我们一起开始就讲了
在冯诺依曼计算机当中
很重要的运算部件就是加法器
计算机做减法的基本思想
事实上就借鉴了
我们刚才介绍的补数的思想
就是我要想办法把减法
也要变成加法
然后用同一套电子线路
同一套硬件装置
同样地可以完成加减乘除
多种多样的运算
回顾我们所进行的计算我们来看看
我们说28
加上35
我可以完成一个计算序列得到63的结果
这是典型的加法运算
这是毋庸置疑的计算
对于第二项
我们把x平方变换成了
变换成了2x
学过高等数学的我们也知道
这是求导数的计算
我们的计算机经常可能会用到
从中文翻译成英文再从英文翻译成中文
这也是典型的计算过程
由四个单词所组成的这样一个序列
变换成
后续的序列 从Bowie Dog Apple Cat
变换成 Apple Bowie
Cat Dog
这里我想大家应该已经看出来了
初始的序列是没有进行排序的
后续的序列进行了一个排序的动作
按照英文字典 去把它进行了一个排序
排序是计算机科学当中非常
非常基础 非常常见的计算
再来考虑我们的数学
推导的过程
无论是数学 物理 化学
可能都有这样的推导过程
根据一组定理和推导规则
可以推导出一些定理来
这里实际上这些都是
我们所讲的计算过程
这都是计算从我列出的这些
这五个例子你是否能够总结出
到底什么是计算
整台图灵机的秘密在于
读写头的状态转移表
它指示着读写头的状态
和当前读写头正对格子的符号
该如何变化
状态转移表规定了
图灵机的状态如何变化
规定了读写头应该读还是写
写什么样的符号
整个图灵机的工作过程非常简单
实际上就是一条规则
按照这样一条规则
我们把这条规则做一个描述
对于图灵机它有一个工作状态
假设当前的工作状态为A
而当前读写头之下
所读到的符号假设为x
由A和x
就决定了
下一步我将做什么
下一步我将做什么
实际上又分成了三个部分
一个是当前书写符号的x是否要写为y
当然你可以不写 或着修改为y
这是第一步
第二步是
我的读写头
带来的变化一个是当前符号
是否要发生变化
第二一部分是
读写头的位置是否要发生变化
我可以左移一位也可以右移一位
也可以位置不发生变化
那么下一步就是状态的变化
我的图灵机在我完成了
这些动作之后将进入
另外一个工作状态
这一条规则实际上
就描述了我们整个图灵机的
工作过程简单的这些规则变化
它是否读写符号 是否进行移动的工作
它的状态如何发生变化
就决定了你的图灵机
它所完成的是什么样的计算
它的状态转移表
也就是由这样一系列的简单规则来组成的
状态转移表实际上就是
我们图灵机的一个核心
用图灵自己的话而言
有了这样一个装置
有了这样一个模型我们可以完成
任何意义上的计算
只要你的控制器说得足够清楚
我们可以做任何专用机器可以做的工作
我们前面有些专用的机器
像八音盒它可以播放音乐
像加法器可以完成加法的工作
有了这样一个装置后
我们把这些专用机器通用化
我可以在通用的这样一个机器上
可以完成各种各样的计算
图灵的思想
成文于1936年
到它正真实现我们今日
计算机的工作模式都是以图灵机的
模型为基础的
到正真实现这样一台计算机器
我们还走过了将近20年的时间
我们人用笔来完成加减乘除
四则运算的这个思维过程
跟一台图灵机的运转是非常相似的
每一个时刻我的注意力
只是集中在一个地方
根据我们已经读到的信息来
移动这个笔尖
在纸张写下一些符号
只是我们如何写怎么去写的
是你头脑当中的一个计算过程
你比方说小学学过的加法口诀
九九乘法表
这些口诀
决定了你要在纸上写下什么样的符号
如果把一个用笔来完成乘法的人
我们把它看成一台图灵机的话
那么这个纸带就相当于你的作业本
你的作业本 你在上面记录数据
读写头就是你这个人手上的这支笔
读写头的状态
就是你的大脑的精神状态
图灵机的状态转移表
就是你用笔算乘法的这样一些规则
九九乘法表
或者是列式的这样一些方法
这种工作模式同样也适
用于更复杂的计算任务
表面看来说图灵机虽然是看起来简单
但是它足以作为我们
完成自动计算的一个基本定义
我们来看 如果把一个完成乘法运算
的人看作一台图灵机的话
他手上的这一支笔就可以看作是
图灵机的读写头
这就是我在纸带上进行书写
留下的输入符号
而完成计算的过程要依据的就是你的
乘法运算口诀 九八 七十二
这样得到一个结果
如此看来图灵机虽然看起来简单
但是它足以
作为自动计算的一个基本定义
现代的计算机不管是笔记本
还是超级计算机
或者是你的手机
你的手机也是一种计算工具
基本的工作原理都是
图灵机
今日计算机的强大
依靠的不是灵巧的器械
高超的工匠技艺
而在于它背后深厚的理论基础
图灵机就是这个理论基础的
一块非常重要的基石
我们今天对图灵机
有了一个直观的认识
对图灵机的系统的深入的学习
还在后续的课程当中
正是因为图灵奠定的理论基础
人类才有了有史以来
可能是最伟大的发明计算机
正是图灵机成就了今日的计算力量
今天我们进入
计算装置与计算机单元的
第二讲 图灵与图灵机
计算机在能够帮助人类
准确高效的完成工作的背后
有着它深厚的理论基础
这就是我们这堂课要讨论的图灵与图灵机
那么在人类计算工具发展的历史上
人们一直没有停下自己追求的脚步
我们希望制造出这样一种机器
既能够像八音盒一样演奏音乐
又能够超越加法器
来完成更加复杂的科学计算
那么我们能否构建出
这样的通用机器呢
这是人类一直以来的梦想
也是一个人的梦想
下面我们介绍 艾伦·图灵
艾伦·图灵在1936年
在他年仅24岁的时候
就对这个问题做出了回答
他说建造这样的计算机器是可能的
他可以完成任何的计算序列
下面我们来看 图灵机
在图灵机的组成当中
有一条无限延伸的纸带
在这个纸带上均匀的划分了
一个一个的小格子
那么在这些格子当中
你可以书写任何的符号
也可以让它就是一个空白
对于纸带上符号的书写
在上方有一个读写头
这个读写头可以向左移动
可以向右移动
也可以进行读和写的动作
可以在纸带上书写符号
也可以在纸带上
阅读符号
那么控制读写头读写需要一个控制器
控制器由一组控制转移规则来组成
按照这个规则来完成读写头
是读还是写
是左移还是右移来完成一些动作
图灵机的工作过程
就是根据读写头当前所读出的符号
以及图灵机内部控制器的工作状态
来确定
它是需要进行移动还是读写的工作
下面我们先通过一个简单的例子
来理解图灵机的工作过程
我们用这个表格记录了图灵机的转换规则
我们来一行一行来看
在状态为S的时候
也就是状态在起始状态的时候
如果读入的当前符号为i
i表示的是0 1到8不包括9
如果在状态S
而你读到的当前符号为i
那么图灵机的动作就是
在当前位置写符号
写的这个符号就是i加1
同时这个状态跃迁到G
G也就是进入了结束状态G
关于G的描述在状态规则表当中
只有一个动作就是停机
我们下面就按照这个状态转换规则
按照这个图灵机的描述来看一些实例
我先把图灵机
这个无限延伸的纸带画出来
在这个无限延伸的纸带上
有一些方格这些方格记录的是
输入输出的符号
我们现在考虑这样一个输入
今年是我们建校六十周年
我们就来考虑60
如果输入符号为60的话
我们看看这个图灵机的工作过程
假设我的读写头的位置
指向了0
我现在的状态为S 而我读入的符号为0
那么按照图灵机
我查找图灵机状态规则表可以发现
我们现在要做的动作
应该是在0这个位置
写上i加1
这个时候i为0
所以写下的是61
同时图灵机的状态
跃迁到G
这样也就进入到了一个
停机的状态
这个图灵机的工作过程就结束了
这个工作过程描述了
我从输入符号60变成61的过程
这就完成了加1的动作
我们再来看一个数字
如果输入纸带上的符号是129
我们来看图灵机的工作过程
当前状态为S 输入符号为9
那么它满足的是第二条转换规则
按照第二条转换规则的动作
9这个位置应该写上0
同时状态跃迁到P
现在我的状态就是P了
同时读写头的位置左移一位
当前我的状态就是P
而现在所读入的符号是2
适用的转换规则为第三条
此时
它的动作按照转换规则的描述
应该是2这个位置写上
i加1 也就是3
同时图灵机的工作进入
停机状态 进入结束状态 即G
G的动作就是停机
图灵机的工作过程结束
可以看到
从输入符号129到
输出符号130
图灵机完成了加1的操作
等于我们这个图灵机整个就是完成了
n加1的动作
我们来对这个图灵机
做一个总结
在图灵机当中我们可以看到
它的工作过程当中有很多很多的状态
像刚才这个问题当中
我们有S 有P 有G
有这样一种工作状态
在这些状态当中有一个
图灵机的起始工作状态
在这里我们的起始工作状态是S
在这些状态当中也一定会
有一些结束状态
结束状态可能是一些 是一组状态
在我们这里只有一个结束状态G
在这个图灵机当中
在书写纸带上可以出现的符号
我们把它称为符号表
这个图灵机当中它的符号表
就是从0到9
剩下的描述这个图灵机的工作过程
我们有一组转换规则
整个图灵机的工作过程
就是从起始状态出发
面对的是
你的纸带上的一些符号
那么根据状态和符号
来选择适用的转换规则
一步一步 最后走到终止状态停机
我们在大学计算机基础当中
只涉及一些直观的表达
希望你能够理解图灵机
理解为什么说图灵机
是计算机的理想数学模型
能够用图灵机去帮助
你理解计算的本质
而只要你变换它的控制规则
它的规则表那么你就可以完成
现在你做任何计算机能够完成的工作
因此我们说图灵机
是理想计算机的数学模型
变换你的控制规则你的控制器
控制器不同
它所完成的计算内容不同
对待同一个输入的符号
得到的结果可能不同
你可能会觉得图灵机的模型
这么简单
它怎么可能完成计算机的复杂任务呢
这就在于你怎么样去理解这个图灵机
不同的控制器可以完成不同的工作
我同样可以写出非常复杂的控制器
来帮助人们完成更加复杂的科学运算
现在我们来考虑一个问题
就是到底什么是计算
计算的本质是什么
图灵机这么一个简单的模型
我们为什么说它是
计算机的数学模型
它只是有一条纸带上面有读写头
有自己的控制器
它怎么就成为了计算机的
数学模型呢
计算归根到底就是一种符号变换
从一个符号串f
按照一定的规则把它变换成
另外一个符号串g
这样的符号变换过程
都可以视为计算
我们刚才所给出的图灵机非常清楚的
描述了这样一个符号变换的过程
符号变换的规则
由图灵机的控制器来决定
图灵从理论上证明了
通用计算机存在的可能性
奠定了通用计算机的理论基础
实际上现在的计算机
也是同样的工作模式
即使输入的数据相同
不同的图灵机的控制器 不同的图灵机
由于有不同的控制器
它得到的输出结果是不一样的
现在的计算机工作模式也是这样的
同样的输入数据
程序不同 也就决定了输出结果的不同
对于同一台图灵机
同一个控制器而言
不同的输入数据完成的计算是相同的
我们先从根本上来看
到底什么是计算
计算的本质是什么
我这里有一些题目
请大家思考这样一些问题
就是到底什么是计算
我在这里给出了一个图灵机的控制器
这个控制器非常简单它只有两条规则
第一条规则说的是
如果读出的当前符号为0到9
则图灵机的读写头右移一位
并且重复这个工作
第二句话说的是如果读到是空格
则写入符号0停机
我们来看一下这样
一个图灵机它完成的工作是什么
假设我的纸带上现在有的符号
是8和2
按照这个图灵机的控制器
我们来看它完成了一个什么样的操作
图灵机的工作过程
由读写的当前符号和状态来控制
假设读写头的位置在这里
按照我们这个控制器的第一条规则
如果我读到的符号在0和9之间
这个图灵机要完成的工作是右移一位
并且重复这个动作
读写头就走到了2这个位置
重复这个动作我这个时候读出的符号
依然是处在0和9之间
要做的动作是重复的继续走到下一位
右移一位
这个时候读写头再读出的就是空格
既然是空格那么执行的是控制器的
第二条规则 如果读到的空格
读写头进行写0的操作
并且停机
整个这个图灵机的工作过程
在你输入符号为82的时候
就结束了
这个时候我们看
我的输入符号是82
那最终我的结束符号是820
是八百二十
实际上这个图灵机我们可以猜测它是
完成了一个乘以10的动作
写成函数就是
我做了一个乘10的乘法运算
这是一个非常简单的控制器
我希望通过这个控制器
你可以理解图灵机的工作过程
就是在我的纸带上有一些输入符号
它和图灵机控制器一起决定了
它的输出状态是什么
这里大家有两点要注意
就是只要我的控制器
没有发生变化
那么无论我的输入符号如何变化
它对于这个控制器而言
它完成的都是乘以10的动作
第二点我要请大家注意的是
就是对于同样的输入符号
如果是82那么对于
这个控制器它的输出
在纸带上留下的最后结果
永远都会是820
这一点是确定的是唯一的
各位同学 大家好
今天我们来说说 冯诺依曼瓶颈 这个话题
课程视频中我们了解到
冯诺依曼体系结构中
包括了运算器 控制器 存储器
输入和输出五大部分
各部分之间通过总线相互连接
传递数据和指令
现实中绝大多数的通用计算机
都采用的是冯氏结构
这些计算机中的运算器
和核心控制器是集成在一块芯片上的
就是所谓的中央处理器CPU
早期的计算机CPU的频率并不高
与外围存储器和慢速设备的
数据交换的性能差异尚不突出
但是呢 随着技术的发展
由于制造工艺的不同
CPU的处理速度与存储器访问的速度
分别依照着不同的指数函数在增长
有数据统计CPU的速度每年提升60%
而存储器仅7%
两者之间存在着巨大的鸿沟
因而会造成CPU在数据输入
或输出存储器时闲置
CPU的性能提升
被慢速的访存所拖累
正所谓是“老牛拉破车
计算机的性能瓶颈就产生了
约翰.巴科斯早在瓶颈尚未凸显的1977年
就提出了 冯诺依曼瓶颈 这个概念
而另一位计算机科学家伍尔夫wulf
则在1995年预测了Memory wall
存储墙的存在
其实 我们每天在使用计算机的时候
都能切身地体会到这个瓶颈产生的效应
当我们开机或者加载应用软件时
焦急地在Loading画面前等待
当我们打开十几个运行窗口后
切换程序时 机器会变得很卡
甚至可能死机
这些现象都是因为CPU
在与内/外存储器频繁的交换数据
而数据交换的速度跟不上CPU的脚步
整体的运行性能下降
那么有没有克服冯氏结构
这个缺陷的办法呢
同学们在讨论中给出了
很多很好的方案或者设想
总结起来可以分为两个思路
第一是现有结构或者技术的改进
比如：引入高速缓存（cache）
又比如很多同学提到的采用并行技术
第二种思路则是结构创新或者技术发明
比如 有同学提到冯氏结构
是以处理器为核心的结构
要解决访存瓶颈应该改为
以存储器为中心的结构
又比如有同学介绍了
新型的高速存储器 忆阻器 的研究进展
实际上 技术的革命
往往是从第一种思路开始的
要破除这个瓶颈
先要分析制约性能提升的因素
我们简单地画个图
就可以找到优化的方向
在冯氏结构中处理器和存储器是分离的
按照 存储程序 的思想
程序和数据
均以二进制码的形式
存放在存储器中
处理器和存储器之间
通过一组总线传递指令和数据
这里的存储器就是我们通常说的内存
实际中处理器和存储器的速度
通常是用 频率 这个指标来衡量的
也就是处理器或者内存条
所能达到的最高工作频率
而总线呢 它的数据传输能力
是以 数据带宽 这个指标来衡量的
数据带宽的大小又取决于两个因素
一是同时传输的数据位数
二是传输的频率
也就是说数据带宽
等于总线频率
乘上数据位宽
可见这三者之间必须协调工作
才能发挥各个部件的最大效能
当高频率的CPU
面对大规模的数据处理时
低通量的总线
或者低频率的存储器
势必成为系统的瓶颈
因此 正如一个叫 云SUN 的同学所言
增大cpu的高速缓存
提高内存和总线的频率
尽可能的增加cpu与内存之间的总线位宽
是缓解冯诺依曼瓶颈的有效途径
事实上工业界呢
也是朝着这几个方向一直在努力
目前AMD CPU
的主频已经达到4GHz
CPU内外集成了多级缓存
而第三代的DDR内存频率
最高已可达3GHz
主板支持的总线频率和位宽
也紧随着存储器的发展
但是，这些硬件方法
都在不断地逼近物理极限
功耗 可靠性 芯片面积
成本等等因素将使得
访存性能指标的提升变得越来越困难
有不少同学在发言中提到了 哈佛结构
它是一种并行体系结构
通过将程序指令和数据分开存储
而达到二者可以并行读写的目的
从而有效地缓解冯诺依曼瓶颈问题
那么 为什么 哈佛结构 没有普及呢
主要的原因就在于
哈佛结构实现起来复杂性较高
扩展的代价也很大
除了硬件的改进
业界在软件方面也在不断地探索
用来平衡CPU和存储器效率的方法
比如动态的访问调度
使得数据访问尽量规则有序
结合缓存技术来提高访存的效率
比如 分支预测 循环展开
等等多种编译优化技术
通过指令调度来减少或者
但无论如何 上述方法和技术
都只能一定程度上缓解冯氏瓶颈
而无法根本克服这一固有的缺陷
目前的计算机产品都是在性能
与复杂度 预期与成本之间折衷的产物
于是呢 人们对新技术的渴望越来越迫切
因而结构创新和新技术的研究不断在推进
比较有代表性的
比如将cpu和存储器集成在一起的PIM技术
比如芯片间的光互联技术
再比如基于纳米电子学
生产频率和带宽更高的存储器件
此外量子计算和生物计算
也完全有可能彻底解决存储墙问题
但总的来说
解决冯诺依曼瓶颈问题任重而道远
一位取名为 思考并快乐着 的同学
在发言中的观点是值得我们共勉的
他大致的意思是
约翰.巴科斯曾告诫我们
它使我们怯于思考更广泛的概念
这是最要命的地方
它限制了人类思考的自由
我们应该不断地进行尝试
从而开创另一片更广阔的天空
我们知道
英文字母一共是26个
希望能够区分大小写
所以我们要区分的这个字母个数
一共是26乘以2
也就是52
对于从信息的角度来看
也就是我要区分52中信息
那我们来看
用5位的位模式能否表示52种信息呢
5位的位模式
我们书写来讲
它能够区分的信息从
5个0开始一直表示到5个1
这中间的信息种类一共是2的5次方
也就是32种
不足以表示我们所有的大小写英文字母
再加一位的话
变成六位的位模式
那么它可区分的信息种类就变成了64
那么64这个数大于52的
足以表示52个大小写英文字符
我这有一个
二进制的加法器
在这个加法器当中
你可以看到它的机械组成当中
有一些木质的开关
这些开关可以倒向左侧
也可以倒向右侧
我在这里用弹珠
是否存在来表示
是0还是1
如果有弹珠 就说这个数值表示1
没有弹珠 表示0
如果我把弹珠倒向这里
木质开关
倒向了这一侧
表示这一位的数值
为1
从这个加法器 可以看到
它是一个6位的位模式
每一位的权值是不一样的
这一位的权值为2的0次方也就是1
第二位它的权值是
2的1次方 也就是2
走到最高位
这一位的权值是2的5次方
也就是32
这一位有弹珠
表示这一位的数值为1
这一位的权值则为32
现在你可以看到这个加法器上
表示的数值为100001
这个数值代表十进制的33
我们来看这样一个装置
它是如何完成自动的
二进制的加法运算的
一个弹珠倒下来表示
这个开关打过来
表示这个数值为1
那么同样的我在这个位置再加上一个1
用二进制的加法来看
1加1就应该得到
10的结果
大家可以看到
权为1的位置上
这个木质开关倒向了这一侧
表示这个数值为0
而在2的1次方 也就是权为2
这一栏当中
这个有一个弹珠
我们说弹珠存在
表示这一位的数值为1
这样也就完成了1加1
等于10的二进制加法
我们再继续看
现在这个
加法器上的数值为10
如果我们再加个1看看这个
它是怎样完成加法运算的
再加1个1
那么这个
加法器上的数值就变成了11
这也就完成了10加1等于11
的这样一个加法运算
如果这个时候我们再加1
我们说这对应的十进制数值就是3了
再加1这个数值变成了4
按照二进制加法 逢2进1的原则
这个结果应该是100
我们来看它怎样完成这种
有进位的二进制加法
我在权为1的圆孔当中
投下了1
大家可以看到 这样完成了
11加上1等于100的加法
也就是3加1等于4
我们希望用二进制的加法器
算一下3加6
那3转换成二进制就是11
我们先把11送入加法器
第二个参加加法运算的数是6
6转换成二进制是110
我们来看这个运算完成之后的
运算结果是多少
大家可以看到这个结果
这一位数值为1的这一位的权为8
而这一位的权为1 相加的结果是
3加6等于9 从这来看
这个二进制的加法器
完成二进制的加法运算
它的运算结果是对的
现在加法器上
表示的就是
以我们目前的表示方法
在加法器上就是一个
它能表示的最大的数
现在我们把这个数送入加法器
这个数在十进制中 应该是63
如果这时候我再加1
这个加法器会发生什么样的情景
你可以看的到
这个时候加法器上什么都不剩了
实际上就变成0了 63加1
因为63加1就是64了
而64
用六位的位模式
以我们这种表示方法
在这个加法器中 没办法表示了
这种现象在计算机中
我们把它叫做溢出
现代计算机
它的存储能力比我这个六位位模式
要强很多
虽然要强很多
但是它依然
有一个上限 有一个界限
就是它能够表示的数的范围和精度
是有限的
无论你是多么强大的计算机
所能够完成的计算的
固有的特点就是
都会有范围和精度的问题
这是你在考虑用计算机
为你完成工作
帮助你学习生活
所都要考虑的一个计算
所固有的一个特点
你要清楚的知道
在电子机械装置上面
完成自动计算 都存在有
范围和精度的问题
那么范围和精度的问题
在我们后续的课程当中都会展开讨论
我们来看10的10次方这个数
前面我们介绍了计数单位
回忆一下 我们用K
这是10的三次方
那么近似的等于2的10次方
我们用M表示10的六次方
近似的等于2的20次方
我们用G来表示10的9次方
2的30次方
这里我计算表示的这个数是10的10次方
我们来计算10的10次方
10的10次方等于10的九次方再去乘以10
这个数约等于2的30次方
乘以2的三次方
这个数是2的33次方
我们来看左右两边
如果我用十进制来表示
和二进制来表示
在物理实现上
我需要多少个物理状态
如果用二进制来表示
2的33次方这个数是
1后面跟上33个0
我用三十四个灯泡来表示的话
每一个灯泡两种开关状态
这里就是三十四个灯泡
一共有六十八种状态
而用十进制来表示10的10次方
是1后面跟上10个0
这是10个0
这是它的十进制表示
这边这是它的二进制表示
如果我用物理装置
如果我能找到
能够表示10个状态的物理装置的话
我需要11个装置
每一个装置有10个状态
这个时候状态总数为110
这就是为什么在101页报告当中
为什么说 二进制的表示更经济
在德国图灵根著名的
郭塔王宫图书馆
保存着一份弥足珍贵的手稿
它的标题是
1与0一切数字的神奇渊源
这份手稿的作者是
德国人 莱布尼兹
二进制的发明者可能
并不是莱布尼兹
但确实是莱布尼兹
总结了二进制的基本运算规则
1674年 莱布尼兹总结了
二进制的概念和二进制的算术运算法则
1945年6月
冯诺依曼和歌德斯坦等人联名
发表了一篇长达101页纸的报告
这个报告被称为计算机史上著名的
一百零一页报告
这份报告奠定了
现代计算机体系结构坚实的根基
也特别强调了
在电子计算机的设计当中
采用二进制的重要性
冯诺依曼在一百零一页报告中
明确指出虽然长久以来
我们的计算习惯
以前的计算工具大多
以十进制系统为基础
但是我们强烈推荐使用二进制
来建造电子计算机
1E20表示1乘以10的20次方
这个运算结果是对的
我们在再来看
加法运算是满足交换律的
我们来把它换一个位置来看
加法运算本身是满足交换律的
我1移到了前方
这个两个运算结果应该是一样的
但是在Python这个计算环境中
为什么我运算结果会不一样
请大家回去分析一下这个问题
我们再看一个实例
我引入了数学库
来计算一下2的平方根
那么下面我们来看2的平方根
我在做乘方运算之后
这个数计算以后就是2的平方根
那么这个数我做乘方运算后
乘方我们刚才说了是两个星号
看它是不是依然与2相等
两个等号表示判断相等
看它跟2是不是依然相等
你看它还回的结果是false
那么今天之后的思考题
就是请你回去思考
为什么Python这样的计算环境当中
会出现这样的错误
这样的错误在计算当中
是固有的现象
那么由于计算所固有这样的特点
那么在你用计算机去解决问题的时候
如果碰到关于数值这类运算
你该怎么去解决这个问题
我在计算机当中怎么真正判断
两个数值是否相等
它的四则运算结合律 交换律
还是不是应该起作用
下面我们讨论
为什么现在电子计算机当中
无一例外都使用的是
01的表示 01的计算
从物理实现的角度来看
我们要找到两个稳定状态是简单的
用电压的高低
电流的有无
电灯的开关都可以表示
两个稳定的状态
相比而言要找到十个稳定的状态
就要困难的多
两个稳定的状态
由此带来的优点包括
可靠性和稳定性都要来的高
从运算规则的角度我们来考虑
对于十进制的加法
刚才大家看到了
加法口诀表
而相比十进制的运算
加法运算规则
二进制的加法规则要简单的多
因而也就简化了运算器
等物理器件的设计
这是计算机的核心
CPU两个非常重要的组件
一个是ALU 一个是CU
ALU的全称指的是
算术逻辑单元
这里L代表的logic是逻辑
这意味着计算机不但能够做算术运算
同样可以完成逻辑运算
我们在逻辑运算当中的真和假
对和错都可以很自然的用0和1来表示
所以使得这样的
电子机械装置完成计算的通用性加强
那么下边我们看这样一个问题
这是一百零一页报告当中的一段原话
它说33位的表示
可以达到10的10次方的大小
二进制系统与十进制系统相比
要来的经济的多
请大家思考
为什么冯诺依曼要这样说呢
计算机当中采用的是01的表示
这种表示使得计算机上的
计算有它独有的特点
你比方说
它跟数学当中的计算是不一样的
数学当中 我们有无限循环小数
和无限不循环小数
像我们有7分之1 我们有π
有像自然对数的底
计算机我们一开始就强调了
它是一个
不管它的存储能力多么强
不管你用一个多大的位模式
来表示这些数 这个位
始终是一个有上限的概念
这意味着对这些无限循环
无限不循环的小数
再进入到计算机
在计算机把它表示出来
那么它跟真正的这个数
从数学上 从理论上而言
它是有误差的 有精度上的损失的
那么跟不用说我们把
十进制的小数转换成二进制
的小数的过程当中
对于有一些数
我们可能找不到等价的转换算法
这也造成了精度上的一些损失
所以这使得在计算机上的
计算跟数学当中的计算
它是不一样的
我们用Python这样一种计算环境
来演示一种现象
大家看 我想计算2的10次方
那么乘方运算在Python
当中是用两个星号表示
这个运算结果是1024
我如果还想完成乘法运算
用3乘以989
那么这运算结果也是正确的
下面我们再看一个带小数点
0.5乘以3结果是1.5
下面我们再看一个简单的运算
0.1乘以3
大家看这个结果是不是出现问题
那你说我们再换一种手段
我不算0.1乘以3
我算0.1加0.1再加上0.1
这结果依然是存在着误差
0.1乘以3是个非常简单的运算
乘法的结果应该是0.3
那么为什么Python
计算出来会有这么一个误差呢
这种现象在基于计算机
这样一些计算环境当中
可以说一种固有的现象
那么下面我们就来分析这种现象
那么在计算机当中
表示数据完成运算都是以01为基础
而人的计算习惯是以十进制为基础
那你的十进制0.1
首先我要完成0.1乘3这样一个运算的话
0.1首先要有它的二进制表示
那么下面我们就来算下0.1的二进制表示
希望由此能够分析出
为什么Python会产生这样的现象
而这种计算所固有的现象
如果不认真的去处理
如果你不理解它
那么很可能会带来一些灾难
请大家做这样一个练习
把十进制数0.1转换成二进制
按照我们刚才的转换算法
可以完成它的转换
1E20表示1乘以10的20次方
这个运算结果是对的
我们在再来看
加法运算是满足交换律的
我们来把它换一个位置来看
加法运算本身是满足交换律的
我1移到了前方
这个两个运算结果应该是一样的
但是在Python这个计算环境中
为什么我运算结果会不一样
请大家回去分析一下这个问题
我们再看一个实例
我引入了数学库
来计算一下2的平方根
那么下面我们来看2的平方根
我在做乘方运算之后
这个数计算以后就是2的平方根
那么这个数我做乘方运算后
乘方我们刚才说了是两个星号
看它是不是依然与2相等
两个等号表示判断相等
看它跟2是不是依然相等
你看它还回的结果是false
那么今天之后的思考题
就是请你回去思考
为什么Python这样的计算环境当中
会出现这样的错误
这样的错误在计算当中
是固有的现象
那么由于计算所固有这样的特点
那么在你用计算机去解决问题的时候
如果碰到关于数值这类运算
你该怎么去解决这个问题
我在计算机当中怎么真正判断
两个数值是否相等
它的四则运算结合律 交换律
还是不是应该起作用
最简单快捷的方法
应该是A
每两个小时重启一次
爱国者导弹系统 我们可以来计算一下
100个小时之后我们的误差
是687米 那么一小时的误差
就是6.87米
那么如果你的运行时间
小于3个小时
那么它的误差应该还控制在
它的杀伤半径之内
小于20米
所以是可以击中目标的
B和C两个选项都可以解决
爱国者导弹的问题
把24位的位模式
改成64位 使得0.1的表示在
爱国者导弹系统当中误差
减小很多
另外通过修改程序
经过一段时间之后对0.1做一个补偿
通过修改程序也可以解决这个问题
但是对这个问题而言
最简便的方法应该是
A选项
每两个小时
重启一次爱国者导弹系统
这个答案是D
大家不要小看这个0.1 这个0.1
也会给计算带来灾难的
在海湾战争当中
爱国者导弹是立了战功的
但是在1991年的2月25号
爱国者导弹 拦截飞毛腿导弹
拦截失败
导致飞毛腿导弹击中了
美军的一个基地 导致了28人丧生
美国政府很快给出了分析报告
分析报告指出
爱国者导弹是因为截断误差
导致了拦截失败
我们具体来分析下这个案例
在爱国者导弹的设计当中
它是用24位的位模式
来存放数据的
而爱国者导弹的计时是以0.1秒为基础的
我们刚才计算过了
计算机无法精确的表示0.1
因为0.1的表示是一个无限循环小数
我用24位位模式表示0.1
在精度上一定是有损失的
0.1秒在爱国者导弹当中
使用的是24位的位模式来存放
它的精度保持到了小数点之后23位
而这个数并不真正等于0.1
所以从一开始
用0.1秒 我们就产生了误差
这是0.1秒的误差
那么经过一秒钟之后
经过一小时之后
一小时3600秒
就是经过一秒之后 经过一小时之后
经过一百小时之后
它的误差已经达到约0.3433秒
而在这次
爱国者导弹去拦截飞毛腿的时候
整个系统已经运行了100个小时
我们来计算一下
爱国者导弹的飞行速度
大概是2000米每秒
0,3433秒的误差
导致了它的飞行由687米的误差
而爱国者导弹
它的杀伤半径是20米
杀伤半径是20米
指的是
如果你的飞毛腿导弹
闯进了我的二十米的杀伤半径之内
我就引爆 我就同归于尽
这就是拦截成功了
而我现在的飞行
有了687米的误差
它就没有能够拦截到飞毛腿导弹
所以飞毛腿击中了美军的兵营
才造成了伤亡
如果你发现了爱国者
导弹的这个问题
那么你觉得该如何解决呢
下面我们给出位模式的概念
信息在计算机内的表示
不管计算机的发展速度多么快
它的存储能力多么强
它依然是个有限的概念
都要考虑我用多少个
二进制位去描述
一种信息 或者一个数
这有一组 一共是八盏灯泡
每个灯泡的亮与不亮
代表着01表示中的0和1
那么这八个灯泡所处的位置不同
它所代表的权值也是不一样的
从右往左 权值依次增大
我先灭了三盏灯泡
如果我用灯泡的亮
来表示1的话
这个灯泡的灭表示的是0
这个数就是11101010
一个二进制位
只能区分两种信息0和1
这就是我们讲的二进制位的概念
通常用小写的b来表示
更多的时候我们是用8个二进制位
也就是8位的位模式来表示信息
通常我们把它叫做一个字节
一个字节指的是8个二进制位
从这大家可以看得出来
我如果就从整数
这个角度来考虑的话
对于8位的位模式而言
我能够区分的信息最小的表示
可以是8个0
一直到最大的数
应该是8个1所表示的
我们可以计算出
八位的位模式
能够表示的信息的种类的多少
这个数应该是2的8次方
这里是256种信息
8位的位模式
可以区分的信息种类为256
下面请大家看这样一个问题
这组灯泡代表的是一个8位的位模式
而这个8位的位模式所代表的数值
计算出来是234
下面有一个问题
如果用位模式来表示
英语当中的字母
位模式最少需要几位
这一单元我们继续0和1的故事
今天我们介绍字符编码
计算机的发明最初确实是为了科学计算
但发展到今天
计算机更成为
我们常用的信息机器
我们使用计算机来处理
各种各样的文档
这些文档有中文的 有英文的
对于英文里的字符如何进行编码
在计算机当中又如何进行处理
这是我们今天这一讲的内容
今天的计算机作为信息机器
可以处理各种各样的数据
这些数据包括数字
数值包括文本信息
还包括有图形图像
音频和视频信息
那么对于数值信息如何表示
如何完成科学计算
我们在前一讲中有所介绍
今天我们来考虑
文本信息这些文本字符包括
中文的 英文的
可能还有其他语言的
这些文本信息在计算机内
是如何被表示 如何被处理的
对于计算机的键盘上
有各种各样的字符
这些字符有一些文本信息
也有一些用于控制的键位
这些键位最终在计算机内部
都会有一个唯一的表示
我们一直都在强调
计算机是01编码
它的母语就是0101的序列
那么最终这些键位
不管是文本的非文本的在计算机
当中如何被表示
这是有国际标准的
那么这个国际标准叫做ASCII码
主要关注西文字符的01编码
键盘上能看到的西文字符包括
大小写的英文字母
包括0到9十个阿拉伯数字
还包含一些类似标点符号
像问号 大于号 小于号
这样一些特殊的符号
这些都是我们讲的可打印字符
同样在键位上还有一些
类似于控制的键位
这些键位包括
回车 换行 删除
这些是不可打印的字符
它是一些控制键位
有一些键位可能还要通过
组合键组合来使用
才能达到完成某个任务的目的
对所有的这128个字符
对于键盘上的所有这这128个字符
在计算机内都有唯一的
01编码与它一一对应
整个字符数目是128个
所以我们说用7位的二进制位模式
就可以把这128个字符表示出来
ASCII的全称
叫做美国信息交换标准代码
取得是它的英文首字母缩写
所以这是通常说的
ASCII码规定了26个英文字母的大小写
0到9十个阿拉伯数字的01编码方式
还包括33个可打印字符包括加减符号
包括加减符号
包括大于号 小于号 问号
这样一些特殊符号的01编码形式
另外还包含了33个
我们前面提到的不可打印的字符
包括键盘上这些回车键位 删除键位
那么它存放在计算机内部
因为ASCII码本身是个7位的编码
所以我们说用一个字节存放就够了
一个字节我们前面介绍过
一个字节指的是一个byte
一共包含8个二进制位
那么在计算机当中存放信息
存放01编码的最小单位是1个字节
而ASCII码有7位
所以在最高位规定恒为0
表示ASCII码
现在计算机不但可以处理英文
同样可以处理汉字
我们上课用的这个讲义
就是以汉字的形式存放在计算机当中
那么这个汉字在计算机内
在你进行处理的时候
同样是以01编码的形式出现
每个汉字它的01编码
是如何进行的呢
除了汉字会在我们的文档中出现之外
在你书写文档的时候
还会出现汉字的注音符
拉丁字母 以及标点符号
这些符号加在一块可能也有六七百个
可能也有六七百个
由此我们可以计算一下
用七位的位模式来表示汉字的01编码
肯定是不够的
我们来看看到底需要
一个字节不够 两个字节呢
我再给它多配几个位模式
是不是就足以表示所有的汉字了呢
我们就以8000个汉字符号为一个界限
请大家计算一下
我如果要表示6 7000的汉字
其它的符号
我们说合在一块一共8000个的话
我至少需要多少位的位模式
我们就假设在一个
用汉字编辑的文档当中
我可能出现有8000个字符
这些字符包括汉字本身
还有一些标点符号
汉字所特有的一些标点符号
包括这个
还包括注音符 我们来看一下
前面我们讲到
西文信息是用七位的位模式
七位位模式可以区分的
类信息种为2的7次方
所以用ASCII码可以区分128种信息
而我现在加上汉字 标点 一些特殊符号
我有8000个需要多少位的位模式
我们可以考虑十位的位模式
对于十位的位模式
我们说可以它能够区分的
信息种类是2的10次方
可以从10个0到10个1
它可以区分的信息种类是2的10次方
这个数我们说表示出来是1024
那么显然十位的二进制位是不够的
十位的01编码是不够的
那么这里跟8000至少差着三位
我们再加三位把它变成13个二进制位
所以能区分的信息种类为2的13次方
它能表示的信息从13个0
这是13个0
那么到13个1
这是13个1
而所有的这些编码形式
它的种类是2的13次方
1后面跟上13个0
这个数的大小就是
2的3次方乘以1024
也就等于8乘以1024
对应于要表示的信息种类是8000
13个二进制位足以表示
我这8000个汉字字符
以及注音符号等等的编码信息的
所以最少需要十三位二进制编码
考虑以后的扩充所以事实上
我们考虑的是十四位二进制编码
由于我们在计算机当中存放的信息
都是以字节为单位
一个字节是8个二进制位
事实上存放一个汉字需要的是
两个字节
也就是我可以给你16个二进制位
我给你16个01编码的位
来表示一个汉字信息
对于汉字的编码我们同样是有标准的
对于我们国家使用的是国标码
全称是国家标准信息交换用汉字编码
我们来看一个例子
看一下 啊 这个汉字的国标码
对于 啊 这个汉字它的国标码为3021H
大家要注意的是我没有把它读成3021
因为后面带个H
而这个H表示这是用16进制
来表示的国标码
而汉字在计算机内的表示
它占用的两个字节
两个字节的最高位都写1
因为我们的汉字用14个
二进制位表示就足够了
我们刚才已经计算过了
我们把两个字节的最高位写1
用来表示汉字
所以 啊 这个字
对于汉字 啊 它的国标码是3021
但是真正它在机内的表示是B0A1
原因是我们把最高位都补了1
补1说明它是一个汉字
那么国标2312码由国家的标准总局发布
从1981年5月1号开始实施
那么国标2312编码主要用在我们大陆地区
也有一些国家像新加坡
也采用了这个编码
对于我国的港澳台地区
采用的汉字编码形式叫大五码
叫big five
GB2312码本身收录了6763个汉字
682个西文字符和图符
使用的是2个字节存放
每个字节的最高位恒为0
对于国标码而言
它的最高位恒为0
但是把它放到计算机内
在机内码的表示中
把最高位写1
用于表示汉字
每个字节最高位恒为1
用于区分中文信息和西文信息
由ASCII码最高位是补0
对于汉字我们把最高位补1
两个字节最高位都补1
表示这是一个汉字编码
那么在这些编码当中
所有的汉字有一个序
对汉字进行了排序
而排序是计算思维一种典型的方法
那排序把一组元素从无序的序列
调整成有序的序列
那么它排序的依据
是根据汉字使用频率的高低
把它分成了两级
那么第一级当中包含有3755个常用汉字
在这些汉字当中
按照拼音字母顺序排列
同音字以汉字笔画排序
笔画的顺序则是横 竖 撇 捺 折
第二级的汉字一共是3008个
按部首顺序排序
与汉字字典使用的方法基本相同
前面我们介绍了
西文信息和汉字信息在计算机
内部的信息表示方法
对于西文信息的表示
可采用ASCII码
同样的对于汉字的
GB2312码也对西文信息的
一些字符进行了编码
所以针对西文信息
也就是我们键盘上出现的英文字符
以及阿拉伯数字
我们不但有ASCII码
GB2312也对它进行了编码
在这个世界上
还有很多其它的语言当中所特有的符号
那么对于这些符号
我们希望能统一它的信息表示方法
由此就出现了Unicode
Unicode对世界上
所有语言的符号进行编码
这些符号组成了通用字符集
你在各种不管是中文 西文 西班牙文
各种语言当中出现的语言上
所要处理的一些字符及符号
都在Unicode当中进行编码
目前应用Unicode的版本
使用的是16位的编码空间
当前版本的统一码
并没有完全使用这16位编码
而是保留大量空间
以作为特殊使用
或者将来扩展使用
这样统一对世界上出现的所有符号
统一进行编码它的好处在于
如果大家都使用Unicode码
那么在你进行编程和信息处理的时候
不再需要考虑平台不同
用的硬件平台不同
软件平台不同
由于用的都是Unicode的编码
那我的程序可能无需修改
对于信息表示部分
可能可以很方便的进行移植
也不需要考虑程序不同
不需要考虑语言的不同
不管你用的是中文系统
还是英文系统
统一采用的都是Unicode编码
对Hello来
看看它的ASCII码的表示
H是大写的H 剩下是小写的e
两个小写的l 一个小写的o
那么它的ASCII码
表示就如下所示
用五个字节我就表示了单词Hello
我们说大写的H它的ASCII码表示
用十进制表示出来是72
而小写的e是101
小写的l是108
小写的o为111
那么更多的时候对应于
ASCII码表示我们采用的是
16进制的表示方法
在16进制中大家可以回忆下
我们讲过的如何把二进制
编码转换成16进制的编码
我们说应该是四位换一位
那么对于大写的H
转换成16进制四位变一位
这个表示就应该是48
小写的e就是65
这是16进制的65
最后一个o是16进制的6F
下面我们使用Dos当中的debug命令
来实实在在的看一下
Hello这个单词在计算机内
用01它到底是怎么表示的
我们可以在开始菜单中
选择运行
在这个小窗口当中输入cmd
进入Dos窗口
进入Dos窗口之后我们运行debug
我们往内存一个数据单元当中
写入Hello这个单词
大家不用关注到底如何往内存单元写单词
我们希望你了解的是
一个英文单词 一串英文字符
在计算机内部它是怎样表示
是怎样的01编码
来表示Hello这个英文单词
这样我就在内存数据
单元里面写入单词Hello
那么下面我们来看一下
真正放在内存单元里的时候
我们强调过所有的数据
不管你是任何类型的数据
不管你是文本 图像 音频 视频
还是参加科学运算
的数值最终都要变成01编码
Hello变成了一串怎样的01编码
我们来看Hello在内存当中的表示
前面这里指的是
这个内存单元的开始地址
我们应该猜的出来
这些表示都是十六进制表示
在这里可看到有A 有C 有F
这是典型的十六进制的表示
48表示大写的H
这是刚才已经复习过的
而65这十六进制的65
表示的是小写的e
那么两个l它的十六进制表示是6C
这是按照ASCII码
它的十六进制表示是6C
到后面这个o是6F
这里你就可以看得到
Hello这个英文单词
在内存当中占据了5个字节
那么它的01表示
用十六进制方式表现出来
就是48 65 6C 6C 6F
我们再来看一下ASCII码表的
一个基本结构
在这张表中
第一行列出了编码当中的高四位
而第一列给出的是低四位
从这个编码表上
可以看出一个基本结构
我们不需要你整个背下
这个ASCII码表的编码表
但是你要知道
它大概的结构是怎样的
一些基本的控制字符
不可打印的字符都放在
高四位编码为0000到0001
就是等于头两列的编码
之后是一些特殊的字符
然后是数字大写字符和小写字符
这里需要你记住的一个键位
就是这个大写的A
请大家查出这个表然后写出
大写字符A的二进制编码是多少
查到了A的01编码之后
我希望你能把它转换成十进制
看看它对应的十进制数应该是多少
A的01编码转换成十进制这个数是65
由此可以看出我的文本信息
事实上都可用某种数值形式表示出来
这在今后的编程当中很有用
那么在介绍计算机如何完成减法之前
我们先来看看
计算机中是怎么表示一个数的
这些数值
在平时所进行的科学运算中
有很多的数
这些数值
一定要在计算机内有编码
一定要在计算机内部有表示方法
才能被处理
我们先来看信息的表示
信息一定要先被表示
有了编码方式之后
才能够被处理
而由于计算机它自己的特点
所以编码最终得到的结果会是0101
那么无论是数值数据
还是其它的数据
都有同样的问题
对于数值数据如何表示
这类问题叫做计算机码制
在我们平常完成的科学运算中有很多数
这些数
在计算机看来
都是一些要处理的数据对象
这些数据对象在计算机内
要能够完成一个处理的流程
首先要有一种编码的方式
我一定要有特定的01串
去表示它
最终才能完成一个计算处理的过程
这种就是数据表示的问题
而计算机所要表示的数据
有很多种类
有数值数据
有文本信息
现在而言还有图形图像
音频视频的信息
这中间都存在着数据表示
也就是编码的问题
我们做算术运算时
数都是有正负的
我有正数 有负数
那么在计算机内部我们说了只有01
怎么样来表示一个数的正负呢
通常的情况下
是我在存储空间中
专门拿出一个二进制位来
这一位就表示符号位
用0表示正数 用1表示负数
一旦我们用01来表示正负
我们就把这个数叫做机器数
把数的符号
数值化的数据表现形式
我们把它叫做机器数
而原来我们所写的带有正负号的数
把它叫做真值
这就是我们讲的
用二进制所表示的两个真值
真正把它存放在计算机中
我们说正负号要用01来表示
由此我们就得到了机器数
在机器数中 0表示正
而1表示这是一个负数
我们再来看编码的方法
我们在这里介绍两种编码方法
一种是原码
计算机的原码表示是
从二进制表示出来最自然的方法
在N位的原码表示方法当中
最高位是对符号部分进行编码
一定有一位是符号位
符号位的表示
无论是哪种编码方式都是一样的
用0表示正 1表示负
剩下的n减1位
则对数字部分进行编码
这种编码方法
跟原有的数字部分是相同的
如果它的数字不足n减1位
在高位进行补零
补足至n减1位
在这种表示方法中 你可以感觉到
数值零的原码实际上有两个
有正零
同时有负零
我们举两个例子
来看一下原码的表示方法
假设采用八位的原码表示
两个真值数
一个是正的101
另一个是负的1010
八位的位模式
是一个字节
这个字节中有八个位
八个二进制位
那么在这八位的位模式中
头一位是符号位
那么剩下的七位用来表示数值
对于x而言
首先符号位为零
而这个数值为101
它不足八位
我们在高位用零补齐
这里需要补四个零补齐八位
这就是八位位模式下
x这个数值的原码表示
再来看y的原码表示
y的原码表示中
同样地先处理符号位
为负数的符号位为一
而它的数值是1010
同样地不足八位
高位用0补齐
这里需要补上三个0
这就形成了y的原码表示
原码表示有一些优点
它非常简单直观也容易理解
但也有一些缺点
第一大缺点就在于
它做加法和减法运算是
比较复杂的
因为要对符号位进行处理
还要判断数值的绝对值大小进行判断
我们通过一个例子来看一下
为什么说用原码进行加减运算
是比较复杂的
首先要对符号位
和数值的绝对值大小进行判断
首先在做加减运算前
你首先要确定符号位
如果是两个正数相加
如果是两个负数相加
如果是异号的两个数相加
我该怎么办
如果是两个异号的数相加
事实上是要做减法
我首先是
要比较出两个数绝对值的大小
决定出符号位是什么
符号位出来之后
我再继续做减法
最终得到一个运算结果
所以这个过程并不简单
我们刚才提到零的形式不唯一
我们来看
在原码的表示方法中
不管你用多少位来表示一个数
0有两种表示方法
有正0 有负0
所以意味着
我们事实上是一个数据对象0
但是映射到符号编码之后
有了两种编码方式与它对应
这都是原码表示的一些缺点
为了简化加减运算
也为了使编码表示更加精准
我们引进了新的机器数的形式
也就是补码
那么可能有的同学已经在开始考虑了
就是减法怎么办呢
我们先来看看帕斯卡
帕斯卡这样一个机械的自动加法器
它是如何完成减法的
我们通过这个动画来看一下
帕斯卡的运算器怎么做减法
大家注意看这个上面
现在你可以看到五个0
在做减法时它会做一个切换
把它切换到五个9
大家注意看
切到五个9了
然后它就会考虑开始做减法
它要算的这个数据是
31减掉16
我们来看看它是怎么做减法的
大家特别要注意的是
它输入31的方式
跟我们前边的是不一样的
齿轮转动的时候
是从这个齿轮的最下面
按照顺时针的方向
一直转到3这个位置停止
这跟我们输入加法运算数不一样
加法运算数是直接数到3
然后一直把它
按顺指针方向转到1
一会儿我们再来看
它为什么要这样做
我们继续把这段看完
而它输入1的情况你也可以想象到了
在做加法时我们输入1
是从这里开始
顺时针方向走一格就可以
然而在做减法的时候
31的一位上的输入
是从根部这个位置
绕一大圈到1这个位置
这是1的输入
可以看到
上面显示输入的数值为31
再来看减16是怎么做的
你看它在减16时并没有把1
从根部开始绕一圈
它是按正常的加法运算的1来表示
从1顺时针走一格走到根部
可以看到 它直接走到了根部
而这里16一样的
按加法运算的6的输入
这时候大家可以看到
上面已经给出了运算结果
就是15
下面我们来分析一下
帕斯卡的计算器
它到底怎么做减法
我们现在同样的来考虑31减16这个减法
来看看人是怎么做31减16的
31减掉16
我们的计算过程
是从最末一位开始
也就是从个位开始
个位上就应该做1减6的动作
而这里1减6减不够
所以只能从三上借一位
所以这个减法就变成了
11减6
这个数值为5
而3因为借走了一位则变成了2
2减1得到的结果就变成了15
这就是我们完成31减16的过程
做这个减法的过程中
可能大家已经看到了 借位很棘手
我怎么能不借位就
完成减的动作呢
在这个例子中
都是两位数 对于两位数而言
减法要保证不发生借位
那么最大的数就应该
用最大的数去减 这个数应该是99
所以不管你减法减多少
只要它是两位数
我用99去减 一定不需要借位
那我们看这个减法变成了什么
我要算的是31减16
在31减16的时候
我发生了借位
而我觉得这个借位很难处理
我希望用99减16
这个式子要两边相等的话
31减16还在
因为我多加了一个99
那我干脆再多加一个
这等于我加了一个一百
再减去一个一百
这样 我这个等式两端依然相等
这时我继续
往下算 这个式子就变成了31加上
由于我在这里选的是99
如果减数是一位数
那么选九就够了
如果减数是三位数
那就得选999
总之 我要保证
不需要借位就能完成这个运算
这个地方就变成了83加1
减100
同样地 这个加起来就变成了
115减100
所以最终的结果是15
所以这样我们就把借位的情况处理了
因为借位
如果你要用电子机械装置去
完成这个借位操作的话
这并不是一件简单的事
所以帕斯卡这样处理加法器
这里的基本思想
就在于补数的概念
我们现在先介绍
什么是9的补数
之所以把它叫做补数
是为了区分于后面将要讲的补码
我们这里都是十进制
我用C来表示补数
用9表示是表示关于9的补数
而在关于9的补数中
我们这里用到了9 99 999
所以这里用1表示
一位的9对a的补数
对于它而言 它的补数就是9减a
假设a等于3
在a等于3的情况下
那么它的补数应该是9减3等于6
我们再来考虑多位的
这是一位数字的补数定义
我们再来看多位的
这个补数的概念就应该是
10的N次方减1减a
再往下算我们可以算出
C 9 N
如果我要做减法的话a减b
就应该等于10的N次方减1减括弧的a减b
再往下推算就变成了
10的N次方
减1减a加b
大家来看
这串数值实际就是
a本身关于9的补数
所以它就变成了C9N a加上b
这里的核心思想在于
我本来是做的一个减法
我本来是需要做a减b的
但通过补数的运算
最终把它转换成了一种加法
这是其一
其二的话 你看一位操作数
就变成了a的补数
最终我们要在帕斯卡计算器上
完成31减16的计算
它对31做了一个特定的处理
这个处理事实上就是求出了
31的补数最终与16进行相加
最终得到31减16的运算结果
那么对于计算机而言
它完成加法的时候有加法器
我们一起开始就讲了
在冯诺依曼计算机当中
很重要的运算部件就是加法器
计算机做减法的基本思想
事实上就借鉴了
我们刚才介绍的补数的思想
就是我要想办法把减法
也要变成加法
然后用同一套电子线路
同一套硬件装置
同样地可以完成加减乘除
多种多样的运算
无论是哪一种编码表示
符号位的处理相同
数的最高位依然为符号位
用0表示正数 用1表示负数
数字部分则与它的符号位相关
对于正数
补码的数字部分与原码相同
而对于负数
补码的数字部分
是将原码的数字部分按位取反加1
补码又如何转换成原码呢
对于正数而言这是一样的
原码的数字部分
因为与补码的数字部分相同
所以表示形式一样
对于负数而言
原码的数字部分是
将补码的数字部分
按位取反再加1
所以
从一个负数求它的补码是
按位取反加1
而从补码换回到原码
同样是按位取反再加1
下面我们看一个例子
我们依然采用八位的位模式
这次我们练习补码的表示
x的真值为正的1101
对于正数而言
它的原码表示
和补码表示是一样的
符号位处理为零
原有的数字部分
1101落下来
缺位的地方高位补0
同样 可以得到x的补码表示
对于正数而言 它跟原码一样
我们再来看一个数
y等于负的1110
在原码表示中
符号位处理为1
原有的数值不做任何变化
记录下来
缺位的位子补0
这样我们就得到了y的原码表示
我们再来看补码的表示
符号位为1
而在补码表示中
由于这个数是负数
所以它原有的位置要
按位取反再加1
原有的0变成1
原有的三个一则变成了0
按位取反
最后一个0变成1
这是按位取反
按位取反后还要加上一个1
最末位为1 再加上1个1
则变成了10
所以最末两位发生了变化
变成了10
我们再来考虑
现在知道了y的补码是
我们来看怎么求回它的原码
我从补码出发
考虑能不能求回它的原码
这个动作依然是取反加1
符号位不动
按位取反之后
三个1变成了三个0
剩下的
碰到0 变成1
1变成0
0变成1
之后
到了这一位取反的结果
还要继续加1
1加1则变成了10
那么在介绍计算机如何完成减法之前
我们先来看看
计算机中是怎么表示一个数的
这些数值
在平时所进行的科学运算中
有很多的数
这些数值
一定要在计算机内有编码
一定要在计算机内部有表示方法
才能被处理
我们先来看信息的表示
信息一定要先被表示
有了编码方式之后
才能够被处理
而由于计算机它自己的特点
所以编码最终得到的结果会是0101
那么无论是数值数据
还是其它的数据
都有同样的问题
对于数值数据如何表示
这类问题叫做计算机码制
在我们平常完成的科学运算中有很多数
这些数
在计算机看来
都是一些要处理的数据对象
这些数据对象在计算机内
要能够完成一个处理的流程
首先要有一种编码的方式
我一定要有特定的01串
去表示它
最终才能完成一个计算处理的过程
这种就是数据表示的问题
而计算机所要表示的数据
有很多种类
有数值数据
有文本信息
现在而言还有图形图像
音频视频的信息
这中间都存在着数据表示
也就是编码的问题
我们做算术运算时
数都是有正负的
我有正数 有负数
那么在计算机内部我们说了只有01
怎么样来表示一个数的正负呢
通常的情况下
是我在存储空间中
专门拿出一个二进制位来
这一位就表示符号位
用0表示正数 用1表示负数
一旦我们用01来表示正负
我们就把这个数叫做机器数
把数的符号
数值化的数据表现形式
我们把它叫做机器数
而原来我们所写的带有正负号的数
把它叫做真值
这就是我们讲的
用二进制所表示的两个真值
真正把它存放在计算机中
我们说正负号要用01来表示
由此我们就得到了机器数
在机器数中 0表示正
而1表示这是一个负数
我们再来看编码的方法
我们在这里介绍两种编码方法
一种是原码
计算机的原码表示是
从二进制表示出来最自然的方法
在N位的原码表示方法当中
最高位是对符号部分进行编码
一定有一位是符号位
符号位的表示
无论是哪种编码方式都是一样的
用0表示正 1表示负
剩下的n减1位
则对数字部分进行编码
这种编码方法
跟原有的数字部分是相同的
如果它的数字不足n减1位
在高位进行补零
补足至n减1位
在这种表示方法中 你可以感觉到
数值零的原码实际上有两个
有正零
同时有负零
我们举两个例子
来看一下原码的表示方法
假设采用八位的原码表示
两个真值数
一个是正的101
另一个是负的1010
八位的位模式
是一个字节
这个字节中有八个位
八个二进制位
那么在这八位的位模式中
头一位是符号位
那么剩下的七位用来表示数值
对于x而言
首先符号位为零
而这个数值为101
它不足八位
我们在高位用零补齐
这里需要补四个零补齐八位
这就是八位位模式下
x这个数值的原码表示
再来看y的原码表示
y的原码表示中
同样地先处理符号位
为负数的符号位为一
而它的数值是1010
同样地不足八位
高位用0补齐
这里需要补上三个0
这就形成了y的原码表示
原码表示有一些优点
它非常简单直观也容易理解
但也有一些缺点
第一大缺点就在于
它做加法和减法运算是
比较复杂的
因为要对符号位进行处理
还要判断数值的绝对值大小进行判断
我们通过一个例子来看一下
为什么说用原码进行加减运算
是比较复杂的
首先要对符号位
和数值的绝对值大小进行判断
首先在做加减运算前
你首先要确定符号位
如果是两个正数相加
如果是两个负数相加
如果是异号的两个数相加
我该怎么办
如果是两个异号的数相加
事实上是要做减法
我首先是
要比较出两个数绝对值的大小
决定出符号位是什么
符号位出来之后
我再继续做减法
最终得到一个运算结果
所以这个过程并不简单
我们刚才提到零的形式不唯一
我们来看
在原码的表示方法中
不管你用多少位来表示一个数
0有两种表示方法
有正0 有负0
所以意味着
我们事实上是一个数据对象0
但是映射到符号编码之后
有了两种编码方式与它对应
这都是原码表示的一些缺点
为了简化加减运算
也为了使编码表示更加精准
我们引进了新的机器数的形式
也就是补码
我们下面考察一下补码的表示范围
在位数相同的条件下
我们来看看补码的表示
跟原码的表示
有什么分别
我们考虑三位的位模式
三位的位模式
所能表示的所有的码制
包括三个0 001
010 011 100 101 110 111
所以三位的位模式
严格来讲我们可以区分的是
2的3次方
一共是八种信息
如果是三位的位模式
我们用来表示数的话
还要拿出去一个符号位
所以这里如果我们用补码表示的话
我们可以看到
它表示的数值的大小
000很明显表示的是正0
001表示的是正1
010表示的是正2
011表示的是正3
再往下
就到了100
100我首先可以确定它是一个负数
因为它的符号位为1
我们现在需要确定
它表示的是多少
我们先把100放在这里
我现在只知道它表示的是一个负数
我先看101
101是一个负数
这是我的位模式
如果这是它的补码表示的话
我希望能够计算出
它所表示的数是多少
如果补码表示为101
第一个1表示是负号
后面我要求出
这个原有数值的大小的话
101本身就是负号
而后面则要取反加1
取反变成1
1变成0 再加1
这个数就变成了11
所以这个数就应该是负3
再来看110
第一个1表示这是一个负数
后面是10
那我要求出原有的数的大小
也要进行取反加1的动作
则变成了01
取反再加1
取反是10取反变成01
再加1则变成10
所以这是负2
我们再来看
最后一个补码是111
第一个1表示负号
后面的编码是11
如果11是补码表示
我要求出它原有数的大小
要进行取反加1
它取反之后的结果是00
再加1则变成了01
所以这个数表示负1
最后我们再来看100这个数
第一个1代表负号
后面的编码是00
我要求出它能表示的
原来的数的大小的话
要进行取反加1的动作
00就变成了11
再加1的话就变成了100
所以这个数代表的就是负4
100表示的是4
这样你可以看到
在补码表示方法中
我们可以看到
0的表示是唯一地
从这里我们可以看出
三位的位模式所表示的数的范围
是从负4到正3
正好是八个数
我们可以用一个
类似于时钟的盘面
来表示
四位位模式的补码表示
可以看到四位的位模式
能表示的最小的数是负8
最大的数是正7
所以这个表示范围是
从负8到正7
我们再来看八位的位模式
在所有的补码表示中
不管你是三位 四位 还是八位的位模式中
0的表示都是唯一的
对于n位的位模式而言
如果你用补码表示的话
那么它所能表示的最小的数
就是负2的n减1次方
而能表示的最大的数
则是正的2的n减1次方减1
所以这里一共就是
2的n次方个数
你所表示的数
与我们平常科学运算中
的数是一一对应的
下面请大家计算一下
负57的8位补码表示
下面我们就来考虑
有了补码 大家可能已经认识到
这个补码和我们
上面在帕斯卡加法器中
讲的补数有类似的地方
最终的目的都是希望
把减法转化成加法来实现
减法是否可以用加法实现呢
我们通过一个简单的例子来看
我这里有一个时钟
它现在指向了六点
但标准时间应该是四点
我的表快了两个小时
怎么想办法
让它跟北京时间同步呢
你可能首先想到的是
快了两小时 就把它拨慢两个小时
我做减法
用6减2把它拨回到4
这样 我们就可以
把时间调整到四点
还有其他方法吗
除了往后拨两个小时 使之到达四
能把时间调同步
是不是还可以继续往前走呢
一方面6减2等于4
我往前一直拨十个小时
六点再拨六个小时就到了十二点
再拨四个小时
就到了四点
所以 沿着顺时针
让它再前进十个小时
是不是也到了四点
这两个动作可以这样来写
第一种方法是做减法
把它往后拨两个小时
这样它就跟北京时间同步了
变成了四点
还有一种方法是
往前拨了十个小时
这样 6加10本来应该是16的
但由于这是十二点的钟面
它最终以十二为模
取了它的余数
做的操作是16减12
最终得到了4
而前面这个操作
我们同样可以进行改写
一样地
也把它做取模的动作
一12为模 余数是
6减2 为4
这就是我们讲的同余
从同余的角度来说
负2与正10是同余的
负2
以12为模求它的余数是
12减2等于10
而10
以12为模取余数也是10
正是因为这样一种操作的存在
这样 6减2这个动作是做减法的
我就通过6加10
把它做了一个实现
核心思想就是
存在12这样一个模
而在计算机中
模是一定存在的
在表示一个数时
我所能表示的最大的数
是有限的
正是因为这个模的存在
依据同余理论
我们可能把减法改造成加法
两个整数a b
如果它们除以整数m
所得的余数相同
则称a b对于模m同余
而我们刚才提到了在计算机中
这个模是一定存在的
因为计算机当中
无论你是用一个字节
两个个字节去表示一个数
它总有一个最大的框框在这
就像我们这个盘面上
最大就只能到十二了
每台计算机当中
都有这样一个模存在
这种情况我们把它叫做
a与b关于模m同余
在模为M的情况下
减法a减b就可以用
a加b的补数来实现
所以 补码的定义也可以写成这样
一个数的补码等于什么
等于2的N次方加上X
然后以2的N次方为模取余数
假设我们就用一个字节
来表示一个数
采用补码的表示方法
这个模就应该是2的七次方
下面我们看一个例子
如果我的模是2的七次方 即128
那么负1以128为模
它的余数就是
2的七次方减1 即127
而127 以128为模
它的余数也是127
下面我们考虑做2减1的动作
我做2减1事实上就等于
用负1的补数
也就是127
127跟负1是同余的
用2加上127
再以128为模取余数
这样就得到最终的运算结果为1
这样我就避免了做减法
而把所有减法都变成了加法运算
下面我们来看补码的运算
按照补码刚才根据模和同余理论
所给出的定义公式
我们可以推倒出
补码的一些基本运算规则
补码的这种表示方法
可以简化加法的运算
并且可以将减法变成加法
我们对第二个公式进行推倒演示
x减y的补码
按照补码的定义它应该等于
2的n次方加x减y
最后以2的n次方为模取余数
对于这样一个数值
我们2的n次方加上x
因为是以2的n次方为模取余数
所以我在前面加上2的n次方
是没有影响的
这样
这里就可以看出
这一部分就是x的补码
后面这一部分
则为负y的补码
由此 我们可以证明
胶片上的第二个公式
所以 采用补码进行加减法的运算
在计算机中只需要一套
实现加法运算的线路
从而简化了计算机
内部硬件电路的结构
下面我们做几个练习
我给了你两个真值 让你来求a加b
这个表示上我们采用五位的位模式
在求解的过程当中
实际上我先求出a加b的补码
那么a加b的补码是
等于a的补码加b的补码
而a是一个正数
所以它的补码不变
而b是一个负数
那么符号位之后
原有的数值要进行取反加1的动作
得到这两个补码之后
剩下的动作就是把这两个补码
a的补码加上b的补码
进行加法运算
这样 我就得到了
a的补码加b的补码的
加法运算结果
这时候要特别注意的是
这时候算出来的是
a加b的补码
而我最终要求出a加b
还要进行取反加1的动作
由此取反加1 我就可以算出
a加b最终的结果是负11
你可以用十进制来验算一下
这个结果是不是正确的
我们再看第二个例子
这个例子当中我们给出了两个正数
但要求做a减b
根据刚才所推倒的公式的结果
a减b
我首先计算的依然是a减b的补码
算出补码之后
再进行取反加一
得到它原有的数值应该是多少
a减b的补码就等于
a的补码加上负b的补码
那么a的补码
因为a是个正数
所以数值是容易求的
而对负b的补码
b原有是正数 而负b就变为负数
那么你求它的补码时候
要进行取反加1的动作
那么这样我们就可以
完成一个运算
由此 可以得到
a减b的补码
再来看第三个例子
a为正数 b为负数
但要做a减b的动作
a减去一个负数
等于a加上一个正数
最终要求a减b
同样地利用我们刚才
所验证的这个公式来进行
a减b的补码
就等于a的补码加上负b的补码
而在这里的b是一个负数
再求一次负则变为正
所以两个补码都是正数
就可以直接用加法运算
运算出它的结果
要把一个正数转化成原码较为容易
所以这里要特别强调的一点就是
在补码运算中符号位参加运算
如果符号位的运算产生了进位
这里无需考虑
产生了进位意味着
再往前没有位置存放这个进位了
这个进位直接丢掉就好了
这是我们刚才所用的
两个基本的完成运算的公式
从这个例子当中我们可以看的到
a是一个正数b是一个负数
这两个数相加
符号位同样地参加运算
符号位产生了进位
这个进位直接丢掉就可以了
因为计算机中
我就用五位的位模式存放了一个数
在符号位上又产生了进位
这个进位没地方存放 直接扔掉
但并不影响计算结果的依然是正确性
我们一直都在强调的是计算机
无论现在发展速度多快
它用来存放一个数的空间有限
就是它能够表示的最大的数有限
两个大数相加都有可能产生溢出的情况
那么我们在计算机中会有
正溢出和负溢出
正溢出指的是
加数和被加数的符号位为零
但是加完之后
结果的符号位为1
这就是正溢出
负溢出则指的是
加数和被加数都是负数
符号位都为1
但是完成加法运算之后结果的符号位为0
这就是我们所讲的负溢出
这是两种溢出的情况
溢出 是计算固有的一种特性
在很多时候你要
解决现实和科学运算中的一些问题
都要面对溢出的现象
下面我们来看数值信息在
计算机中是如何表示的
计算机中有各种各样的数据
计算机中的数据包括有
文本的数值的图形图像的
还包含很多音频 视频的数据
今天我们来考虑
真正的数值信息
在计算机中如何表示
特别是像小数点我们该如何处理
我们首先介绍定点数和浮点数
这个点指的就是小数点
计算机中能够处理的数据一般包含
整数部分和小数部分
如何表示小数点
就成为一个问题
根据小数点的位置是否固定
将数分为定点表示和浮点表示两类
定点数和浮点数
代表数值的两种不同表示
它们由原码或补码构成
我们先来看定点数
定点的含义就是
小数点的位置是不变的
实际上定点数就是用来表示
整数和纯小数的
这种表示方法中
小数点的位置是固定的
并且是隐藏起来的
并不是说
用一个二进制位
把一个小数点存放在里面
而是跟计算机约定好
小数点的位置是在这里
并没有用一个二进制位表示
一个定点数只包含一个编码
定点的正数指的是
小数点固定在数的最低位之后
这种表示叫做定点整数
你可以看到
我用一组二进制位
这就是我们讲的位模式
我用这样一个位模式
来表示一个整数
这种叫做定点整数
约定好小数点的位置就在这里
前面最高位为符号位
剩下的是它的数值部分
而小数点就是这个位置
我们约定好它就在这个位置
而定点小数指的是
小数点固定在数的最高位之前
符号位之后
在这样一个位模式中
你可以看到
最高一位为符号位
我们的约定的小数点就在这个位置
这时候你可以看到
它表示的这个数是个纯小数
而后面这些位置
都是小数点之后的数值部分
用定点数可以表示一个整数
也可以表示一个纯小数
对于其它的小数怎么办
这里采用科学计数法的形式
我们把一个有小数点的数
进行一定的变换
最终使它能够用
定点整数和定点小数来表示
我们来看一个例子
假设这里有一个二进制小数
101.11
我们试图用科学计数法把它表示成
0.10111
这是个二进制的数
不是十进制的数
所以它的位权
每一位移动都是2的倍数
以2为权
这里我们可以看到
小数点被移动了3位
那这里就要加2的3次方
3在二进制中的表示是11
这样你可以看到
这就是我们的定点小数
而这就是我们的定点整数
这样我就可以用
一个定点小数再加一个定点整数
表示一个浮点数
所以用科学计数法
我们可以把任何一个二进制的浮点数
进行一些变换
变成用一对定点数
来表示一个浮点数
这一对定点数 一个是定点小数
一个是定点整数
所以 浮点数
是由尾数m和阶码e两部分组成
r不用表示
因为它本身是基于二进制的
位权一定是以二为基底
通常尾数用纯小数表示
由原码或者补码来表示
阶码是整数用补码表示
我们可以看一下
浮点数在计算机存储器中的表示
这时候 有可能有两个符号位
一个是 阶码本身有符号位
刚才我们做的2的3次方
这个3是正3
用二进制表示是正的11
所以这个地方 阶码本身有符号位
阶码本身有符号位
我们把它叫做阶符
阶码11也就表示在这个位置
而这个数本身一定也有符号位
后边就是小数
就是科学计数法中的尾数部分
通常
我们会把尾数部分
浮点进行规格化
规格化的含义是
如果一个非0浮点数的尾数
最高位为1
我们就称之为浮点规格化数
计算机内部
浮点数都是以规格化的形式出现的
我们下面来看一下
怎么做规格化
假设这里有一个二进制浮点数0.0011
我们来看如何把它做规格化
规格化的目的是使小数最高位为1
同样的通过科学计数法移位
可以把它变成0.11
意味着小数点向右移动了两位
实际是把原有的小数扩大了
下面 这个阶码是不是应该为负呢
同样是二进制 以2为基底
而这时小数点是向右移动了两位
这时就要乘以负的2次方
而2在二进制中是10
这样我们就把0.0011进行了规格化
使得它尾数部分最高位为1
我们来看一个例子
十进制256的浮点形式是什么样呢
首先要把它转换成二进制
256是2的8次方
2的8次方指1后面有8个0
而0.5在二进制中表示是0.1
第一步用科学计数法对尾数规格化
这样 我们就得到
它的阶码为9
表示成二进制是1001
我们假设阶码1001
用八位的二进制表示
尾数用十六位二进制表示
它的浮点表示形式应该是
下面这样
对于这个数而言
阶码为正数
所以最高位为0
这时整个数的符号也为0
所以整个256.5
用二进制24位位模式来表示的话
就应该是这样一种情况
这个零指符号位
而我们约定的小数点就在这里
后面是它的数值部分
IEEE给出了浮点数表示的754标准
单精度的浮点数使用的是32位
使用32位的位模式存放一个浮点数
叫做单精度浮点数
在这种表示方法中
最高位为整个数的符号位
使用八位来表示阶码部分
使用23位来表示数的尾数部分
而用64位的位模式表示一个浮点数
叫做双精度浮点数
最高位为数的符号位
之后是11位的指数部分
和52位的尾数部分
这个答案是D
加减法用的是
同一套电子机械装置
同一组硬件电路
下面来考虑乘除怎么办
减法的情况解决了
还有乘法和除法
我们分别来看一下
我们下面举例来看一下
二进制完成乘法这样的一个过程
再来考虑
这样一个过程
是不是有了加法器就足够了
我们计算十进制的13乘以11
13 对应二进制的1101
而11对应1011
我们来看它完成乘法的过程
最末位为1
所以首先下来的是1101
乘数的2的1次方位
权在这个位置 也是1
所以这里同样是1011
而第三位为0 那么意味着
这组数值为0 2 3 4
最后一个1代表1101
可以看到
这三行虽然都是1101
但它们代表的数值不一样
比如 第二行的数值代表11010
而最后一行代表1101000
所以 你看到的是什么
这样斜位下来
最终要完成一个乘法结果是
最后这四列我们完成一个加法的运算
而三个1相加后产生了进位1
这里产生了进位0
同样地产生了进位0
这是最后乘法运算的一个结果
我们考虑这个乘法运算
一个是 你可以看到
它是什么 是不是被乘数
我在这里做相加运算的这些
实际上都有被乘数的影子
事实上指的都与被乘数的移位和相加
所以通过这个例子可以看出
二进制的乘法运算是什么
二进制的乘法运算就是被乘数的移位
然后再进行相加的动作
所以 无论是移位还是相加
用加法器来做就足够了
我们再来考虑除法的情况
除法的二进制基本运算规则是简单
我们来看胶片上的例子
从这个例子考虑完成除法的过程
可以看出
除数的移位
然后与原有的被除数
做减法的这样一个过程
所以归根到底说
有四则运算加减乘除
但事实上我有一个加法器
就方便地实现了
减法 乘法和除法运算
计算机有计算机图形学
它可以画出很多绚丽的图片来
现在这里有一个图片
我希望你能用Scratch 用BYOB把它画出来
分析这个图片你会看的出来
这里面最基本的元素是什么
最基本的就是一个一个的圆
你可以看到这里由一个一个的圆来组成
分析这个图片
它就是画了一组圆
一个一个这样的圆
你数出来的话 这里面实际上是十八个圆
所组成的一幅图片
那么下面就是
我怎么把这十八个圆能够画出来呢
用Scratch怎么把这十八个圆画出来呢
仔细分析这个图片
发现这个图片就是十八个
特殊的圆所组成的图片
我们下面的问题就变成
我怎么样把圆画出来呢
我怎么把这十八个圆
组合在一起能够形成这个图片呢
现在的根本问题
就是计算机怎么能自动的把圆画出来
在Scratch当中并没有直接支持
画圆的命令
你能说精灵前后左后移动带着一支笔
我可以画出一些图片来
它没有直接画圆的一条指令
我们怎么能真正实现画圆呢
我们怎么能够真正的把这个圆画出来呢
我们先来看
先看简单的
这个正方形我们能不能画出来
我们先来考虑如何画出一个正方形
那么程序的开始
我们已经习惯于
当这个绿色的旗子被点击的时候
代表着程序的开始
既然要画图 那这支笔要放下来
我们在这里设置笔的颜色为
蓝色
我要画一个正方形
事实上是画四条线首尾相连
我们可以考虑画四条线是可以的
我现在在（0，0） 这个位置
有了起点 我给它一个终点
下面我就可以画出一条线来
我现在是在（0，0）这个位置
我计算四个顶点的坐标
可以把这个正方形画出来
假设我这里用 x是50
y是0
实际上是往右走画一条线
走到（50，50）这个位置
我们又可以画出一条线
走到（0，50）
最终回到原点
实际上是我们规定了精灵
它走了一个正方形
所以最终它画出来一个正方形
精灵太大了 我们把它隐藏起来
不要让它出现
双击我们就可以画出这个正方形了
大家想想看
有没有其它的方法画出正方形呢
我们考虑它是不是还有其它的方法
是要考虑还有没有更一般化的方法
能够使我的程序看起来更加简洁
我们换一种思路来考虑
在我们特定的BYOB的环境当中
在所有的计算环境当中
都是两点决定一条线段
我们特殊的在于小精灵是会动的
我可以通过转弯
前进的动作来完成一个正方形
那么我们来看
我们仔细分析
现在精灵不见了
我们把精灵弄出来
相对于正方形而言 有点太大了
我们把它缩小
到原来的百分之三十
那么这个精灵我是可以运动的
而在我的运动的过程当中
因为我带着笔
所以可以把运动路线画出来
你可以看到
我们画这个正方形的动作可以看做是
向右前进
然后左拐
左拐只是一个转向的动作 转
向之后又是前进
前进然后又左拐
又前进 又左拐 又前进
实际上这个动作
严格来讲就是一个组合 两个动作
左拐和前进
实际上是完成了
我画正方形的过程
我们把这个size放在这里
画笔的颜色没有变
我们换一个起始位置开始
我们从一百
开始画正方形
这个时候我们换了一种方式
现在这个舞台上有点乱
我们用画笔当中的clear这个命令
把屏幕清理一下
那么下面我不再用这组指令
我不用两点决定一条线让它这样走
我们用左拐前进 前进左拐 重复四次
最终完成了
正方形的画法
我们用到循环 重复的动作
这个动作要重复四次
最终完成画一个正方形
我的动作在于前进
依然前进五十步
前进五十步之后左拐
拐多大的角度
拐九十度 换一个方向
我们来运行这个指令
可以看到它也完成了画正方形的动作
我现在在考虑其它的正的多边形
我有没有可能画一个正的六边形
我们说这是可能的
我们把这个起始的坐标
让它重新回到原点放到中间 好看一点
我们让它重复
六边形重复六次
我们如果每次还是五十步不变的话
每次转就不是转九十度了
而是转六十度
我们来看这个时候
它画出来的是什么样的图形
它画出来一个正的六边形
我们继续扩大
既然有正六边形
我们看看正十二边形会变成什么样
正十二边形当中
每次它转的角度就没有六十度这么大
只有三十度
我们把这个
每次前进的步数缩小一点 改成二十步
这是正十二边形
有的同学是不是已经意识到
我们要干什么了
这个正十二边形是不是跟圆就很接近了
我们再继续逼近
我们让它画出正三十六边形
每次转的角度只有十度
同样的把前进步数缩小
我们来看它的变化
可以看到到正三十六边形时
已经很像一个圆了
每次让它转一度来看
每次转一度 而把这段重复三百六十次
意味着我也转了
三百六十度
每一次走的步数两步就好
我们可以看到这段程序的指令
可以看到它非常缓慢的
画出了一个圆
大家可能看出这个圆可能出现了一些问题
我们刚才在编程当中遇到了一些问题
一个是小精灵在画的时候
由于我每次都前进了两步
使得它碰到了这个边界
一旦碰到边界
计算机处理上程序出现了错误
我们可以看到这是刚才我们所
出现的一些错误
到边界上它画出来一些有问题的线
这个时候我们把这段距离
每次前进的步数把它缩小
每次只前进一步
可以看出
那么这样它画出了一个圆
我们用clear把它清除一下
同样初始化
使得这个小精灵回到原点
这个时候 它回到了原点
它也画出了一条线
我们可以把它清掉
清掉之前意味着
最开始的时候
我们还是把笔收上来
初始的动作
在真正画之前
我们再把笔放下来来完成
这个小精灵画的动作
那么精灵画一个圆
虽然看起来是一个连续的圆
事实上它是正的三百六十边形
一点一点把它拼起来
我们之所以在这里讲
通过正多边形来逼近
去画出一个圆来
是因为这个思想在计算机科学当中
是非常关键的
我们一直强调计算机是离散的 是有限的
我们数学当中的圆
这个圆边上的这些点
它是连续的
而体现在计算机科学当中一定是离散的点
只是这些离散的点
在你做逼近的时候 你找的点足够多
像我们用正三百六十边形
去逼近一个圆
给你的感觉是连续的点所构成的圆
这些线似乎是连续的
但是你要理解并深刻记住的是
在计算机科学当中
这些都是由离散的 有限的点来组成
那么我们画出的圆
下面运用一些循环的深入的概念
再去考虑把刚才的图片画出来
我们再来考虑
怎么样用循环把十八个圆画出来
我们仔细的看一下
计算机画这十八个圆的过程
通过这个过程
我们来思考程序该如何编写
刚才我们是用正三百六边形去逼近圆形
看到这些圆的一些变化
观察这个程序的运行过程
事实上大家应该已经看到
小精灵每次画圆的起点
都是固定的 都在（0,0）
只不过角度有些变化
它每次似乎有一个偏转
这十八个圆我们最终偏转了三百六十度
意味着每一次偏转二十度
下面我们就来完成这一段程序
这个精灵画圆的过程
这是正三百六十边形
这是它画了一个圆
而我在这里要画十八个圆
意味着我要重复十八次这个动作
外面还要一个循环
那么这里牵扯到了双重循环的概念
其实每循环一次画了一个圆
我们一共画了十八个圆
每次画圆
并不是同一个圆在同一个位置重复
而是我有一个角度的转换
十八个圆最终要回到原点
也就是转了三百六十度
那么每次转二十度
我们画上旋转二十度
每一次都旋转了二十度
下面来看画圆的过程
先把屏幕清空来看
有同学发现了一些问题
还是不要画正三百六十边形
画三十六边形
每次还是转十度
步数换成五步
这样就会快很多
这个圆有点小
我们还是把它停止
还是十步 重画
画的起点是精灵停在的位置
我们希望它每次从原点开始画
一开始还要让它精灵回到原点
回到(0,0)的位置
同时要求它的方向也要是正确的
指向正右方
再重新开始
这样它就在屏幕的正中
画出来刚才我们所需要的图形
在程序设计这一部分
我们主要是用一些图形学
和简单的游戏作为例子
希望以一种直观的有趣的方式
来帮助你理解程序设计当中的
基本概念和基本思想
我们在前面介绍了变量和函数的概念
下面我们通过两个实际的运用问题
来加深对这两个概念的理解
我们给出的概念是一种直观上的认识
第一个问题依然是基于图形的
这个图形是一个简单的
很有规律的图形
我们希望你用程序也就是计算机
能够把这个图形画出来
分析这个图形 我们说
计算机最擅长的事情
就是这种简单重复劳动
你只要固定了我的计算步骤
那我可以一丝不苟的
不知疲倦的把这个图画出来
我们来分析一下这个图形
用一个小精灵应该怎么样来画出来
我们来分析这个小精灵
应该如何画出这幅图形来
起点在最中间的位置
小精灵从这里开始画
它的动作应该先是前进
前进之后
左拐九十度
继续前进
然后再左拐九十度前进
所以我们说两个动作可以完成
简单的画的序列
用前进以及左转
一个直角弯儿 慢慢的
这两个动作一直重复
最终可以完成
画出这幅图形来
小精灵画这个图形
跟我们之前画正方形有所不同的
最大的区别就在于
我们在画正方形的时候
虽然每次
每次的行动都在前进拐弯前进拐弯
但在这其中每次前进的步长
都是一样的
这样我画出来是一个正方形
而在这个图形当中
每次拐弯之后
再前进的步长实际上比前面的步长
增加了一个增量
它每一次的步长都有一个增加
最终形成了
这样的简单的重复的图形
在这个中间就要用到变量
在正方形当中
它的边长是个常量
它不发生变化
而在这里我们画图的过程中
每次前进的步长
都在发生变化
就可以更好的
体现我们变量的作用
下面我们就把这个程序做一个实现
在实现这个图形的时候
我们考虑设计一个变量
每一个变量都有自己的名字
我们给它请个名字叫长度
叫length
对于它来讲 最开始的初值
我们把它设成20
最开始的边长是20
然后在每次前进之后
在每次拐弯之后
都增加一个增量
这个增量我们把它设为6
假设每次步长在转弯之后
这个增加的数值即为增量为6
这就意味着
变量length这个值
最终实现的时候对应的是内存当中
运行起来之后
它对应的是内存当中一个存储单元
在这个存储单元 最开始的初值是20
每次拐弯之后我们都希望
这个变量能够每次完成
一个自动增加的动作
能够完成一开始就是20加6
变化的方式
因为我的增量为6
所以变量length的变化方式
应该是每次把现在的数值与6相加
然后重新赋給length
也就是重新写到内存当中的单元
所以在第一次转弯过后
在第一次转弯完成之后
我们要完成的动作是
length把它加6
那么这个时候length是从内存当中
读出它的数值
而这个时候的数值是20
20加6的结果读出来就是26
完成这个运算之后 计算结果是26
把26重新赋給length这个变量
也就是把26这个数值
重新写回到内存单元
写到length所代表的内存单元就意味着
26覆盖了原来20的内容
这个时候就再也找不到20所在了
不管你是用磁存储技术
还是固态存储技术
还是各种各样的内存
硬件的存储技术
原有的数值抹掉了
20找不到了 现在只能找到26
再次拐弯之后 再来完成计算的过程
公式是没有变化的 依然是length加6
把它重新赋給length这个变量
这个时候我再来完成这个计算
我读出的length数值从哪来
我再来完成length加6的运算
要从内存当中来
而在内存当中
我现在记录的数值是26
那么26加上6得到的结果就是32
最终32要重新写回到
length这个内存单元
而在这个时候我们说26就被抹掉了
那么得到的内存单元的内容就是32
这是变量
一个完成计算的基本的使用规律
下面就来看我怎么在Scratch当中
定义这个变量
然后根据这个变量
我们该如何画出这个图形来
我们说定义变量在变量这一类的指令当中
第一条是我要生成一个变量
我们给它起个名字就叫length
这个变量对所有的精灵都起作用
对这个长度我们给它赋个初值
我们让最开始的长度为20
那么它的变化
把它写到下面来
它的变化在后续的过程当中
会发生一个新的长度
应该是旧的长度上加6
在操作当中有加法运算
加法运算是个二元运算 需要两个操作数
这两个操作数当中
一个就是原有的length值
在变量当中我需要原有的length的值
然后加上6
这是它的变化的过程
书写这变化的过程还可用另外一条指令
就是这条change指令
用这两条指令我们可以看到
set之后 可以看到在舞台上
这个长度就变成了20
而我每次对它进行加6
双击这条指令代表它的执行
可以看到内存单元的变化
每次它增加了6个
大小增加了6
要完成这个加6的动作
还有另外一条指令就是改变
我们用change一样
可以每次改变它的大小
change它后面的6就表示每次增加6
我们双击它可以看到这个变化
这两条指令完成了同样的工作
用哪条都可以
我们用短一点的
不用delete
变量这件事情我们就处理好了
下面就是怎样完成重复性的工作了
完成这个画图第一步是前进
只是这时候前进的步长不再是10步了
因为每一次前进的步长
都发生了变化
而这个变化我们用length来表示
每次前进一个length长度
length为20
意味着我前进20步
length为26 意味着我前进26步
虽然是一条指令
由于length的变化不一样
所以在屏幕上我看到的结果不一样
它每次画的长度是不一样的
而我每次前进之后
我们画这个图的规律就是
我要完成一个转弯的动作
我每次画的方向不一样
我要改变这个方向
我们用这个来表示
都是转过了一个直角 我用九十度
转过了九十度
我们说画这个图就是这个动作
前进转弯 前进转弯这个动作不断的重复
需要用到的控制结构就是循环
循环是程序设计
三类控制结构当中非常重要的一类
在这里固定一个
循环的次数
循环的表现形式是多种多样的
在后续的程序设计课程学习当中
大家会学到很多
我们在这里只是希望你能够
对基本的程序设计结构
对循环有一个最基本的认识
我们让它循环四十次
每一次画完一步之后
还有一个动作就是修改这个长度
下一次我在前进的长度不一样
因为我们这是画图
所以这个画笔是不能丢掉的
一开始我们先把屏幕清理一下
然后把画笔放下来
我们希望它每次从中心开始画
那么做一个初始化的动作
让这个小精灵走到最中央
这个精灵有点大
我们把精灵缩小点
精灵缩小为原来的百分之二十
我们让它慢一点画
我们如果执行的话
你可以看到它画的速度是非常快的
这条语句出了问题
应该是把画笔放下来
而不是把画笔收回去
把画笔放下来
现在的画笔颜色是紫色
那我们来看画的有点太快了
我们让它慢点画好了
在每笔画完之后
我们给它一个等待的动作
等待的指令在这个控制当中
每笔画完之后等待0.1秒
重新让它画完
我们可以看到它清楚的行进
拐弯 前进 拐弯
最后画完这个图的这个过程
这就是变量
length这个变量
在这里所起的作用
你可以看到它每次画的时候
length的这个数值
在舞台上一直发生着变化
从最开始的初值为20
到最后经过四十次循环之后
变成了260
精灵太大了
我们把它缩小
那么在这也可以对它进行缩小
我可以通过拖曳把它拖到
这个大小合适
那么我们
我现在需要建立某种模型
而这样的模型可能是某种建筑
在这些建筑当中
正方形是非常常见的
有大大小小各种各样的正方形
我需要作三个正方形
大家看到的状况是
在我的某项设计当中
可能是某项工程或某个建筑设计当中
我需要很多个正方形
现在需要三个正方形
我需要计算机能够画出三种正方形
那这三种正方形大小不一
都摆在这里 有的是走十步可以做到的
有的是要走
一百步可以做到
我们说计算机科学家
总是试图寻找一种更一般化的方法
也就是更抽象的方法
来描述这件事情
虽然我们这三段指令
虽然这三个程序的核心思想
都是画正方形
区别仅仅在于正方形的边长不一样
我们在前面讲抽象与计算的时候
提到过函数的概念
我们在讲抽象与计算的时候
特别强调了函数的概念
函数实际上是对自变量
与值之间的一组对应关系的抽象
函数无论在数学当中
还是计算机科学当中
都是非常重要的概念
它以自变量x的输入为基础
通过函数的计算
最终得到一个唯一的值
一个唯一的输出结果
对于我们所画的正方形
在程序设计语言当中
它也提供这样的机制
我可以设计函数
这个函数就是完成一个画正方形的动作
它的自变量是什么
就是我们这里所要求的边长
你给我的边长不一样
我画出的正方形是边长不一样的正方形
你给我边长是十
我就画边长为十的正方形
你给我边长一百
我画出来的就是
边长为一百的正方形
每次的输入不同 我得到的输出
在显示器上所看到的
正方形的大小不一样
我们先来回顾函数的概念
在数学当中 一个函数描述的是
每一个输入值对应唯一输出值
这种对应关系
我们就把函数看做是一种
对输入的处理
最终能得到一个输出的结果
这里指的输入
可以没有输入 也可以有多个输入
就像函数里
我们有一元函数 二元函数
也有常量函数
对于函数的要求是
同样的输入
一定要产生同样的输出结果
在下面这里 我列出了五项
BYOB当中的五项表达式
你来辨别下 这五项表达式
这五个表达式中 哪项不是函数
从这五项当中
严格来讲从数学的角度来讲
A不是函数
因为对于随机数的产生
我们刚才在小鱼找宝物的过程当中
也看到了
我们的横坐标 纵坐标
在黄色的小宝物出现的时候
横坐标 纵坐标它是随机出现的
它可能在屏幕当中任意一个合法的位置上
意味着 每一次我都要用这个函数
我们产生的结果都不一样
随机位置都不一样
这跟数学上对函数的定义
是有矛盾 有冲突的
我们数学上强调同样的输入
要得到确定的同样的输出
那么这五个选项当中
容易发生错误的是最后一个选项
最后一个选项
它没有输入
但事实上函数是允许没有输入的
就是它始终的取值就为真
true 是一个函数
我们看A选项
我们在计算机科学当中
经常会讲随机函数
而我们刚才又强调了它不符合
它跟数学上函数的定义是有冲突的
事实上 随机数的发生器
在计算机科学当中是一个重要的出现
很多时候我们都需要随机数
大家在网络上玩的游戏
包括很多数据的仿真 模拟
我们都需要随机数
随机数的产生
在计算机科学当中有一整套的理论支持
如果大家对随机数感兴趣
对随机数发生器感兴趣
在后续的课程当中
可以去自学一些
计算机类的课程
我们再回到刚才讨论画正方形的问题
我们能不能把
画正方形的这些指令把它一般化
把它抽象出来
使得它可以画任何大小的正方形
现在来看看在BYOB当中是怎么画的
我们想象在数学当中定义正弦函数
定义一个画正方形的函数
那么这件事该怎么做呢
在BYOB当中 它有这样的支持
在BYOB变量这一类的程序代码当中
把他的指令拉到最下
大家可以看到Make a block
我可以利用Make a block这条命令来设计
一个函数
我这个函数叫画正方形
它对所有的精灵都起作用
我希望它画一个正方形
我们说这个函数用来干什么呢
它的自变量是什么呢
这是用来画正方形的
自变量x是什么呢
X就是它的边长
而这个时候我需要一个变量
我就把它叫做边长
用length作为它的边长
下面我们对这个Block Editor
我们在这里定义
自己的函数
这个函数无非就是
我们刚才重复的那些动作
只是这个时候
它画的程度决定于你输入的
你在调用的时候给它的边长是多少
我们现在一样的是重复四次
这个时候我走多远是决定于
我这个边长
我走这个边长这么远
然后转90度
既然是四边形
既然是个画图
我们需要把画笔放下来
同样需要设置
不动画笔的颜色
画完之后把画笔收起来
这就是我们这段函数的定义
下面来看
我在编程的时候我就可以用到
我所定义的这个block
这里就是我定义的block
我把它拉过来
你可以看到我刚才给了它一个自变量
这个自变量是length
我在这里给它一个具体的数值50
我双击它
你可以看到这个小精灵
画了一个正方形
我们刚才画了很多个不同的
我要继续画其它不同的
我在这里画一个边长为100
再双击 你可以看到
屏幕上有点乱
我们把屏幕清一下
这个时候你可以看到
我要求它画两个正方形
你可以看到
每次画完它都回到了原点
先画了一个边长为50的
又画了一个边长为100
所以这就是我们讲的
很重要的一个概念函数
函数是非常重要的抽象
函数的力量也是非常强大的
我们回到函数的定义
点右键Editor
我们可以重新编辑我对函数的定义
我在这里画的是一个正方形
实际上它是一个正的四边形
有没有可能我写一个函数
画出很多正多边形呢
我有没有可能
以正多边形的边数
为一个参数
使得写一个函数既画出正方形
又能画出正六边形 正十二边形
这是可以做的
你可以增加一个变量 这个变量指的是
我们用边数
用这个边数sides来表示这是正几边形
repeat的次数就不是重复四次
我有多少条边
我就要重复多少次
我要把这边
我要重复这么多次
我们把这个函数的名字改掉
因为我就不画square了
我就直接把它改成这个画
这个时候有了边数的概念
边长还是这个边长
只是我这个时候旋转的角度
就不再是90度了
这时我旋转的实际上是有一个度数的变化
它跟我的边数相关
四边形我们旋转的90度
实际上是360度除以4
而三十六边形
我不知道刚刚大家是不是有印象
三十六边形我每次是旋转10度
10度是360度除以36
所以这应该是一个表达式
这个表达式应该是一种
除以的关系
我们要转的角度是什么呢
是360除以边的数目
我们就画出了这样一个正的多边形
我们可以调用它来看
先把屏幕清一下
不要画边长为50
我们画一个四边形
然后边长为10
我们画一个十二边形
你可以看到它从原点开始
首先画出一个正方形 边长为50
然后它又画出了一个正十二边形
边长为10
我们把边长扩大一点
边长20
来看一下 再运行
我不但可以画正四边形
也可以画正多边形
函数在计算机科学中是非常重要的概念
函数有自己的定义域有值域
可能是一个字符串可能是数值计算
也可能是一些参加判断的逻辑变量
对于它的输出它所计算的值
它可能没有输出
对于它的值域而言
它可能有返回值 可能也没有返回值
在返回的值当中 可能是数值的
也可能是文本的
也可能以一些图像
作为程序运行的结果展示给用户来看
函数的输入可能有一个或多个
刚才我们设计了一个函数
用一个函数
短短的几行语句就既可以完成
画正方形 正六边形
各种各样的正多边形
不同的边长
不同的边数的正多边形
我们说这就是抽象的力量所在
而函数之所以强大
就是因为它体现出了抽象的力量所在
我们归纳总结了
在画正多边形过程当中一些
一般化的思想
把这些一般化的思想用函数
在Scratch当中 在BYOB中做了一个实现
最终我们用不超过十行语句
实现了画正多边形的函数
我们用这个短短的函数 很小的函数
就可以画正方形正六边形正十二边形
到最后甚至我们可以用
正三十六 正三百六十边形
去模拟去逼近一个圆
这正是函数的力量所在
也正体现了抽象的力量所在
函数我们说它是一个很强大的机制
函数是非常有力量的
在计算机科学当中函数非常重要
对于函数的概念
我们强调的是
一个输入对应一个唯一的输出
而这个特点
我们说在计算机科学当中非常有意义
它的意义就在于我定义好的函数
只要我对它的实现
把它在做了一个很好的封装
封装在一个盒子里
对于一个固定的输入
我一定会产生固定的输出
不管你在什么样的机器上
也不管你使用什么样的计算环境
这点在计算机科学中之所以重要
是因为利用函数
我可以很好的实现并行并发
每一个函数它的工作是相互独立的
我们下面看一个实际的应用问题
看一下在这个实际的应用问题当中
函数的应用
这个应用是一个中学水平
很简单的应用问题
在一个矩形游泳池的周围
我要建一个环形的过道
并且要在外围围上一圈围栏
游泳池的长和宽由用户从键盘录入
这意味着
你要把游泳池的长和宽都处理成变量
这个公司可能专门建造这种游泳池
而客户不同
它所要求的游泳池的大小不一样
但我希望这一个程序
能够完成
我对所有这类游泳池
我都能计算出它的工程造价
所以要把它处理成变量
那么这里我有两个变量
而且这两个变量要从键盘由用户来输入
过道的宽度是三米
也就是这个图当中灰色的区域
这个过道为三米
对于围栏的造价
每米
这个围栏它是一个周长
算它的周长那么这个造价
是每米的长度上
我们需要花费50块钱
对于过道而言 这是表面积的问题
过道的造价是每平方米30块钱
要求你来计算整个工程的造价
那么这个题是非常简单的应用问题
你肯定会做
现在的问题是我们不让你做
你得让计算机把这事算明白
我们就要利用一些计算环境
不管你是C语言 C++
还是一会我们要用的Scratch?
你要利用
计算机上的计算环境
让计算机把这件事计算出来
对于这道应用题
我们可以粗略的先把流程图画出来
我们整个计算过程就应该是
程序开始之后 首先要输入
这个游泳池的长和宽
都要有长和宽的数值之后
才能完成计算
我们说流程图当中
输入框用平行四边形
输入游泳池的长和宽
输入长和宽
有了长宽之后
我们说剩下的两部运算
就是计算了
有了长和宽的数值之后
我可以计算
围栏的造价
围栏的造价计算完之后
我可以计算过道的造价
假设围栏造价我们用S1来表示
过道造价用S2
这里的长和宽分别用L
和W来表示的话
最后的一步计算应该是
求和输出 求和
S1加上S2
这就是我们计算出来总的造价
求和之后 可以直接输出的
求和之后把这个计算的结果放在S当中
最后一步就应该又回到了输入输出
最后一步又是输入输出
输出S最终的结果
这就完成了我们计算
游泳池这道题相关造价的一个流程图
那么这个流程图过程相对
很直观 很简洁
就是一步一步完成计算就可以了
下面我们就来看 有了这个流程图之后
这是算法 这是流程图
有了这个流程图和算法之后
BYOB在具体的一个程序计算环境当中
怎么样能够让计算机
最终能够算出实实在在的结果来
我们先来分析下这个问题
建造的游泳池都是有规律的
都是长方形的游泳池
对于这个长方形
不管它的长和宽是多少
长方形有它的长和宽
不管它的长和宽多少
把长和宽设计成两个变量
变量都要取名字
在程序里定义好这两个变量之后
程序在运行的时候
计算机会为在两个变量
分配两个内存单元
这两个内存单元放的就是它当时的数值
我们又回到这道题
我们这道题关心的是长方形
我要算围栏的造价
还要算过道的造价
围栏的造价
我关心的是这个长方形的周长
事实上对于任何长方形的周长
应该是长与宽相加
然后再乘以二
对于长方形 我们的面积
它是等于长乘以宽
这写出来是两个公式
但事实上
严格来讲两个函数
只是这两个函数都是二元函数
对于周长 我们给它起个名字
我简单的先写成P
就叫perimeter好了
既然是函数
这是函数名
这个函数
对于这个函数
它的输入有两个
一个是它的长
一个是它的宽
函数的计算公式就是等于
长加宽乘以二
对于长方形的面积 它也是一个二元函数
用area来表示
同样的对于这个函数
它的输入也是两个
前面我们强调过 对于函数而言
它可以没有输入
也可以有多个输入
那么对于面积的计算
它就等于长乘以宽
函数的定义 我们强调的是
对于唯一一组
对于一个固定输入
你要产生同样的计算结果
它的计算结果一定是确定的 唯一的
我们的输入是
两个变量的值 我们把它看做一组输入
那么每一组输入
我们都会产生一个结果
这就是我们讲的符合函数的定义
这就是我们写成二元函数
我们说了用f的形式
就是f(x,y)
只不过这里我们的f(x,y)一个是等于x加y
乘以二 这是周长
另外一个是等于x乘以y
这是f1的话
这是我们的f2 第二个函数 二元函数
等于x乘以y
那么这样
我们就先对着我们分析出来的这两个函数
看看在Scratch当中
如何完成这两个函数的定义
定义这两个函数
这些指令在
变量这类指令代码中
我可以make a block
我们在这里make a block
实际上最终是让它完成一个计算
在画正多边形程序当中
我们用到了函数的概念
我们使用的也是make a block这样的指令
只是在那在画正多边形的时候
这三个选项当中
我们选择的是command
因为这个它不需要任何返回值
它只是把这个动作完成就可以
可以看做是命令式的函数
而这里还有两个其它的选项
一个是reporter
一个是predicate
一个是reporter指的是
我这个函数要有返回值带回来
就像我们这里
我希望你能够把f的数值告诉我
你算出来 不管它的周长 面积是多少
我希望你把这些结果告诉我
就是你要有一个返回值的概念
那么第三个是predicate指的是为此
需要你来回答我下面定义的这个block
要回答是真 是假 是对 是错
你要给出一个回答
我们要计算的是长方形的周长和面积
而最终这个实际应用问题当中
我利用周长和面积
最终来计算出一个造价
我们要用的这个概念就是
我在这个时候我们要用到的是
block的类型
就是reporter
要带有返回值的
你要把周长和面积最终返回来告诉我
选择reporter
那么我们先来计算周长
perimeter
这是你给block也就是这个是函数名
我们给它一个有意义的名字
一看就知道最终它是用来计算周长的
计算周长 它有两个输入
我需要知道你的长和宽
我才能最终告诉你
算出来这个面积是多少
我需要长
点击这个向右的小三角
我们给它一个类型
就是你的输入是什么类型的
我们说这里它是一个数值
数值类型
同样的我还需要宽
一样的数值类型
就是我们在函数定义的
函数定义的公式的左边
这就是f（x,y)
下面就是我要完成函数的计算了
这个函数的计算
是一个简单的算式
我们先把这个算式写出来
这个算式是最终
要进行乘以二动作
计算周长我要乘以二
最终的一个运算是乘法
所以你在写这个运算式的话
要注意优先级
然后才是长和宽相加
我们在运算符这里选择长和宽相加
谁和谁相加呢
长和宽相加
然后乘以二
通过这个颜色的变化 你就可以看到
可以看得出来这个颜色的变化
体现了优先级
先做加法 再做乘法
那么这个结果
我们希望它完成这个运算之后
要把这个结果带回来
在control当中
返回这个数值 用report
你要把这个结果最终告诉
打一个报告给我
这就是我完成了
写一个计算周长的函数
下面就请大家
在你的机器上
写出如何来完成面积计算的函数
如果你还有问题
你可以跟着我一块做
创建一个新的block
这个时候是计算面积
一样的是需要把这个面积的值带回来
所以我把它定义成reporter
同样的
我在这里需要两个变量
计算面积公式更简单 把它们两个相乘
然后再control当中找到report
把这个结果计算出来
还来注意一下这两个变量的数据类型
这就是数据类型 数据结构的概念了
这两个都是数值
要完成数值的乘法运算
在回到变量分类当中 你可以看得到
那么在make a block下面
我有了两个新的函数
这两个函数一个叫area
一个是叫做perimeter
这两个函数 你可以看到
为什么函数是一种抽象
这就是抽象
这两个函数就等于我做好了那两个盒子
在你给了我输入之后
我才能计算出具体的运算结果
而在你给我输入之前
它是两个抽象的概念
两个抽象的定义在这里
我只是知道我这个是用来计算面积的
我这个是用来计算周长的
它只是在这样一些数之间建立联系
我们再回到这道题
在这两个函数当中
我们说我们都定义了长和宽
但这两个概念同样是虚的
在计算机科学当中 我们把两个参数
这是函数的两个参数
在数学当中我们把它叫做自变量
那么这两个参数叫做形式参数
因为它没有实实在在的数值 它是虚的
而在这个应用问题当中
我们定义好了两个函数
这两个函数是抽象的概念
每一个函数都需要两个输入
这是数学当中我们提的的自变量
都需要有长和宽
也就是你那函数计算当中的x和y
那么这两个参数 在你定义函数的时候
你并不知道它具体的数值是多少
这就是我们讲的抽象的概念
它是虚的
在计算机科学当中
它是一个虚的东西
而我们在这里 要完成一个具体的
游泳池的造价的计算当中
长和宽是一个个具体数值
那我们在回到BYOB当中
如何定义一个具体的长和宽
我们要用到的
就是前面我们已经讲过的变量的概念
我们最终要写程序
要这个小精灵完成
这个游泳池造价的计算
对于每一个具体的游泳池
它都有自己的长和宽
那么虽然这个长和宽的数值
最终要由用户从键盘录入
但是它在内存当中
或者程序当中 一定会有一个
唯一的标识 我们给它起个名字
长我们就用L来表示
宽我们就用W来表示
第一个动作就是用户从键盘
来录入长和宽
这牵扯到了
变量的输入
变量的输入
变量的输入实际上就是
这个小精灵要去感知外部环境了
感知道外部这个键盘的变化
我希望从键盘读取输入
这是需要外部
需要小精灵去感知外部的环境
感知这一类指令当中 叫sensing
你可以看到有ask
我们这个地方不是
ask what is your name
长方形的长是多少
how long is the length
你可以看到
我刚才点击这条指令
实际上在右侧 在舞台上
我们可以看到这条指令的执行
小精灵就会问用户
给用户一个提示
这个时候我需要这个长度
我问你长是多少
那么这个时候wait
后面还有一个wait的指令
wait的指令那么程序在运行的时候
在这个时候
它就会等待用户从键盘来录入数值
我在这里就可以完成的录入
那么这个数值读进来之后
它是由一个特定的变量
所有键盘的录入的结果
它先放进一个变量
叫answer当中
那么最终这个answer输入的是这个长度
我们需要把这个
我们需要
把长度设为answer
这是Scratch本身的处理
就是所有键盘录入的结果
它先放到变量answer当中
那么你不用answer我们在这里用l w
因为有两个输入嘛
我用l w 来表示
那么这个时候就要把answer的值付给l
那么下面要做的是 我们的长录入结束了
我们还要把它复制一下
同样的完成宽度的录入
同样它给出用户一个提示
第二次录入的就是宽
这就是我输出围栏的造价
那么下面我们来计算过道的造价
过道实际上是两个长方形面积之差
把两个长方形面积算出了 做一个减法
就算出了过道的
过道的整个表面积
过道的面积我们算出来了
过道的面积算出了之后
我要计算造价
题意说的是每平方米30块钱
做乘法 我的面积这么多
最终要乘以30
那么一共多少平方米呢
同样的 我把做一个输出
总的造价实际上是
这两部分相加
这样我们通过两个简单应用问题
把变量和函数这两个概念
加深一个理解
在程序设计这一单元
我们希望通过一些实例
来让大家对程序设计当中的一些基本概念
和基本思想有一个最直观的认识
在大学计算机基础当中
讨论这部分内容是希望
通过一些直观的有趣的方式
让大家对程序设计有一个入门级的理解
为今后程序设计的学习打好一个基础
程序设计的目的是为了问题的求解
而我们在处理复杂问题的时候
碰到比较大的比较复杂的问题
要进行处理的时候
分析人处理这些问题的方法
实际上我们可以把它归为两大类
一类就是自底向上的
就是我们前面所讲过的
像BYOB的这种处理方式
像搭积木块一样的
我先从一件小事
一件一件小事都做完之后
最终可能完成一个比较好的作品
这是一种搭积木的自底向上的方式
那么另外一类典型的
大问题处理复杂问题的方法
我们说是自顶向下的
我拿到一个大问题之后
我先不去找那么小积木块
我从大问题开始分析
我要达到这样一个目标
最终要求解这个大的问题
我先把它分成一些
一级一级逐步把它细化
一级一级的分解这样的问题
这就是典型的程序设计当中
我们把它叫做结构化程序设计思想
那么下面我们就来讨论
什么是结构化的程序设计思想
它的自顶向下的过程是怎么样来进行的
这样一种方法在计算机的问题求解当中
是非常有力量的
简单的来说这种问题求解方法就是
我先把一个复杂的大问题
把它分解成一些
相对来说比较小的相关的问题
如果这些小的问题对我来说
对计算机而言依然复杂
那我这分解过程一直进行
直到分解成一些非常非常简单的步骤
计算机一看就知道怎么做
那么你的这个自顶向下的分解过程
就可以结束了 我可以去编写程序了
根本的思想还是来自于人类
进行问题求解的思想
在自顶向下的这种问题求解
这种设计过程当中
一个复杂的问题的解决
可以由一系列更小的更简单的
问题解决来组成
那么解决这些小的问题
同样可以由解决更小的更简单的问题来实现
那你不断的持续的这么分解这么做
直到这个问题简单到可以很轻松的解决掉
最后我们把所有解决这些子问题
或者分解出来的这些方案最终拼接回来
组成的就是最终的
原始的大问题的解决方案
刚才我们就已经强调过了
系统的学习是在程序设计
在数据结构 在算法的这些课程当中
但我们希望在大学计算机基础这门课
能够尽可能给你一种直观的认识
至少有一点点思想
为你程序设计的学习
做一个铺垫
我们先从一个具体的问题来入手
我们依然选择的是
图形的问题
我现在希望计算机能够画出这样一个图形
你当然说你可以画
我现在是想让计算机把这个图画出来
那么分析这个图你很快就可以发现
很简单 全部都是线
都是一些线段 我会画线段
即使在BYOB当中
我有起点有终点
通过坐标我可以把它画出来
这就是我们讲的
这是搭积木式的
就是自底向上的方法我可以画
因为我有一个一个小积木块
我知道怎么画线
我把这些线
定好了起点的坐标 终点的坐标
线都画完了 我这幅图也完成了
那下面我们要考虑的是
这是一种求解问题的方法
但是现在我们希望用
这个问题我们来考虑另外一种思路
就是自顶向下
我这个图是不是还有其它的处理方式
能够简洁的把这个图画出来
我们来分析一下这个图
你可以看到这个图有几个
组成部分
其实刚才我们提到过
计算机最擅长于一些简单的重复劳动
所以我试图在这张图当中
我要来找一些规律
最好就是一些简单动作的重复
如果能做成这样 那么计算机画出来就会是
非常简洁
那么计算机画得思路会更清晰一些
分析这张图 画这个图
我们可以看到它有几个部分来组成
那么最好认的这一部分就是
这个正方形
在这个图当中有一个正方形
这我们就可以看成是一个部分
我希望把这个复杂的图一看
冷丁一看 挺复杂的 我怎么画呢
我把它分解一下 把它分成几个部分
这个正方形 我们说是一个部分
我们再来看看其它的还有没有规律的
因为我们前面讲过很多例子了
知道这个正方形怎么画
我们再换一种绿颜色来看
我们再来看看
你可以看到中间有一些有规律的图像
我在这里可以看到一些直角的两底
你可以看到这个动作是不是也是挺有规律的
有四个这样的角
那么除了这四个角 剩下的线
我想大家是不是已经看得挺清楚的了
我画这个复杂的图 我把它分成几个部分
而这独立的每个部分 在部分内部
它是有一些规律
我们可以看得到的
黄色可能不太清楚 用棕色好了
那么剩下的就是这个
井字的这个线了
所以你看现在就覆盖了我所有的线了
假设这个井字线是第二步的话
我们把这个绿色的线看做是第三步
那么画这个大的图我们就把它分成了
第一步我画一个正方形好了
第二步我就四个角 我画一个井字
第三步我把这四个角画出来
当然它们之间有一定的关系
我们在位置上有一些相对的关系
那么这样 我们就完成了最终
画这个图的工作
这个图我们刚才提到过了
自底向上我可以画
每一根线 我知道画线
那么我把所有的线累积在一块
堆积木一样 我最终可以堆出这个图
但是我们换了一种思路
我们自顶向下的往下看
对于这个复杂的图形
从这个复杂的图形当中
我们把它分出了三个部分 它有三个
相对来说比这个图
不那么复杂的三个部分来组成
我们来看看
这就是我们讲的自顶向下的最顶层
就最初的算法我怎么样来考虑呢
虚线的部分可以看到整个图形
我要画一个正方形
这是你的第一步 我把这个正方形画出来
第二步
我要把这个井字画出来
这个四根线
这是小精灵都可以做到的
背着一支笔我可以把这些线画出来
最后一步我需要把四个角画出来
我们讲了这个问题的顶层设计
所以在第一次的分解当中
我把这个复杂的问题
分成了三个子问题
这三个子问题
相比原始问题而言
相对简单 但是并没有简单到
我一下就知道怎么做
当然对于正方形 我们原来画过 你肯定知道
这个正方形我会画
我知道该怎么做
但事实上 它们最终
都还需要进一步的求精 就是在这一层
还没有落到我能写程序的时候
我们还要继续把它进行分解
直到它简单到 我一看我就知道怎么写程序了
那么这个分解过程就可以结束了
那么这中间的一二三步
这三步我们都还可以继续进行分解
那么在你自顶向下的第一层
这样我们得到的结果实际上是四步
那么第一步 我们说要加上一个初始化
意味着我要确定起点的坐标
画笔的颜色
我们给它一个初始化的工作
对于初始化工作
我们也有一些具体的步骤要做 第一步
我要确定你的起点在哪里 起点的坐标在哪里
第二我要背好画笔
第三我可能还要设置一些
画笔的颜色
这是在你完成画整个图之前
也就是求解这个复杂问题之前的初始化工作
接下来的第一步就是画这个正方形
那么画这个正方形 我们前面已经
完成了 前面我们已经写过了一个函数了
那么在这里我们不借用那个函数
重新再把画正方形的过程写一遍
正方形无非是画四条边
在这个时候我依然可以累积
我把这四条边起点终点定义好了
那我这个正方形就画出来了
这是一种方法
用这种方法我可以把这个正方形画出来
那么对于这一步的求精我们还有第二种方法
就是前进 拐弯
我们同样可以完成
重复四次
一样我们可以把这个正方形画出来
因为前面的画笔我已经带好了
我们一直都在强调的就是
计算机科学家 也就是程序设计的开发人员
一直试图写出的是
简洁的清晰的程序
我们一般不会把
这样一个步骤写八步 左转前进
我们一般会把它写成循环的形式
也就是同样的步骤我们把它重复四次
我重复这个动作四次 把它写成一个循环
这是我们一直强调的
这也是循环的作用所在
这是我们对第一步的求精
实际上第一步的求精我们说 到这个时候
这一步的求精就可以截止了
因为走到这里 事实上已经非常清楚的知道
接下来该怎么做了
那么这一步的求精我们得到的算法
可以说是我们前面介绍的伪代码
我用伪代码来编写的这个计算过程
那么下面就是画这个井字线了
画井字线 我们说就四根线
起点终点 我们可以把这四根线
确定了坐标之后 把这四根线画出来
那么这一步的求精 事实上
在这个层次上也可以结束了
因为我很清楚这个线该怎么画
我可以直接去写程序了
这是我们第二层的求精进行到了第二步
第二层的求精 最后一步
就是把这四个角画出来
因为这四个角 我们可以把它
再分解就是
我画左上角右上角左下角右下角
我把这四个角画出来
那么到这个时候我们说这件事还没完
我怎么画左上角 我怎么画右上角
所以这一步还需要更进一步的求精
所以我们可以体会到这个
自顶向下的这个问题求解的过程
实际上它是一个逐步细化的一个过程
那么有些步可能在第二层我的求精就结束了
而有些步可能还需要继续分解
直到分解到我可以看着写出程序来了
程序已经很清晰的呈现它的结构了
那么这个分解的过程就可以结束了
那么这种自顶向下的逐步细化的过程
实际上贯穿了软件设计 算法设计
以及程序设计的整个过程
对于复杂的软件开发
我们将软件的体系结构
按照自顶向下的方式
对各个层次的过程细节
和数据细节逐层的细化
直到用程序设计语言的语句能够实现为止
从而最后确立整个的体系结构
这就是我们强调的结构化程序设计思想
那么之所以把它叫做结构化程序设计思想
这个结构指的就是
在我们程序设计基础当中的三种
基本控制结构
顺序结构 循环结构 分支结构
在结构化的程序设计方法当中
强调的就是自顶向下的逐步求精的过程
将问题求解由抽象
逐步具体化
那么从这也可以看得到
你对问题的分解是从哪开始的
从最初的抽象开始的
如果你最初的抽象做的不好
那么很可能最终
得到的就是一个不好的程序不好的软件
所以抽象基础很多都依赖于你的数学基础
这也是我们学习计算机
为什么那么强调数学的原因所在
那么在结构化程序设计思想当中
我们另外一个强调的就是模块化的设计
我们把它分成一块一块
就像我们刚才那个复杂的图
我们把它分成了三个部分
那么每一个部分的实现
都可以把它实现成一个模块
这一个模块是用来画正方形的
这一个模块就是用来画井字图的
根据模块功能把它划分
可能是三个 可能是若干个 更多个
那么如果需要的话也可以
对它继续进行划分
所以这个分解是逐层进行的
我们刚才已经强调了这个结构的含义
为什么把它叫做结构化
实际上是由高级语言正确的来实现这三种
基本的程序结构
这三种结构指的就是顺序的
就在计算机当中的序是非常关键的
选择结构也就是我们的分支我们的判断
如果 那么 否则这样一种判断
另外一类重要的程序结构就是循环了
循环结构 我认为这是计算机强大的原因所在
就是我可以可靠的稳定的
不计疲劳的一遍一遍的
做这样一些简单重复劳动
而且只要你的程序不错 我就不错
只要你人不犯错 机器是不会犯错的
关键是你要理解机器 理解它的运转模式
